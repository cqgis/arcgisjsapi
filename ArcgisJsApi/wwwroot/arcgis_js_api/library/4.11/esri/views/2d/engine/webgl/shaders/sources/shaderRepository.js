// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.11/esri/copyright.txt for details.
//>>built
define(["require","exports"],function(a,b){return{background:{"background.frag":"uniform lowp vec4 u_color;\r\nvoid main() {\r\n  gl_FragColor \x3d u_color;\r\n}\r\n","background.vert":"attribute vec2 a_pos;\r\n\r\nuniform highp mat3 u_dvsMat3;\r\nuniform mediump float u_coord_range;\r\nuniform mediump float u_depth;\r\n\r\nvoid main() {\r\n  vec3 v_pos \x3d u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0);\r\n  gl_Position \x3d vec4(v_pos.xy, 0.0, 1.0);\r\n}\r\n"},bitBlit:{"bitBlit.frag":"uniform lowp sampler2D u_tex;\r\nuniform lowp float u_opacity;\r\n\r\nvarying mediump vec2 v_uv;\r\n\r\nvoid main() {\r\n  lowp vec4 color \x3d texture2D(u_tex, v_uv);\r\n\r\n  // Note: output in pre-multiplied alpha for correct alpha compositing\r\n  gl_FragColor \x3d color *  u_opacity;\r\n}\r\n",
"bitBlit.vert":"attribute vec2 a_pos;\r\nattribute vec2 a_tex;\r\n\r\nvarying mediump vec2 v_uv;\r\n\r\nvoid main(void) {\r\n  gl_Position \x3d vec4(a_pos, 0.0, 1.0);\r\n  v_uv \x3d a_tex;\r\n}\r\n"},highlight:{"blur.frag":"// A gaussian blur shader. It blurs the alpha channel of its input\r\n// according to 4 different sigma and stores the results into the\r\n// four channel of the target framebuffer.\r\n\r\n// It is intended to be called twice; the first time to perform an\r\n// horizontal blur, and a second time to perform a vertical blur.\r\n\r\n// This shader is used to turn the highlight mask into a highlight\r\n// map. The highlight map is an approximation of the signed distance\r\n// field of the mask.\r\n\r\n\r\n// Interpolated texture coordinates.\r\nvarying mediump vec2 v_texcoord;\r\n\r\n// Blur direction information. There are two possible\r\n// configurations that the host code can use.\r\n//  - [1, 0, 1/WIDTH, 0] Used when blurring horizontally. In this\r\n//    case u_direction[0] \x3d 1 is expressed in pixel and is fed to\r\n//    the gauss function to produce the value of the gaussian weight\r\n//    for that pixel, while u_direction[2] \x3d 1/WIDTH is in texel units\r\n//    and is used to sample the right texel from the texture map.\r\n//  - [0, 1, 0, 1/HEIGHT] Used when blurring vertically. In this\r\n//    case u_direction[1] \x3d 1 is expressed in pixel and is fed to\r\n//    the gauss function to produce the value of the gaussian weight\r\n//    for that pixel, while u_direction[3] \x3d 1/HEIGHT is in texel units\r\n//    and is used to sample the right texel from the texture map.\r\nuniform mediump vec4 u_direction;\r\n\r\n// Source to destination channel selection matrix.\r\nuniform mediump mat4 u_channelSelector;\r\n\r\n// The highlight map is obtained by blurring the alpha channel of the highlight\r\n// mask accroding to these 4 values of the gaussian's sigma parameter.\r\nuniform mediump vec4 u_sigmas;\r\n\r\n// This is the highlight mask if we have not blurred horizontally yet, otherwise\r\n// it is the horizontally blurred highlight map and blurring it one more time\r\n// vertically will complete the process.\r\nuniform sampler2D u_texture;\r\n\r\n// The gaussian kernel. Note that it lacks the normalization constant, because\r\n// we want to store it unnormalized in the highlight map (i.e. having a peak\r\n// value of 1). Note also that we are using the SIMD (single instruction, multiple\r\n// data) capabilities of the GPU to compute four different gaussian kernels, one\r\n// for each sigma.\r\nmediump vec4 gauss4(mediump vec2 dir) {\r\n  return exp(-dot(dir, dir) / (2.0 * u_sigmas * u_sigmas));\r\n}\r\n\r\n// Same as above but uses only channel 3, aka `w`, aka `q`, aka `a`.\r\nmediump float gauss1(mediump vec2 dir) {\r\n  return exp(-dot(dir, dir) / (2.0 * u_sigmas[3] * u_sigmas[3]));\r\n}\r\n\r\nmediump vec4 selectChannel(mediump vec4 sample) {\r\n  return u_channelSelector * sample;\r\n}\r\n\r\n// Sample the input texture and accumulated its gaussian weighted value and the\r\n// total weight; operates on all four channels.\r\nvoid accumGauss4(mediump float i, inout mediump vec4 tot, inout mediump vec4 weight) {\r\n  // Computes the gaussian weights, one for each sigma.\r\n  // Note that u_direction.xy is [1, 0] when blurring horizontally and [0, 1] when blurring vertically.\r\n  mediump vec4 w \x3d gauss4(i * u_direction.xy);\r\n\r\n  // Accumumates the values.\r\n  // Note that u_direction.xy is [1/WIDTH, 0] when blurring horizontally and [0, 1/HEIGHT] when blurring vertically.\r\n  tot +\x3d selectChannel(texture2D(u_texture, v_texcoord + i * u_direction.zw)) * w;\r\n\r\n  // Accumulates the weights.\r\n  weight +\x3d w;\r\n}\r\n\r\n// Sample the input texture and accumulated its gaussian weighted value and the\r\n// total weight; operates on a single channel.\r\nvoid accumGauss1(mediump float i, inout mediump float tot, inout mediump float weight) {\r\n  // Computes the gaussian weights, using only the last sigma.\r\n  // Note that u_direction.xy is [1, 0] when blurring horizontally and [0, 1] when blurring vertically.\r\n  mediump float w \x3d gauss1(i * u_direction.xy);\r\n\r\n  // Accumumates the values.\r\n  // Note that u_direction.xy is [1/WIDTH, 0] when blurring horizontally and [0, 1/HEIGHT] when blurring vertically.\r\n  tot +\x3d selectChannel(texture2D(u_texture, v_texcoord + i * u_direction.zw))[3] * w;\r\n\r\n  // Accumulates the weights.\r\n  weight +\x3d w;\r\n}\r\n\r\nvoid main(void) {\r\n  // Initialize accumulated values and weights to zero.\r\n  mediump float tot \x3d 0.0;\r\n  mediump float weight \x3d 0.0;\r\n\r\n  // Accumulates enough samples. These will be taken\r\n  // horizontally or vertically depending on the value\r\n  // of u_direction.\r\n  accumGauss1(-4.0, tot, weight);\r\n  accumGauss1(-3.0, tot, weight);\r\n  accumGauss1(-2.0, tot, weight);\r\n  accumGauss1(-1.0, tot, weight);\r\n  accumGauss1(0.0, tot, weight);\r\n  accumGauss1(1.0, tot, weight);\r\n  accumGauss1(2.0, tot, weight);\r\n  accumGauss1(3.0, tot, weight);\r\n  accumGauss1(4.0, tot, weight);\r\n\r\n  // Originally we were performing 4 blurs in parallel;\r\n  // Now we store the only result in the alpha component.\r\n  // dari8942: In theory we could disable writing to rgb\r\n  // using a color mask but I don't really feel like messing\r\n  // with that now.\r\n  gl_FragColor \x3d vec4(0.0, 0.0, 0.0, tot / weight);\r\n}\r\n",
"highlight.frag":"// Takes as input the highlight map, estimated the signed distance field,\r\n// and shades the fragments according to their estimated distance from the\r\n// edge of the highlighted feature.\r\n\r\n// A shade texture is used to turn distance values into colors; the shade\r\n// texture is basically a color gradient and is recomputed on the host\r\n// every time that the user alters the highlight options.\r\n\r\n// Interpolated texture coordinates.\r\nvarying mediump vec2 v_texcoord;\r\n\r\n// The highlight map. Each channel is a blurred\r\n// version of the alpha channel of the highlight mask.\r\n//  - Channel 0 (red) corresponds to a gaussian blur with sigma \x3d u_sigmas[0];\r\n//  - Channel 1 (green) corresponds to a gaussian blur with sigma \x3d u_sigmas[1];\r\n//  - Channel 2 (blue) corresponds to a gaussian blur with sigma \x3d u_sigmas[2];\r\n//  - Channel 3 (alpha) corresponds to a gaussian blur with sigma \x3d u_sigmas[3];\r\n// As of today, only channel 3 is used for distance estimation.\r\n// But the availability of different amounts of blur leaves the\r\n// door open to multi-scale approaches.\r\nuniform sampler2D u_texture;\r\n\r\n// The highlight map was obtained by blurring the alpha channel of the highlight\r\n// mask accroding to these 4 values of the gaussian's sigma parameter.\r\nuniform mediump vec4 u_sigmas;\r\n\r\n// A 1-D texture used to shade the highlight.\r\nuniform sampler2D u_shade;\r\n\r\n// The 1-D shade texture is spreaded between u_minMaxDistance[0] and u_minMaxDistance[1].\r\nuniform mediump vec2 u_minMaxDistance;\r\n\r\n// Signed distance estimation.\r\nmediump float estimateDistance() {\r\n  // Use the largest sigma and the corresponding distance value stored in the\r\n  // last channel of the highlight map.\r\n  mediump float sigma \x3d u_sigmas[3];\r\n  mediump float y \x3d texture2D(u_texture, v_texcoord)[3];\r\n\r\n  // Estimates the distance by linearization and local inversion around\r\n  // the inflection point. The inflection point is in x \x3d 0.\r\n  const mediump float y0 \x3d 0.5;                           // Value of the convolution at the inflection point.\r\n  mediump float m0 \x3d 1.0 / (sqrt(2.0 * 3.1415) * sigma);  // Slope of the convolution at the inflection point.\r\n  mediump float d \x3d (y - y0) / m0;                        // Inversion of a local linearization.\r\n\r\n  // Return the estimated distance.\r\n  return d;\r\n}\r\n\r\n// Shading based on estimated distance.\r\nmediump vec4 shade(mediump float d) {\r\n  // Maps the sampled distance from the [A, D] range (see HighlightRenderer::setHighlightOptions) to [0, 1].\r\n  mediump float mappedDistance \x3d (d - u_minMaxDistance.x) / (u_minMaxDistance.y - u_minMaxDistance.x);\r\n\r\n  // Force to [0, 1]; it should not be necessary because the shade texture uses the CLAMP address mode, so\r\n  // this should happen anyway internally to the sampler, but in practice it is needed to avoid weird\r\n  // banding artifacts.\r\n  // We don't really know if we need this or not.\r\n  mappedDistance \x3d clamp(mappedDistance, 0.0, 1.0);\r\n\r\n  // Sample the 1-D shade texture on its center line (i.e. on t\x3d0.5).\r\n  return texture2D(u_shade, vec2(mappedDistance, 0.5));\r\n}\r\n\r\nvoid main(void) {\r\n  // Estimate the distance.\r\n  mediump float d \x3d estimateDistance();\r\n\r\n  // Shade the distance.\r\n  gl_FragColor \x3d shade(d);\r\n}\r\n",
"textured.vert":"// Identity vertex shader that outputs an untransformed 2-D vertex\r\n// and passes its texture coordinates unchanged to the interpolator.\r\n\r\n// Vertex position.\r\nattribute mediump vec2 a_position;\r\n\r\n// Texture coordinates.\r\nattribute mediump vec2 a_texcoord;\r\n\r\n// Texture coordinates to be interpolated.\r\nvarying mediump vec2 v_texcoord;\r\n\r\nvoid main(void) {\r\n  // Pass the position unchanged.\r\n  gl_Position \x3d vec4(a_position, 0.0, 1.0);\r\n\r\n  // Pass the texture coordinates unchanged.\r\n  v_texcoord \x3d a_texcoord;\r\n}\r\n"},
magnifier:{"magnifier.frag":"uniform lowp vec4 u_background;\r\nuniform mediump sampler2D u_readbackTexture;\r\nuniform mediump sampler2D u_maskTexture;\r\nuniform mediump sampler2D u_overlyTexture;\r\n\r\nvarying mediump vec2 v_texCoord;\r\n\r\nvoid main(void)\r\n{\r\n  lowp vec4 color \x3d texture2D(u_readbackTexture, v_texCoord);\r\n  color \x3d color + (1.0 - color.a) * u_background;\r\n\r\n  // calculate the grayscale value of the mask:\r\n  lowp vec4 mask_color \x3d texture2D(u_maskTexture, v_texCoord);\r\n  lowp float gray \x3d 1.0 - dot(mask_color, vec4(0.3, 0.59, 0.11, 0));\r\n  // make all the map color outside the mask black\r\n  color *\x3d gray;\r\n\r\n  lowp vec4 overley_color \x3d texture2D(u_overlyTexture, v_texCoord);\r\n\r\n  // premultiply the overlay color\r\n  overley_color.rgb *\x3d overley_color.a;\r\n  gl_FragColor \x3d overley_color + (1.0 - overley_color.a) * color;\r\n}\r\n",
"magnifier.vert":"precision mediump float;\r\n\r\nattribute mediump vec2 a_pos; // encoded values are 0 and 1\r\n\r\nuniform mediump vec2 u_drawPos; // the center position of the magnifier\r\nuniform mediump float u_width; // the width of the magnifier in normalized display coords\r\nuniform mediump float u_height; // the height of the magnifier in normalized display coords\r\n\r\nvarying mediump vec2 v_texCoord;\r\n\r\n\r\nvoid main(void)\r\n{\r\n  v_texCoord \x3d a_pos;\r\n  vec2 coord \x3d u_drawPos + vec2(a_pos - 0.5) * vec2(u_width, u_height);\r\n  gl_Position \x3d vec4(coord, 0.0, 1.0);\r\n}\r\n"},
materials:{"constants.glsl":"const float C_DEG_TO_RAD \x3d 3.14159265359 / 180.0;\r\nconst float SIGNED_BYTE_TO_UNSIGNED \x3d 128.0;\r\n\r\n// markers\r\nconst float SOFT_EDGE_RATIO \x3d 1.0; // use blur here if needed\r\n\r\n// lines\r\nconst float THIN_LINE_WIDTH_FACTOR \x3d 1.1;\r\n\r\n// meaning that a 2 pixels line width is considered a thin line\r\nconst float THIN_LINE_HALF_WIDTH \x3d 1.0;\r\n\r\n// labels \r\nconst float OFFSET_PRECISION \x3d 1.0 / 8.0;\r\nconst float OUTLINE_SCALE \x3d 1.0 / 5.0;\r\nconst float SDF_FONT_SIZE \x3d 24.0;\r\n\r\n// maximum SDF distance of 8 pixels represent the distance values that range from -2 inside the\r\n// geometry to 6 on the outside. 6 is actually the maximum distance outside the glyph, therefore\r\n// it is the limitation of the halo which is 1/4 of the geometry size.\r\nconst float MAX_SDF_DISTANCE \x3d 8.0;\r\n\r\nconst float PLACEMENT_PADDING \x3d 8.0;\r\n\r\n\r\nconst float EPSILON \x3d 0.0000001; \r\n\r\nconst int MAX_FILTER_COUNT \x3d 2;\r\n",
"effects.glsl":"\r\nuniform mat4 u_insideEffectMat4[ MAX_FILTER_COUNT ];\r\nuniform mat4 u_outsideEffectMat4[ MAX_FILTER_COUNT ];\r\n\r\nvec4 getEffectColor(in vec4 color, in float filterFlags) {\r\n  vec4 outColor \x3d vec4(color);\r\n\r\n  // default visibility filter is index 0, index 1+ are effects\r\n  for (int i \x3d 1; i \x3c EFFECT_COUNT + 1; i++) {\r\n    float bit \x3d getBit(filterFlags, i);\r\n    \r\n    outColor \x3d u_insideEffectMat4[ i ] * (bit  * outColor) + u_outsideEffectMat4[ i ] * ((1.0 - bit) * outColor);\r\n  }\r\n  \r\n  return outColor; \r\n}\r\n\r\nvoid applyFilter(inout vec4 color, inout vec3 pos, in float filterFlags) {\r\n\r\n  // default visibility filter is index 0, index 1+ are effects\r\n  for (int i \x3d 0; i \x3c EFFECT_COUNT + 1; i++) {\r\n    float bit \x3d getBit(filterFlags, i); \r\n\r\n    color \x3d u_insideEffectMat4[ i ] * (bit  * color) + u_outsideEffectMat4[ i ] * ((1.0 - bit) * color);\r\n  }\r\n\r\n  // If we are not visible, clip the vertex if we are doing a hit-test\r\n  pos.z +\x3d 2.0 * (1.0 - getBit(filterFlags, 0)); \r\n}\r\n\r\nvoid applyFilterLabels(inout vec4 color, inout vec3 pos, in float filterFlags) {\r\n  float bit \x3d getBit(filterFlags, 0); \r\n\r\n  pos.z +\x3d 2.0 * (1.0 - bit);\r\n\r\n  // When outsideLabelsVisible is false, we also clip labels if they fail any effect filter\r\n#ifndef OUTSIDE_LABELS_VISIBLE\r\n  for (int i \x3d 1; i \x3c EFFECT_COUNT + 1; i++) {\r\n    float bit \x3d getBit(filterFlags, i); \r\n\r\n    pos.z +\x3d 2.0 * (1.0 - bit);\r\n  }\r\n#endif\r\n}\r\n",
fill:{"fill.frag":"precision highp float;\r\n\r\n#include \x3cmaterials/constants.glsl\x3e\r\n\r\n#ifdef ID\r\n\r\nvarying highp vec4 v_id;\r\n\r\n#endif // ID\r\n\r\n#ifdef PATTERN\r\n\r\nuniform lowp sampler2D u_texture;\r\n\r\nvarying mediump vec4 v_tlbr;\r\nvarying mediump vec2 v_tileTextureCoord;\r\n\r\n#endif // PATTERN\r\n\r\n#ifdef DOT_DENSITY\r\n\r\nuniform mediump mat4 u_dotColors[ 2 ];\r\nuniform sampler2D u_dotTextures[ 2 ];\r\nuniform vec4 u_dotBackgroundColor;\r\n\r\nvarying highp vec4 v_dotThresholds[ 2 ];\r\nvarying vec2 v_dotTextureCoords;\r\n\r\n#endif\r\n\r\nvarying lowp vec4 v_color;\r\nvarying lowp float v_opacity;\r\n\r\nfloat max4(vec4 target) {\r\n  return max(max(max(target.x, target.y), target.z), target.w);\r\n}\r\n\r\nvoid main() {\r\n\r\n#ifdef ID\r\n\r\n  gl_FragColor \x3d v_id;\r\n\r\n#elif defined(PATTERN)\r\n\r\n  // normalize the calculated texture coordinate such that it fits in the range of 0 to 1.\r\n  mediump vec2 normalizedTextureCoord \x3d mod(v_tileTextureCoord, 1.0);\r\n  // interpolate the image coordinate between the top-left and the bottom right to get the actual position to sample.\r\n  // after normalizing the position, we get a value ranging between 0 and 1 which refers to the entire texture, however\r\n  // we need to only sample from area that has our sprite in the mosaic.\r\n  mediump vec2 samplePos \x3d mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\r\n  // sample the sprite mosaic\r\n  lowp vec4 color \x3d texture2D(u_texture, samplePos);\r\n  gl_FragColor \x3d v_opacity * v_color * color;\r\n\r\n#elif defined(DOT_DENSITY) \x26\x26 !defined(HIGHLIGHT)\r\n\r\n  vec4 textureThresholds0 \x3d texture2D(u_dotTextures[0], v_dotTextureCoords);\r\n  vec4 textureThresholds1 \x3d texture2D(u_dotTextures[1], v_dotTextureCoords);\r\n\r\n  vec4 difference0 \x3d v_dotThresholds[0] - textureThresholds0;\r\n  vec4 difference1 \x3d v_dotThresholds[1] - textureThresholds1;\r\n\r\n#ifdef DD_DOT_BLENDING\r\n\r\n  vec4 isPositive0 \x3d step(0.0, difference0);\r\n  vec4 isPositive1 \x3d step(0.0, difference1);\r\n\r\n  float weightSum \x3d dot(isPositive0, difference0) + dot(isPositive1, difference1);\r\n  float lessThanEqZero \x3d step(weightSum, 0.0);\r\n  float greaterThanZero \x3d 1.0 - lessThanEqZero ;\r\n  float divisor \x3d (weightSum + lessThanEqZero); // Guard against divide by zero\r\n\r\n  vec4 weights0 \x3d difference0 * isPositive0 / divisor;\r\n  vec4 weights1 \x3d difference1 * isPositive1 / divisor;\r\n\r\n  vec4 dotColor \x3d u_dotColors[0] * weights0 + u_dotColors[1] * weights1;\r\n\r\n  gl_FragColor \x3d greaterThanZero * dotColor + lessThanEqZero * u_dotBackgroundColor;\r\n\r\n#else\r\n\r\n  float diffMax \x3d max(max4(difference0), max4(difference1));\r\n  float lessThanZero \x3d step(diffMax, 0.0);\r\n  float greaterOrEqZero \x3d 1.0 - lessThanZero;\r\n\r\n  vec4 isMax0 \x3d step(diffMax, difference0);\r\n  vec4 isMax1 \x3d step(diffMax, difference1);\r\n\r\n  vec4 dotColor \x3d u_dotColors[0] * isMax0 + u_dotColors[1] * isMax1;\r\n\r\n  gl_FragColor \x3d greaterOrEqZero * dotColor + lessThanZero * u_dotBackgroundColor;\r\n\r\n#endif\r\n\r\n#else\r\n\r\n  gl_FragColor \x3d v_opacity * v_color;\r\n\r\n#endif // PATTERN\r\n\r\n#ifdef HIGHLIGHT\r\n\r\n  gl_FragColor.a \x3d 1.0;\r\n\r\n#endif // HIGHLIGHT\r\n}\r\n",
"fill.vert":"precision mediump float;\r\n\r\n#include \x3cmaterials/constants.glsl\x3e\r\n#include \x3cmaterials/utils.glsl\x3e\r\n#include \x3cmaterials/vv.glsl\x3e\r\n#include \x3cmaterials/effects.glsl\x3e\r\n\r\nattribute vec2 a_pos;\r\nattribute vec4 a_id;                // objectId in RGBA components\r\nattribute float  a_visible;         // one byte controlling the visibility of the vertex (separate buffer),\r\n\r\n#ifndef DOT_DENSITY\r\nattribute vec4 a_color;\r\nattribute vec4 a_tlbr;\r\nattribute vec4 a_aux1;\r\nattribute vec2 a_aux2;\r\nattribute vec4 a_aux3;              // encodes a bitset (CIM) detailing vv locking\r\n#endif\r\n\r\n#if defined(VV_COLOR) || defined(VV_OPACITY)\r\nattribute highp vec4 a_vv;\r\n#endif\r\n\r\nuniform highp mat3 u_dvsMat3;      // premultiplies DisplayMat3 * ViewMat3 * ScreenMat3\r\nuniform highp float u_pixelRatio;\r\n\r\nvarying lowp vec4 v_color;\r\nvarying lowp float v_opacity;\r\n\r\n#ifdef ID\r\nvarying highp vec4 v_id;\r\n#endif\r\n\r\n#ifdef PATTERN\r\nuniform mediump float u_zoomFactor;\r\nuniform mediump vec2 u_mosaicSize;\r\n\r\nvarying mediump vec4 v_tlbr;\r\nvarying mediump vec2 v_tileTextureCoord;\r\n#endif\r\n\r\n#ifdef DOT_DENSITY\r\nattribute highp vec4 a_dd1;\r\nattribute highp vec4 a_dd2;\r\n\r\nuniform float u_dotValue;\r\nuniform float u_tileDotsOverArea; \r\n\r\nuniform float u_dotTextureDotCount;\r\nuniform float u_tileZoomFactor; \r\n\r\nvarying vec4 v_dotThresholds[ 2 ]; \r\nvarying vec2 v_dotTextureCoords;\r\n\r\nvec4 dotThreshold(vec4 featureAttrOverFeatureArea, float dotValue, float tileDotsOverArea) {\r\n  return featureAttrOverFeatureArea * (1.0 / dotValue)  * (1.0 / tileDotsOverArea);\r\n}\r\n#endif\r\n\r\nvoid main()\r\n{\r\n// Arguably DotDensity should be extracted to its own shader. This gets a bit\r\n// fungly because DD uses a signifcantly different stride\r\n#ifndef DOT_DENSITY \r\n  float a_bitset \x3d a_aux3.w; \r\n  float isColorLocked \x3d getBit(a_bitset, 0);\r\n  \r\n  v_color \x3d a_color;\r\n#else\r\n  v_color \x3d vec4(0.0, 0.0, 0.0, 1.0);    // for highlight\r\n#endif\r\n  v_opacity \x3d 1.0;\r\n  \r\n#ifdef ID\r\n  v_id \x3d a_id;\r\n#endif\r\n  \r\n#ifdef VV_OPACITY\r\n  v_opacity \x3d getVVOpacity(a_vv.y);\r\n#endif\r\n  \r\n#ifdef VV_COLOR\r\n  v_color \x3d getVVColor(a_vv.x, v_color, isColorLocked);\r\n#endif\r\n  \r\n#ifdef PATTERN\r\n  vec2 aux2 \x3d (1.0 / SIGNED_BYTE_TO_UNSIGNED) * a_aux2;\r\n  vec2 symbolOffset \x3d u_zoomFactor * (a_aux1.zw - SIGNED_BYTE_TO_UNSIGNED);\r\n  mat3 patternMatrix \x3d mat3(1.0);\r\n\r\n  // calculate the pattern matrix\r\n  patternMatrix[0][0] \x3d 1.0 / (u_zoomFactor * a_aux1.x * aux2.x);\r\n  patternMatrix[1][1] \x3d 1.0 / (u_zoomFactor * a_aux1.y * aux2.y);\r\n\r\n  // calculate the texture coordinates of the current vertex. It will of course get interpolated.\r\n  // The pattern matrix is a 3x3 scale matrix which 'tiles' the texture inside the tile, translating from\r\n  // tile coordinates to texture coordinates.\r\n  v_tileTextureCoord \x3d (patternMatrix * vec3(a_pos + symbolOffset, 1.0)).xy;\r\n  v_tlbr \x3d a_tlbr / u_mosaicSize.xyxy;\r\n\r\n#elif defined(DOT_DENSITY)\r\n  float size \x3d u_tileZoomFactor * 512.0 * 1.0 / u_pixelRatio;\r\n\r\n  v_dotThresholds[0] \x3d dotThreshold(a_dd1, u_dotValue, u_tileDotsOverArea);\r\n  v_dotThresholds[1] \x3d dotThreshold(a_dd2, u_dotValue, u_tileDotsOverArea);\r\n  v_dotTextureCoords \x3d (a_pos + 0.5) / size;\r\n\r\n#endif\r\n  vec3 v_pos \x3d u_dvsMat3 * vec3(a_pos, 1.);\r\n\r\n  applyFilter(v_color, v_pos, a_visible);\r\n  \r\n  gl_Position \x3d vec4(v_pos, 1.0);\r\n}\r\n"},
icon:{"icon.frag":"precision mediump float;\r\n\r\n#include \x3cmaterials/constants.glsl\x3e\r\n#include \x3cmaterials/utils.glsl\x3e\r\n#include \x3cutil/encoding.glsl\x3e\r\n#include \x3cmaterials/effects.glsl\x3e\r\n#include \x3cmaterials/constants.glsl\x3e\r\n\r\nuniform lowp sampler2D u_texture;\r\n\r\nvarying lowp vec2 v_tex;\r\nvarying lowp float v_transparency;\r\nvarying mediump vec2 v_size;\r\nvarying lowp vec4 v_color;\r\nvarying float v_visible;\r\n\r\n#ifdef SDF\r\nvarying lowp vec4 v_outlineColor;\r\nvarying mediump float v_outlineWidth;\r\nvarying float v_overridingOutlineColor;\r\n#endif // SDF\r\n\r\n#ifdef HIGHLIGHT\r\nvarying float v_isThinGeometry;\r\n#endif // HIGHLIGHT\r\n\r\n#ifdef ID\r\nvarying highp vec4 v_id;\r\n#endif // ID\r\n\r\nvoid main()\r\n{\r\n#ifdef SDF\r\n  lowp vec4 fillPixelColor \x3d v_color;\r\n\r\n  // calculate the distance from the edge [-0.5, 0.5]\r\n  float d \x3d 0.5 - rgba2float(texture2D(u_texture, v_tex));\r\n\r\n  // the soft edge ratio is about 1.5 pixels allocated for the soft edge.\r\n  float size \x3d max(v_size.x, v_size.y);\r\n  float dist \x3d d * size * SOFT_EDGE_RATIO;\r\n\r\n  // set the fragment's transparency according to the distance from the edge\r\n  fillPixelColor *\x3d clamp(0.5 - dist, 0.0, 1.0);\r\n\r\n  float outlineWidth \x3d v_outlineWidth;\r\n\r\n  #ifdef HIGHLIGHT\r\n    outlineWidth \x3d max(outlineWidth, 4.0 * v_isThinGeometry);\r\n  #endif\r\n\r\n  // count for the outline\r\n  // therefore tint the entire icon area.\r\n  if (outlineWidth \x3e 0.25) {\r\n    lowp vec4 outlinePixelColor \x3d v_overridingOutlineColor * v_color + (1.0 - v_overridingOutlineColor) * v_outlineColor;\r\n\r\n    // outlines can't be larger than the size of the symbol\r\n    float clampedOutlineSize \x3d min(outlineWidth, size);\r\n\r\n    outlinePixelColor *\x3d clamp(0.5 - abs(dist) + clampedOutlineSize * 0.5, 0.0, 1.0);\r\n\r\n    // finally combine the outline and the fill colors (outline draws on top of fill)\r\n    gl_FragColor \x3d v_transparency * ((1.0 - outlinePixelColor.a) * fillPixelColor + outlinePixelColor);\r\n  }\r\n  else {\r\n    gl_FragColor \x3d v_transparency * fillPixelColor;\r\n  }\r\n#else // not an SDF\r\n   lowp vec4 texColor \x3d texture2D(u_texture, v_tex);\r\n   gl_FragColor \x3d v_transparency * getEffectColor(texColor, v_visible);\r\n#endif // SDF\r\n\r\n#ifdef HIGHLIGHT\r\n  gl_FragColor.a \x3d step(1.0 / 255.0, gl_FragColor.a);\r\n#endif // HIGHLIGHT\r\n\r\n#ifdef ID\r\n  if (gl_FragColor.a \x3c 1.0 / 255.0) {\r\n    discard;\r\n  }\r\n  gl_FragColor \x3d v_id;\r\n#endif // ID\r\n}\r\n",
"icon.vert":"precision mediump float;\r\n\r\n#include \x3cmaterials/constants.glsl\x3e\r\n#include \x3cmaterials/utils.glsl\x3e\r\n#include \x3cmaterials/vv.glsl\x3e\r\n#include \x3cmaterials/effects.glsl\x3e\r\n\r\nattribute vec2 a_pos;\r\nattribute vec4 a_vertexOffsetAndTex;\r\nattribute vec4 a_id;                   // objectId in RGBA components\r\nattribute vec4 a_color;\r\nattribute vec4 a_outlineColor;\r\nattribute vec4 a_sizeAndOutlineWidth;\r\nattribute float a_visible;             // one byte controlling the vertex visibility (separate buffer)\r\n\r\n#ifdef VV\r\nattribute highp vec4 a_vv;\r\n#endif\r\n\r\nuniform highp mat3 u_dvsMat3;\r\nuniform highp mat3 u_displayMat3;\r\nuniform highp mat3 u_displayViewMat3;\r\nuniform vec2 u_mosaicSize;            // mosaic size in pixels\r\n\r\nvarying lowp vec4 v_color;\r\nvarying mediump vec2 v_tex;           // texture coordinates used to sample the sprite atlas\r\nvarying lowp float v_transparency;    // the calculated transparency to be applied by the fragment shader.\r\nvarying mediump vec2 v_size;          // icon size in px\r\nvarying float v_visible;\r\n\r\n#ifdef SDF\r\nvarying lowp vec4 v_outlineColor;\r\nvarying mediump float v_outlineWidth;\r\nvarying float v_overridingOutlineColor;\r\n#endif\r\n\r\n#ifdef HIGHLIGHT\r\nvarying float v_isThinGeometry;\r\n#endif // HIGHLIGHT\r\n\r\n#ifdef ID\r\nvarying highp vec4 v_id;\r\n#endif\r\n\r\nvec2 getMarkerSize(inout vec2 offset, in vec2 baseSize, in float vvSize) {\r\n  float f \x3d getVVSize(baseSize.y, vvSize);\r\n  vec2 size \x3d vec2(f * baseSize.x / baseSize.y, f);\r\n\r\n  offset *\x3d (size / baseSize);\r\n  return size;\r\n}\r\n\r\nvoid main()\r\n{\r\n  vec2 offset \x3d a_vertexOffsetAndTex.xy;\r\n  vec2 a_tex \x3d a_vertexOffsetAndTex.zw + SIGNED_BYTE_TO_UNSIGNED;\r\n  vec2 a_size \x3d a_sizeAndOutlineWidth.xy;\r\n  float a_bitset \x3d a_sizeAndOutlineWidth.w;\r\n\r\n  float isMapAligned \x3d getBit(a_bitset, 0);\r\n  float isColorLocked \x3d getBit(a_bitset, 1);\r\n  float isThinGeometry \x3d getBit(a_bitset, 2);\r\n  mat3 offsetMat3 \x3d isMapAligned * u_displayViewMat3 + (1.0 - isMapAligned) * u_displayMat3;\r\n\r\n  v_transparency \x3d 1.0;\r\n  v_color \x3d a_color;\r\n  v_size \x3d a_size;\r\n  v_tex \x3d a_tex / u_mosaicSize; // texture coords and transparency\r\n  v_visible \x3d a_visible;\r\n\r\n#ifdef ID\r\n  v_id \x3d a_id;\r\n#endif\r\n\r\n#ifdef VV_OPACITY\r\n  v_transparency \x3d getVVOpacity(a_vv.z);\r\n#endif\r\n\r\n#ifdef VV_COLOR\r\n  v_color \x3d getVVColor(a_vv.y, a_color, isColorLocked);\r\n#endif // VV_COLOR\r\n\r\n#ifdef VV_SIZE\r\n  v_size \x3d getMarkerSize(offset, a_size, a_vv.x);\r\n#endif\r\n\r\n#ifdef VV_ROTATION\r\n  offset \x3d (getVVRotationMat3(a_vv.w) * vec3(offset, 0.0)).xy;\r\n#endif\r\n\r\n#ifdef SDF\r\n  #ifdef VV_COLOR\r\n    // this is true only if we have SDF and color VV\r\n    v_overridingOutlineColor \x3d isThinGeometry;\r\n  #else\r\n    v_overridingOutlineColor \x3d 0.0;\r\n  #endif\r\n\r\n  offset *\x3d 2.0;\r\n  v_outlineColor \x3d getEffectColor(a_outlineColor, a_visible);\r\n  // YF: in practice v_size.x and v_size.y are identical since we're mostly dealing with sms\r\n  v_outlineWidth \x3d min(a_sizeAndOutlineWidth.z, max(v_size.x - 0.99, 0.0));\r\n#endif\r\n\r\n#ifdef HIGHLIGHT\r\n  v_isThinGeometry \x3d isThinGeometry;\r\n#endif\r\n\r\n  vec3 pos \x3d u_dvsMat3 * vec3(a_pos, 1.0) + offsetMat3 * vec3(offset, 0.0);\r\n\r\n  applyFilter(v_color, pos, a_visible);\r\n\r\n  gl_Position \x3d vec4(pos, 1.0);\r\n}\r\n"},
label:{"label.frag":"precision lowp float;\r\n\r\nuniform mediump sampler2D u_referenceTex;\r\nuniform mediump vec2 u_screenSize;\r\nuniform mediump float u_pixelRatio;\r\n\r\nvarying mediump float v_antialiasingWidth;\r\nvarying mediump float v_edgeDistanceOffset;\r\nvarying mediump vec2 v_tex;\r\n\r\n#ifdef ID\r\nvarying mediump float v_fadeStep;\r\n#else\r\nuniform lowp sampler2D u_texture;\r\nvarying mediump vec4 v_color;\r\n#endif // ID\r\n\r\nconst vec3 epsilon \x3d vec3(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\r\n\r\nvoid main()\r\n{\r\n  mediump vec2 refTextPos \x3d gl_FragCoord.xy / (u_pixelRatio * u_screenSize.xy);\r\n  mediump vec4 referenceFragment \x3d texture2D(u_referenceTex, refTextPos);\r\n#ifdef ID\r\n  mediump float alpha \x3d clamp(referenceFragment.a + v_fadeStep, 0.0, 1.0);\r\n  // fill the whole quad\r\n  gl_FragColor \x3d vec4(alpha);\r\n#else\r\n  // read the fade alpha\r\n  lowp float fadeAlpha \x3d referenceFragment.a;\r\n\r\n  // read the distance from the SDF texture\r\n  lowp float dist \x3d texture2D(u_texture, v_tex).a;\r\n\r\n  // the edge distance if a factor of the outline width\r\n  // We cap this to 0.25 to prevent this from becomming negative / running into the glyph boundaries\r\n  float glyphEdgeDistance \x3d max(0.75 - v_edgeDistanceOffset, 0.25);\r\n\r\n  // use a smooth-step in order to calculate the geometry of the shape given by the distance field\r\n  lowp float sdfAlpha \x3d smoothstep(glyphEdgeDistance - v_antialiasingWidth, glyphEdgeDistance + v_antialiasingWidth, dist);\r\n\r\n  gl_FragColor \x3d fadeAlpha * sdfAlpha * v_color;\r\n#endif\r\n}\r\n",
"label.vert":"precision mediump float;\r\n\r\n#include \x3cmaterials/constants.glsl\x3e\r\n#include \x3cmaterials/utils.glsl\x3e\r\n#include \x3cmaterials/vv.glsl\x3e\r\n#include \x3cmaterials/effects.glsl\x3e\r\n\r\nattribute vec2 a_pos;                         // (2 x i16)\r\nattribute vec4 a_color;                       // (4 x u8)\r\nattribute vec2 a_vertexOffset;                // (2 x i16) offset from the anchor point of the string\r\nattribute vec4 a_texAndSize;                  // (4 x u8) texture coordinatesm and font size. w is for the halo size\r\nattribute vec4 a_refSymbolAndPlacementOffset; // (4 x u8) reference symbol offset (px) and the placement offset (px)\r\nattribute float a_vvSize;                     // size visual variable\r\nattribute lowp float  a_visible;              // a one byte controlling the visibility of the vertex (separate buffer)\r\nattribute mediump vec2 a_visibilityRange;     // (2 x u8);\r\n\r\nuniform mediump float u_zoomLevel;            // the current zoom level X 10\r\nuniform highp mat3 u_dvsMat3;                 // premultiplies displayMat3 * viewMat3 * screenMat3\r\nuniform highp mat3 u_displayMat3;\r\nuniform float u_mapRotation;\r\nuniform float u_mapAligned;\r\nuniform vec2 u_mosaicSize;\r\nuniform float u_pixelRatio;\r\n\r\nvarying mediump float v_antialiasingWidth;\r\nvarying mediump float v_edgeDistanceOffset;\r\nvarying mediump vec2 v_tex;                   // texture coordinates used to sample the glyph atlas\r\nvarying mediump vec4 v_color;\r\n\r\n#ifdef ID                                     // somewhat of a misnomer - id is used here for the label alpha phase\r\nuniform mediump float u_fadeStep; \r\nvarying mediump float v_fadeStep;\r\n#endif\r\n\r\nfloat getZ(in float minZoom, in float maxZoom, in float angle) {\r\n  float glyphAngle \x3d angle * 360.0 / 254.0;\r\n  float mapAngle \x3d u_mapRotation * 360.0 / 254.0;\r\n  float diffAngle \x3d min(360.0 - abs(mapAngle - glyphAngle), abs(mapAngle - glyphAngle));\r\n  float z \x3d 0.0;\r\n\r\n  // make sure range is inclusive\r\n  z +\x3d 2.0 * (1.0 - step(minZoom, u_zoomLevel));\r\n  z +\x3d 2.0 * (1.0 - step(u_zoomLevel, maxZoom));\r\n  z +\x3d 2.0 * u_mapAligned * step(90.0, diffAngle);\r\n  return z;\r\n}\r\n\r\nvoid main()\r\n{\r\n  float isHalo \x3d mod(a_pos, 2.0).x; // lsb of a_pos denotes whether a vertex is part of the halo or not\r\n  vec3 pos \x3d vec3(floor(a_pos * 0.5), 1.0);\r\n  vec2 placementDir \x3d a_refSymbolAndPlacementOffset.zw - 1.0;  // encoded as dir + 1.0\r\n  vec2 vertexOffset \x3d a_vertexOffset * OFFSET_PRECISION;\r\n  float refSymbolSize \x3d a_refSymbolAndPlacementOffset.y;\r\n  float fontSize \x3d a_texAndSize.z;\r\n  float z \x3d getZ(a_visibilityRange.x, a_visibilityRange.y, a_refSymbolAndPlacementOffset.x);\r\n\r\n  float fontScale \x3d fontSize / SDF_FONT_SIZE;\r\n  float halfSize \x3d refSymbolSize / 2.0;\r\n\r\n  v_color \x3d a_color;\r\n  v_tex \x3d a_texAndSize.xy / u_mosaicSize;\r\n\r\n#ifdef ID\r\n  v_fadeStep \x3d u_fadeStep;\r\n#endif\r\n  \r\n#ifdef VV_SIZE // unlike with text, this is the VV_SIZE of the reference symbol, not the label itself\r\n  halfSize \x3d getVVSize(refSymbolSize, a_vvSize) / 2.0;\r\n#endif\r\n  // if halo.x is zero (not a halo) v_edgeDistanceOffset will end up being zero as well.\r\n  v_edgeDistanceOffset \x3d isHalo * OUTLINE_SCALE * a_texAndSize.w / fontScale / MAX_SDF_DISTANCE;\r\n  v_antialiasingWidth \x3d 0.106 * SDF_FONT_SIZE / fontSize / u_pixelRatio;\r\n\r\n  vec2 placementOffset \x3d placementDir * (halfSize + PLACEMENT_PADDING);\r\n  vec3 glyphOffset \x3d u_displayMat3 * vec3(vertexOffset + placementOffset, 0.0);\r\n  vec3 v_pos \x3d u_dvsMat3 * pos + glyphOffset;\r\n  \r\n  applyFilterLabels(v_color, v_pos, a_visible);\r\n\r\n#ifdef DEBUG\r\n  v_color \x3d vec4(a_color.rgb, z \x3d\x3d 0.0 ? 1.0 : 0.645);  // visualize hidden glyphs\r\n#endif\r\n  \r\n  gl_Position \x3d vec4(v_pos.xy, v_pos.z + z, 1.0);\r\n}\r\n"},
line:{"line.frag":"precision lowp float;\r\n\r\n#include \x3cutil/encoding.glsl\x3e\r\n#include \x3cmaterials/constants.glsl\x3e\r\n\r\nuniform lowp float u_blur;\r\nuniform mediump float u_antialiasing;\r\n\r\nvarying mediump vec2 v_normal;\r\nvarying mediump float v_lineHalfWidth;\r\nvarying lowp vec4 v_color;\r\nvarying lowp float v_transparency;\r\n\r\n#if defined(PATTERN) || defined(SDF)\r\nuniform sampler2D u_texture;\r\nuniform mediump float u_zoomFactor;\r\n\r\nvarying mediump vec4 v_tlbr; // normalized pattern coordinates [0, 1]\r\nvarying mediump vec2 v_patternSize;\r\nvarying highp float v_accumulatedDistance;\r\n#endif // PATTERN SDF\r\n\r\n#ifdef SDF\r\nconst float sdfPatternHalfWidth \x3d 15.5; // YF: assumed that the width will be set to 31\r\nconst float widthFactor \x3d 2.0;\r\n#endif // SDF\r\n\r\n#ifdef ID\r\nvarying highp vec4 v_id;\r\n#endif // ID\r\n\r\n\r\nvoid main()\r\n{\r\n  // for now assume that a thin line is a line which is under 2 pixels (1 pixels on either sides of the centerline)\r\n  mediump float thinLineFactor \x3d max(THIN_LINE_WIDTH_FACTOR * step(v_lineHalfWidth, THIN_LINE_HALF_WIDTH), 1.0);\r\n\r\n  // dist represent the distance of the fragment from the line. 1.0 or -1.0 will be the values on the edge of the line,\r\n  // and any value in between will be inside the line (the sign represent the direction - right or left).\r\n  // since u_linewidth.s (half line width) is represented in pixels, dist is also given in pixels\r\n  mediump float fragDist \x3d length(v_normal) * v_lineHalfWidth;\r\n\r\n  // calculate the alpha given the difference between the line-width and the distance of the fragment from the center-line.\r\n  // when it is a thin line then use a slightly shallower slope in order to add more feathering\r\n  lowp float alpha \x3d clamp(thinLineFactor * (v_lineHalfWidth - fragDist) / (u_blur + thinLineFactor - 1.0), 0.0, 1.0);\r\n\r\n#if defined(SDF) \x26\x26 !defined(HIGHLIGHT) // When we render the highlight, we want to treat the line as if it was solid\r\n  mediump float lineHalfWidth \x3d widthFactor * v_lineHalfWidth;\r\n  mediump float lineWidthRatio \x3d lineHalfWidth / sdfPatternHalfWidth;\r\n  mediump float relativeTexX \x3d mod((u_zoomFactor * v_accumulatedDistance + v_normal.x * lineHalfWidth) / (lineWidthRatio * v_patternSize.x), 1.0);\r\n  mediump float relativeTexY \x3d 0.5 + 0.5 * v_normal.y;\r\n\r\n  // claculate the actual texture coordinates by interpolating between the TL/BR pattern coordinates\r\n  mediump vec2 texCoord \x3d mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\r\n\r\n  // calculate the distance from the edge [-0.5, 0.5]\r\n  mediump float d \x3d rgba2float(texture2D(u_texture, texCoord)) - 0.5;\r\n\r\n  // the distance is a proportional to the line width\r\n  float dist \x3d d * lineHalfWidth;\r\n\r\n  lowp vec4 fillPixelColor \x3d v_transparency * alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\r\n  gl_FragColor \x3d fillPixelColor;\r\n#elif defined(PATTERN) \x26\x26 !defined(HIGHLIGHT)  // When we render the highlight, we want to treat the line as if it was solid\r\n  // we need to calculate the relative portion of the line texture along the line given the accumulated distance along the line\r\n  // The computed value should is anumber btween 0 and 1 which will later be used to interpolate btween the BR and TL values\r\n  mediump float relativeTexX \x3d mod((u_zoomFactor * v_accumulatedDistance + v_normal.x * v_lineHalfWidth) / v_patternSize.x, 1.0);\r\n\r\n  // in order to calculate the texture coordinates prependicular to the line (Y axis), we use the interpolated normal values\r\n  // which range from -1.0 to 1.0. On the line's centerline, the value of the interpolated normal is 0.0, however the relative\r\n  // texture value shpould be 0.5 (given that at the bottom of the line, the texture coordinate must be equal to 0.0)\r\n  // (TL) ---------------------------      --\x3e left edge of line. Interpolatedf normal is 1.0\r\n  //              | -\x3e line-width / 2\r\n  //      - - - - - - - - - - - - - -\r\n  //              | -\x3e line-width / 2\r\n  //      ---------------------------- (BR)--\x3e right edge of line. Interpolatedf normal is -1.0\r\n\r\n  mediump float relativeTexY \x3d 0.5 + (v_normal.y * v_lineHalfWidth / v_patternSize.y);\r\n\r\n  // claculate the actual texture coordinates by interpolating between the TL/BR pattern coordinates\r\n  mediump vec2 texCoord \x3d mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\r\n\r\n  // get the color from the texture\r\n  lowp vec4 color \x3d texture2D(u_texture, texCoord);\r\n\r\n  gl_FragColor \x3d v_transparency * alpha * v_color * color;\r\n#else // solid line (no texture, no pattern)\r\n  // output the fragment color\r\n  gl_FragColor \x3d v_transparency * alpha * v_color;\r\n#endif // SDF\r\n\r\n#ifdef HIGHLIGHT\r\n  gl_FragColor.a \x3d step(1.0 / 255.0, gl_FragColor.a);\r\n#endif // HIGHLIGHT\r\n\r\n#ifdef ID\r\n  if (gl_FragColor.a \x3c 1.0 / 255.0) {\r\n    discard;\r\n  }\r\n  gl_FragColor \x3d v_id;\r\n#endif // ID\r\n}\r\n",
"line.vert":"precision mediump float;\r\n\r\n#include \x3cmaterials/constants.glsl\x3e\r\n#include \x3cmaterials/utils.glsl\x3e\r\n#include \x3cmaterials/vv.glsl\x3e\r\n#include \x3cmaterials/effects.glsl\x3e\r\n\r\nattribute vec2 a_pos;\r\nattribute vec4 a_id;\r\nattribute vec4 a_color;\r\nattribute vec4 a_offsetAndNormal;\r\nattribute vec2 a_accumulatedDistanceAndHalfWidth;\r\nattribute vec4 a_tlbr;\r\nattribute vec4 a_segmentDirection;\r\nattribute float  a_visible;                // a one byte controlling the visibility of the vertex (separate buffer)\r\n\r\n#ifdef VV\r\nattribute highp vec3 a_vv;\r\n#endif\r\n\r\nuniform highp mat3 u_dvsMat3;              // premultiplies DisplayMat3 * ViewMat3 * ScreenMat3\r\nuniform highp mat3 u_displayViewMat3;     // premultiplies DisplayMat3 * ViewMat3\r\nuniform mediump float u_zoomFactor;\r\nuniform mediump float u_antialiasing;\r\n\r\nvarying mediump vec2 v_normal;             // interpolated normal to the line. packed into the two LSBs of the vertex coordinate\r\nvarying mediump float v_lineHalfWidth;\r\nvarying lowp vec4 v_color;\r\nvarying lowp float v_transparency;\r\n\r\n#ifdef ID\r\nvarying highp vec4 v_id;\r\n#endif\r\n\r\n#ifdef PATTERN\r\nuniform mediump vec2 u_mosaicSize;\r\n\r\nvarying mediump vec4 v_tlbr;               // normalized pattern coordinates [0, 1]\r\nvarying mediump vec2 v_patternSize;\r\n#endif\r\n\r\n#if defined(PATTERN) || defined(SDF)\r\nvarying highp float v_accumulatedDistance; // we need to accumulated distance only if it is a pattern or an SDF line\r\n#endif\r\n\r\n#if defined(SDF) \x26\x26 !defined(HIGHLIGHT) // When we render the highlight, we want to treat the line as if it was solid\r\nconst float widthFactor \x3d 2.0;\r\n#else\r\nconst float widthFactor \x3d 1.0;\r\n#endif\r\n\r\nconst float scale \x3d 1.0 / 31.0;\r\n\r\nvoid main()\r\n{\r\n  float a_bitset \x3d a_segmentDirection.w;\r\n\r\n  float isColorLocked \x3d getBit(a_bitset, 0);\r\n  float lineHalfWidth \x3d a_accumulatedDistanceAndHalfWidth.y * scale;\r\n\r\n  v_transparency \x3d 1.0;\r\n  v_color \x3d a_color;\r\n  v_normal \x3d a_offsetAndNormal.zw * scale;\r\n\r\n#ifdef ID\r\n  v_id \x3d a_id;\r\n#endif\r\n\r\n#ifdef VV_OPACITY\r\n  v_transparency \x3d getVVOpacity(a_vv.z);\r\n#endif\r\n\r\n#ifdef VV_COLOR\r\n  v_color \x3d getVVColor(a_vv.y, v_color, isColorLocked);\r\n#endif\r\n\r\n#ifdef VV_SIZE\r\n  lineHalfWidth \x3d 0.5 * getVVSize(2.0 * lineHalfWidth, a_vv.x);\r\n#endif\r\n\r\n#ifdef PATTERN\r\n  v_tlbr \x3d a_tlbr / u_mosaicSize.xyxy;\r\n  v_patternSize \x3d vec2(a_tlbr.z - a_tlbr.x, a_tlbr.w - a_tlbr.y);\r\n#endif\r\n\r\n  // make sure to clip the vertices in case that the width of the line is 0 (or negative)\r\n  float z \x3d 2.0 * step(lineHalfWidth, 0.0);\r\n\r\n  // add an antialiasing distance. We use 0.2 rather than 0.5 in order to match the SVG renderer\r\n  // also limit the total line width to 1.3 pixels. Below this value lines don't look good compared\r\n  // to the SVG renderer\r\n  v_lineHalfWidth \x3d max(lineHalfWidth, 0.45) + 0.2 * u_antialiasing;\r\n\r\n\r\n#ifdef HIGHLIGHT\r\n  v_lineHalfWidth \x3d max(v_lineHalfWidth, 2.0);\r\n#endif\r\n\r\n  // for now assume that a thin line is a line which is under 2 pixels (1 pixels on either sides\r\n  // of the centerline) in practice, a thin line is a line who's half width vary from 0.45px to\r\n  // the value of thinLineHalfWidth, as the value is claped in line 221 above\r\n  mediump float thinLineFactor \x3d max(THIN_LINE_WIDTH_FACTOR * step(v_lineHalfWidth, THIN_LINE_HALF_WIDTH), 1.0);\r\n\r\n  // calculate the relative distance from the centerline to the edge of the line. Since offset is\r\n  // given in integers (for the sake of using less attribute memory, we need to scale it back to\r\n  // the original range of ~ [0, 1]) in a case of a thin line we move each vertex twice as far\r\n  mediump vec2 dist \x3d thinLineFactor * widthFactor * v_lineHalfWidth * a_offsetAndNormal.xy * scale;\r\n\r\n#if defined(PATTERN) || defined(SDF)\r\n  v_accumulatedDistance \x3d a_accumulatedDistanceAndHalfWidth.x + dot(scale * a_segmentDirection.xy, dist / u_zoomFactor);\r\n#endif\r\n\r\n  vec3 offset \x3d u_displayViewMat3 * vec3(dist, 0.0);\r\n  vec3 v_pos \x3d u_dvsMat3 * vec3(a_pos.xy, 1.0) + offset;\r\n  vec3 pos \x3d vec3(v_pos.xy, z);\r\n\r\n  applyFilter(v_color, pos, a_visible);\r\n\r\n  gl_Position \x3d vec4(pos, 1.0);\r\n}\r\n"},
text:{"text.frag":"precision lowp float;\r\n\r\nuniform lowp sampler2D u_texture;\r\n\r\nvarying mediump vec4 v_color;\r\nvarying mediump float v_antialiasingWidth;\r\nvarying mediump float v_edgeDistanceOffset;\r\nvarying mediump vec2 v_tex;\r\nvarying lowp float v_transparency;\r\n\r\n#ifdef ID\r\nvarying highp vec4 v_id;\r\n#endif // ID\r\n\r\nvoid main()\r\n{\r\n  // read the distance from the SDF texture\r\n  lowp float dist \x3d texture2D(u_texture, v_tex).a;\r\n\r\n  // the edge distance if a factor of the outline width\r\n  // We cap this to 0.25 to prevent this from becomming negative / running into the glyph boundaries\r\n  float glyphEdgeDistance \x3d max(0.75 - v_edgeDistanceOffset, 0.25);\r\n\r\n  #ifdef HIGHLIGHT\r\n    glyphEdgeDistance /\x3d 2.0;\r\n  #endif\r\n\r\n  // use a smooth-step in order to calculate the geometry of the shape given by the distance field\r\n  lowp float alpha \x3d smoothstep(glyphEdgeDistance - v_antialiasingWidth, glyphEdgeDistance + v_antialiasingWidth, dist) * v_transparency;\r\n\r\n  gl_FragColor \x3d alpha * v_color;\r\n\r\n#ifdef ID\r\n  if (gl_FragColor.a \x3c 1.0 / 255.0) {\r\n    discard;\r\n  }\r\n  gl_FragColor \x3d v_id;\r\n#endif // ID\r\n}\r\n",
"text.vert":"precision mediump float;\r\n\r\n#include \x3cmaterials/constants.glsl\x3e\r\n#include \x3cmaterials/utils.glsl\x3e\r\n#include \x3cmaterials/vv.glsl\x3e\r\n#include \x3cmaterials/effects.glsl\x3e\r\n\r\nattribute vec2 a_pos;          // 2 * 2 (2 x signed 16)\r\nattribute vec4 a_id;           // 4 (4 x unsigned byte)\r\nattribute vec4 a_color;        // 4 (4 x unsigned byte)\r\nattribute vec2 a_vertexOffset; // 2 * 2 // (2 x signed 16) offset from the anchor point of the string\r\nattribute vec4 a_texFontSize;  // 4 (4 x unsigned byte) texture coordinatesm and font size\r\nattribute vec4 a_aux;          // hold onto additional information such as a bitset on the last byte (a_aux.w)\r\nattribute float a_visible;     // a one byte controlling the visibility of the vertex (a separate visibility buffer)\r\n\r\n#ifdef VV\r\nattribute highp vec4 a_vv;\r\n#endif\r\n\r\nuniform vec2 u_mosaicSize;\r\nuniform float u_pixelRatio;\r\nuniform highp mat3 u_dvsMat3;\r\nuniform highp mat3 u_displayMat3; // Premultiplies DisplayMat3 * ViewMat3 * ScreenMat3\r\n\r\nvarying mediump vec4 v_color;\r\nvarying mediump float v_antialiasingWidth;\r\nvarying mediump float v_edgeDistanceOffset;\r\nvarying mediump vec2 v_tex;        // texture coordinates used to sample the glyph atlas\r\nvarying lowp float v_transparency; // the calculated transparency to be applied by the fragment shader. \r\n\r\n#ifdef ID\r\nvarying highp vec4 v_id;\r\n#endif // ID\r\n\r\nvoid main()\r\n{\r\n  float a_bitset \x3d a_aux.w;\r\n\r\n  float isColorLocked \x3d getBit(a_bitset, 0);\r\n  float isHalo \x3d getBit(a_pos.x, 0);   // The lsb of pos denotes whether a vertex is part of the halo or not\r\n  float fontSize \x3d a_texFontSize.z;\r\n  vec3 pos \x3d vec3(floor(a_pos * 0.5), 1.0);\r\n  vec3 offset \x3d vec3(a_vertexOffset * OFFSET_PRECISION, 0.0);\r\n  float scale \x3d 1.0;\r\n\r\n  v_transparency \x3d 1.0;\r\n  v_color \x3d a_color;\r\n  v_tex \x3d a_texFontSize.xy / u_mosaicSize;\r\n\r\n#ifdef ID\r\n  v_id \x3d a_id;\r\n#endif\r\n\r\n#ifdef VV_OPACITY\r\n  v_transparency \x3d getVVOpacity(a_vv.z);\r\n#endif\r\n\r\n#ifdef VV_COLOR\r\n  // we don't want to override the halo color\r\n  v_color \x3d isHalo * a_color + (1.0 - isHalo) * getVVColor(a_vv.y, a_color, isColorLocked);\r\n#endif\r\n\r\n#ifdef VV_SIZE\r\n  float f \x3d getVVSize(a_texFontSize.z, a_vv.x);\r\n  scale \x3d f / fontSize; \r\n  fontSize \x3d f;\r\n  offset.xy *\x3d scale; \r\n#endif\r\n  \r\n#ifdef VV_ROTATION\r\n  offset \x3d getVVRotationMat3(a_vv.w) * offset;\r\n#endif\r\n\r\n  vec3 v_pos \x3d u_dvsMat3 * pos + u_displayMat3 * offset;\r\n  float fontScale \x3d fontSize / SDF_FONT_SIZE;\r\n\r\n  // if isHalo is zero (not a halo) v_edgeDistanceOffset will end up being zero as well.\r\n  v_edgeDistanceOffset \x3d isHalo * OUTLINE_SCALE * a_texFontSize.w / fontScale / MAX_SDF_DISTANCE;\r\n  v_antialiasingWidth \x3d 0.105 * SDF_FONT_SIZE / fontSize / u_pixelRatio;\r\n\r\n  applyFilter(v_color, v_pos, a_visible);\r\n  \r\n  gl_Position \x3d vec4(v_pos, 1.0);\r\n}\r\n"},
"utils.glsl":"\r\nfloat getBit(in float bitset, in int bitIndex) {\r\n  float offset \x3d pow(2.0, float(bitIndex));\r\n\r\n  return mod(floor(bitset / offset), 2.0);\r\n}\r\n","vv.glsl":"#if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\r\n  #define VV_SIZE\r\n#endif\r\n\r\n#if defined(VV_COLOR) || defined(VV_SIZE) || defined(VV_OPACITY) || defined(VV_ROTATION)\r\n  #define VV\r\n#endif\r\n\r\n#ifdef VV_COLOR\r\nuniform highp float u_vvColorValues[8];\r\nuniform vec4 u_vvColors[8];\r\n#endif // VV_COLOR\r\n\r\n#ifdef VV_SIZE_MIN_MAX_VALUE\r\nuniform highp vec4 u_vvSizeMinMaxValue;\r\n#endif // VV_SIZE_MIN_MAX_VALUE\r\n\r\n#ifdef VV_SIZE_SCALE_STOPS\r\nuniform highp float u_vvSizeScaleStopsValue;\r\n#endif // VV_SIZE_SCALE_STOPS\r\n\r\n#ifdef VV_SIZE_FIELD_STOPS\r\nuniform highp float u_vvSizeFieldStopsValues[6];\r\nuniform float u_vvSizeFieldStopsSizes[6];\r\n#endif // VV_SIZE_FIELD_STOPS\r\n\r\n#ifdef VV_SIZE_UNIT_VALUE\r\nuniform highp float u_vvSizeUnitValueWorldToPixelsRatio;\r\n#endif // VV_SIZE_UNIT_VALUE\r\n\r\n#ifdef VV_OPACITY\r\nuniform highp float u_vvOpacityValues[8];\r\nuniform float u_vvOpacities[8];\r\n#endif // VV_OPACITY\r\n\r\n#ifdef VV_ROTATION\r\nuniform lowp float u_vvRotationType;\r\n#endif // VV_ROTATION\r\n\r\nconst highp float nanValue \x3d 1e-30;\r\n\r\nbool isNan(float val) {\r\n  return (val \x3d\x3d nanValue);\r\n  //return !( val \x3c 0.0 || 0.0 \x3c val || val \x3d\x3d 0.0 );\r\n}\r\n\r\n#ifdef VV_SIZE_MIN_MAX_VALUE\r\nfloat getVVMinMaxSize(float sizeValue, float fallback) {\r\n  if (isNan(sizeValue)) {\r\n    return fallback;\r\n  }\r\n\r\n  // we need to multiply by 8 in order to translate to tile coordinates\r\n  float interpolationRatio \x3d (sizeValue  - u_vvSizeMinMaxValue.x) / (u_vvSizeMinMaxValue.y - u_vvSizeMinMaxValue.x);\r\n  interpolationRatio \x3d clamp(interpolationRatio, 0.0, 1.0);\r\n  return u_vvSizeMinMaxValue.z + interpolationRatio * (u_vvSizeMinMaxValue.w - u_vvSizeMinMaxValue.z);\r\n}\r\n#endif // VV_SIZE_MIN_MAX_VALUE\r\n\r\n#ifdef VV_SIZE_FIELD_STOPS\r\nconst int VV_SIZE_N \x3d 6;\r\nfloat getVVStopsSize(float sizeValue, float fallback) {\r\n  if (isNan(sizeValue)) {\r\n    return fallback;\r\n  }\r\n\r\n  if (sizeValue \x3c\x3d u_vvSizeFieldStopsValues[0]) {\r\n    return u_vvSizeFieldStopsSizes[0];\r\n  }\r\n\r\n  for (int i \x3d 1; i \x3c VV_SIZE_N; ++i) {\r\n    if (u_vvSizeFieldStopsValues[i] \x3e\x3d sizeValue) {\r\n      float f \x3d (sizeValue - u_vvSizeFieldStopsValues[i-1]) / (u_vvSizeFieldStopsValues[i] - u_vvSizeFieldStopsValues[i-1]);\r\n      return mix(u_vvSizeFieldStopsSizes[i-1], u_vvSizeFieldStopsSizes[i], f);\r\n    }\r\n  }\r\n\r\n  return u_vvSizeFieldStopsSizes[VV_SIZE_N - 1];\r\n}\r\n#endif // VV_SIZE_FIELD_STOPS\r\n\r\n#ifdef VV_SIZE_UNIT_VALUE\r\nfloat getVVUnitValue(float sizeValue, float fallback) {\r\n  if (isNan(sizeValue)) {\r\n    return fallback;\r\n  }\r\n\r\n  return u_vvSizeUnitValueWorldToPixelsRatio * sizeValue;\r\n}\r\n#endif // VV_SIZE_UNIT_VALUE\r\n\r\n#ifdef VV_OPACITY\r\nconst int VV_OPACITY_N \x3d 8;\r\nfloat getVVOpacity(float opacityValue) {\r\n  if (isNan(opacityValue)) {\r\n    return 1.0;\r\n  }\r\n\r\n  if (opacityValue \x3c\x3d u_vvOpacityValues[0]) {\r\n    return u_vvOpacities[0];\r\n  }\r\n\r\n  for (int i \x3d 1; i \x3c VV_OPACITY_N; ++i) {\r\n    if (u_vvOpacityValues[i] \x3e\x3d opacityValue) {\r\n      float f \x3d (opacityValue - u_vvOpacityValues[i-1]) / (u_vvOpacityValues[i] - u_vvOpacityValues[i-1]);\r\n      return mix(u_vvOpacities[i-1], u_vvOpacities[i], f);\r\n    }\r\n  }\r\n\r\n  return u_vvOpacities[VV_OPACITY_N - 1];\r\n}\r\n#endif // VV_OPACITY\r\n\r\n#ifdef VV_ROTATION\r\nmat4 getVVRotation(float rotationValue) {\r\n  // YF TODO: if the symbol has rotation we need to combine the symbo's rotation with the VV one\r\n  if (isNan(rotationValue)) {\r\n    return mat4(1, 0, 0, 0,\r\n                0, 1, 0, 0,\r\n                0, 0, 1, 0,\r\n                0, 0, 0, 1);\r\n  }\r\n\r\n  float rotation \x3d rotationValue;\r\n  if (u_vvRotationType \x3d\x3d 1.0) {\r\n    rotation \x3d 90.0 - rotation;\r\n  }\r\n\r\n  float angle \x3d C_DEG_TO_RAD * rotation;\r\n\r\n  float sinA \x3d sin(angle);\r\n  float cosA \x3d cos(angle);\r\n\r\n  return mat4(cosA, sinA, 0, 0,\r\n              -sinA,  cosA, 0, 0,\r\n              0,     0, 1, 0,\r\n              0,     0, 0, 1);\r\n}\r\n\r\nmat3 getVVRotationMat3(float rotationValue) {\r\n  // YF TODO: if the symbol has rotation we need to combine the symbo's rotation with the VV one\r\n  if (isNan(rotationValue)) {\r\n    return mat3(1, 0, 0,\r\n                0, 1, 0,\r\n                0, 0, 1);\r\n  }\r\n\r\n  float rotation \x3d rotationValue;\r\n  if (u_vvRotationType \x3d\x3d 1.0) {\r\n    rotation \x3d 90.0 - rotation;\r\n  }\r\n\r\n  float angle \x3d C_DEG_TO_RAD * -rotation;\r\n\r\n  float sinA \x3d sin(angle);\r\n  float cosA \x3d cos(angle);\r\n\r\n  return mat3(cosA, -sinA, 0,\r\n             sinA, cosA, 0,\r\n              0,    0,    1);\r\n}\r\n#endif // VV_ROTATION\r\n\r\n#ifdef VV_COLOR\r\nconst int VV_COLOR_N \x3d 8;\r\n\r\nvec4 getVVColor(float colorValue, vec4 fallback, float isColorLocked) {\r\n  if (isNan(colorValue) || isColorLocked \x3d\x3d 1.0) {\r\n    return fallback;\r\n  }\r\n\r\n  if (colorValue \x3c\x3d u_vvColorValues[0]) {\r\n    return u_vvColors[0];\r\n  }\r\n\r\n  for (int i \x3d 1; i \x3c VV_COLOR_N; ++i) {\r\n    if (u_vvColorValues[i] \x3e\x3d colorValue) {\r\n      float f \x3d (colorValue - u_vvColorValues[i-1]) / (u_vvColorValues[i] - u_vvColorValues[i-1]);\r\n      return mix(u_vvColors[i-1], u_vvColors[i], f);\r\n    }\r\n  }\r\n\r\n  return u_vvColors[VV_COLOR_N - 1];\r\n}\r\n#endif // VV_COLOR\r\n\r\nfloat getVVSize(in float size, in float vvSize)  {\r\n\r\n#ifdef VV_SIZE_MIN_MAX_VALUE\r\n  return getVVMinMaxSize(vvSize, size);\r\n\r\n#elif defined(VV_SIZE_SCALE_STOPS)\r\n  return u_vvSizeScaleStopsValue;\r\n\r\n#elif defined(VV_SIZE_FIELD_STOPS)\r\n  return getVVStopsSize(vvSize, size);\r\n\r\n#elif defined(VV_SIZE_UNIT_VALUE)\r\n  return getVVUnitValue(vvSize, size);\r\n\r\n#else\r\n  return size;\r\n\r\n#endif\r\n}\r\n"},
raster:{"solid.frag":"precision mediump float;\r\n\r\nvoid main(void) {\r\n  gl_FragColor \x3d vec4(1.0, 0.0, 0.0, 1.0);\r\n}\r\n","texture.frag":"precision mediump float;\r\n\r\n// Texture coordinates.\r\nvarying vec2 v_texcoord;\r\n\r\n// Texture sampler.\r\nuniform sampler2D u_texture;\r\n\r\n// Opacity.\r\nuniform float u_opacity;\r\n\r\nvoid main(void) {\r\n  vec4 color \x3d texture2D(u_texture, v_texcoord);\r\n  color.a *\x3d u_opacity;\r\n  gl_FragColor \x3d vec4(color.rgb * color.a, color.a);\r\n}\r\n",
"transform.vert":"precision mediump float;\r\n\r\n// Vertex position. Assumed normalized in the [0, 1] range.\r\nattribute vec2 a_position;\r\n\r\n// Transform matrix.\r\nuniform mat4 u_transform;\r\n\r\n// Output texture coordinates, for interpolation.\r\nvarying vec2 v_texcoord;\r\n\r\nvoid main(void) {\r\n  gl_Position \x3d u_transform * vec4((2.0 * a_position - 1.0), 0.0, 1.0);\r\n  v_texcoord \x3d a_position;\r\n}\r\n"},stencil:{"stencil.frag":"void main() {\r\n  gl_FragColor \x3d vec4(1.0, 1.0, 1.0, 1.0);\r\n}\r\n",
"stencil.vert":"attribute vec2 a_pos;\r\n\r\nvoid main() {\r\n  gl_Position \x3d vec4(a_pos, 0.0, 1.0);\r\n}\r\n"},tileInfo:{"tileInfo.frag":"uniform mediump sampler2D u_texture;\r\nvarying mediump vec2 v_tex;\r\n\r\nvoid main(void) {\r\n  lowp vec4 color \x3d texture2D(u_texture, v_tex);\r\n  gl_FragColor \x3d 0.75 * color;\r\n}\r\n","tileInfo.vert":"attribute vec2 a_pos;\r\n\r\nuniform highp mat3 u_dvsMat3;\r\n\r\nuniform mediump float u_depth;\r\nuniform mediump float u_coord_ratio;\r\nuniform mediump vec2 u_delta; // in tile coordinates\r\nuniform mediump vec2 u_dimensions; // in tile coordinates\r\n\r\nvarying mediump vec2 v_tex;\r\n\r\nvoid main() {\r\n  mediump vec2 offset \x3d u_coord_ratio * vec2(u_delta + a_pos * u_dimensions);\r\n  vec3 v_pos \x3d u_dvsMat3 * vec3(offset, 1.0);\r\n  \r\n  gl_Position \x3d vec4(v_pos.xy, 0.0, 1.0);\r\n\r\n  v_tex \x3d a_pos;\r\n}\r\n"},
util:{"encoding.glsl":"// Factors to convert rgba back to float\r\nconst vec4 rgba2float_factors \x3d vec4(\r\n    255.0 / (256.0),\r\n    255.0 / (256.0 * 256.0),\r\n    255.0 / (256.0 * 256.0 * 256.0),\r\n    255.0 / (256.0 * 256.0 * 256.0 * 256.0)\r\n  );\r\n\r\nfloat rgba2float(vec4 rgba) {\r\n  // Convert components from 0-\x3e1 back to 0-\x3e255 and then\r\n  // add the components together with their corresponding\r\n  // fixed point factors, i.e. (256^1, 256^2, 256^3, 256^4)\r\n  return dot(rgba, rgba2float_factors);\r\n}\r\n"}}});