// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.11/esri/copyright.txt for details.
//>>built
require({cache:{"esri/views/2d/tiling/TileInfoViewPOT":function(){define("require exports ../../../core/tsSupport/extendsHelper ../../../core/tsSupport/decorateHelper ../../../layers/support/TileInfo ./TileInfoView ./TileKey".split(" "),function(w,v,l,u,d,k,a){return function(n){function c(){var b=null!==n&&n.apply(this,arguments)||this;b._fullCacheLodInfos=null;b._levelByScale={};return b}l(c,n);c.prototype.getTileParentId=function(b){b=a.pool.acquire(b);var c=0===b.level?null:a.getId(b.level-1,
b.row>>1,b.col>>1,b.world);a.pool.release(b);return c};c.prototype.getTileCoverage=function(b,a,c){b=n.prototype.getTileCoverage.call(this,b,a,c);if(!b)return b;var f=1<<b.lodInfo.level;b.spans=b.spans.filter(function(b){return 0<=b.row&&b.row<f});return b};c.prototype.scaleToLevel=function(b){this._fullCacheLodInfos||this._initializeFullCacheLODs(this._lodInfos);if(this._levelByScale[b])return this._levelByScale[b];var a=this._fullCacheLodInfos;if(b>a[0].scale)return a[0].level;for(var c=void 0,
q=void 0,c=0;c<a.length-1;c++)if(q=a[c+1],b>q.scale)return c=a[c],c.level+(c.scale-b)/(c.scale-q.scale);return a[a.length-1].level};c.prototype._initializeFullCacheLODs=function(b){b=0===b[0].level?b.map(function(b){return{level:b.level,resolution:b.resolution,scale:b.scale}}):d.create({size:this.tileInfo.size[0],spatialReference:this.tileInfo.spatialReference}).lods.map(function(b){return{level:b.level,resolution:b.resolution,scale:b.scale}});for(var a=0;a<b.length;a++)this._levelByScale[b[a].scale]=
b[a].level;this._fullCacheLodInfos=b};return c}(k)})},"esri/views/vectorTiles/TileHandler":function(){define("require exports ../../request ../../core/has ../../core/ItemCache ../../core/promiseUtils ../../core/requireUtils ../../core/workers ../2d/tiling/TileKey ./GeometryUtils ./GlyphMosaic ./GlyphSource ./SpriteMosaic ./TileIndex ./VectorTileDisplayObject module".split(" "),function(w,v,l,u,d,k,a,n,c,b,f,y,q,h,g,m){var x=new d(10),p=new Map;return function(){function e(e,g,t,b){this.devicePixelRatio=
g;this.allowUpdates=t;this._connection=this._glyphMosaic=this._spriteMosaic=null;this._updateQueue=new Map;this._ongoingRequests=new Map;this._vectorTileLayer=e;this._container=b}e.prototype.destroy=function(){this.stop();this._vectorTileLayer=null;this._spriteMosaic&&(this._spriteMosaic.dispose(),this._spriteMosaic=null);this._glyphMosaic&&(this._glyphMosaic.dispose(),this._glyphMosaic=null)};Object.defineProperty(e.prototype,"initialized",{get:function(){return this._broadcastPromise&&this._broadcastPromise.isFulfilled()},
enumerable:!0,configurable:!0});Object.defineProperty(e.prototype,"spriteMosaic",{get:function(){return this._spriteMosaic},enumerable:!0,configurable:!0});Object.defineProperty(e.prototype,"glyphMosaic",{get:function(){return this._glyphMosaic},enumerable:!0,configurable:!0});Object.defineProperty(e.prototype,"ongoingRequestCount",{get:function(){return this._ongoingRequests.size},enumerable:!0,configurable:!0});e.prototype.start=function(){var e=this;this.stop();var g=[],t=this._vectorTileLayer.loadSpriteSource(this.devicePixelRatio).then(function(g){e._spriteMosaic=
new q(1024,1024,250);e._spriteMosaic.setSpriteSource(g)});g.push(t);var b=this._vectorTileLayer.styleRepository,t=new y(b.glyphs);this._glyphMosaic=new f(1024,1024,t);var t=this._vectorTileLayer.sourceNameToSource,c;for(c in t)g.push(this._fetchTileMap(t[c]));c=n.open(a.getAbsMid("./WorkerTileHandler",w,m),{client:this}).then(function(g){e._connection=g});g.push(c);return this._broadcastPromise=k.all(g).then(function(){return e._connection.broadcast("setLayers",b.styleJSON)})};e.prototype.stop=function(){this._broadcastPromise&&
!this._broadcastPromise.isFulfilled()&&this._broadcastPromise.cancel();this._updateQueue.forEach(function(e){return e.cancel()});this._ongoingRequests.forEach(function(e){return e.cancel()});this._connection&&(this._connection.close(),this._connection=null)};e.prototype.updateStyle=function(){this._updateQueue.forEach(function(e){return e.cancel()});this._updateQueue.clear();this._ongoingRequests.forEach(function(e){return e.cancel()});this._ongoingRequests.clear();var e=this._vectorTileLayer.styleRepository,
g,t=k.create(function(e){g=e});k.all(this._connection.broadcast("updateStyle",e.styleJSON)).then(function(){return g()});return this._broadcastPromise=t};e.prototype.updateTile=function(e,g){var r=this;if(!this.allowUpdates)return k.resolve(null);if(!this._broadcastPromise.isFulfilled()||!this._connection)return k.reject(Error("no connection"));g=Math.round(b.degToByte(g.state.rotation));if(e.rotation===g)return k.resolve(null);var a,c=e.key;this._updateQueue.has(c.id)&&(a=this._updateQueue.get(c.id),
a.cancel(),this._updateQueue["delete"](c.id));e.rotation=g;a=e.client.invoke("updateSymbols",{key:e.id,rotation:g}).then(function(g){r._updateQueue["delete"](c.id);e.updateSymbolData(g);return g}).catch(function(e){if("cancel"!==e.dojoType)r._updateQueue["delete"](c.id)});this._updateQueue.set(e.id,a);return a};e.prototype.updateTileData=function(e){for(var g=e.tileId,r=this._container.children,b,a=0;a<r.length;a++)if(b=r[a],b.id===g){b.updateTileData(e.tileData);break}};e.prototype.getVectorTile=
function(e,b,t,a){void 0===a&&(a=0);e=new c(e,b,t,0);var r=new g(e,this._vectorTileLayer.tileInfo,this._vectorTileLayer.styleRepository,0),p=this.getTileData(e,0).then(function(e){e?r.setData(e.tileData,e.client):r.setData(null,null);return r});return k.create(function(e,g){p.then(function(g){return e(g)}).catch(function(e){return g(e)})})};e.prototype.getTileData=function(e,g){var r=this;if(!this._broadcastPromise.isFulfilled()||!this._connection)return k.reject(Error("no connection"));var a=e.id;
if(this._ongoingRequests.has(a))return this._ongoingRequests.get(a);var c=this._vectorTileLayer.sourceNameToSource,p=[],A=[],f;for(f in c){var m=c[f],x=m.getRefKey(e);p.push(x);A.push(m.name)}var h=!1,c=k.eachAlways(p).then(function(t){for(var c=Math.round(b.degToByte(g)),p=[],f=0;f<t.length;f++)if(null==t[f].value)p.push(k.reject("getRefKey failed for source "+A[f]));else{var m=r._getTileData(e,t[f].value,A[f]).then(function(e){return e&&e.protobuff?e:(h=!0,r._ongoingRequests.delete(a),k.reject())});
p.push(m)}return k.eachAlways(p).then(function(g){for(var b={},p=[],f=0;f<g.length;f++)g[f].value&&g[f].value.protobuff&&0<g[f].value.protobuff.byteLength&&(b[g[f].value.sourceName]={refKey:t[f].value.toString(),protobuff:g[f].value.protobuff},p.push(g[f].value.protobuff));if(0===Object.keys(b).length)return h=!0,r._ongoingRequests.delete(a),k.resolve(null);var A=r._connection.getAvailableClient();return A.invoke("createTileAndParse",{key:e.toString(),rotation:c,cacheTile:r.allowUpdates,sourceName2DataAndRefKey:b},
{transferList:p}).then(function(e){h=!0;r._ongoingRequests.delete(a);return{tileData:e,client:A}}).catch(function(g){h=!0;r._ongoingRequests.delete(a);A.invoke("destructTileData",e.id);return k.reject(g)})}).catch(function(e){r._ongoingRequests.delete(a);return k.reject(e)})}).catch(function(e){r._ongoingRequests.delete(a);return k.reject(e)});h||this._ongoingRequests.set(a,c);return c};e.prototype.getSprites=function(e){return this._spriteMosaic.getSpriteItems(e)};e.prototype.getGlyphs=function(e){return this._glyphMosaic.getGlyphItems(e.tileID,
e.font,e.codePoints)};e.prototype.getStyleRepository=function(){return this._vectorTileLayer.styleRepository};e.prototype._getTileData=function(e,g,b){return this.fetchTileData(g.toString(),b).then(function(e){return{protobuff:e,sourceName:b}})};e.prototype._fetchTileMap=function(e){if(e.capabilities.operations.supportsTileMap&&e.tileIndex||!e.tileMapURL)return k.resolve();var g=x.get(e.tileMapURL);if(g)return e.tileIndex=g,k.resolve();if(p.has(e.tileMapURL))return p.get(e.tileMapURL).then(function(g){e.tileIndex=
new h(g.data)});g=l(e.tileMapURL,{responseType:"json"});g.then(function(g){e.tileIndex=new h(g.data);p["delete"](e.tileMapURL);x.put(e.tileMapURL,e.tileIndex)});p.set(e.tileMapURL,g);return g};e.prototype.fetchTileData=function(e,g){e=c.pool.acquire(e);var b=this._vectorTileLayer.sourceNameToSource;if(!(g in b))return c.pool.release(e),k.reject(Error("invalid source name"));g=b[g].getSourceTileUrl(e.level,e.row,e.col);c.pool.release(e);return l(g,{responseType:"array-buffer"}).then(function(e){return e.data})};
return e}()})},"esri/views/vectorTiles/GlyphMosaic":function(){define("require exports ../../core/has ../../core/promiseUtils ./Rect ./RectangleBinPack ../webgl/Texture".split(" "),function(w,v,l,u,d,k,a){return function(){function n(a,b,f){this.height=this.width=0;this._dirties=[];this._glyphData=[];this._currentPage=0;this._glyphIndex={};this._textures=[];this._rangePromises=new Map;this.width=a;this.height=b;this._glyphSource=f;this._binPack=new k(a-4,b-4);this._glyphData.push(new Uint8Array(a*
b));this._dirties.push(!0);this._textures.push(void 0)}n.prototype.getGlyphItems=function(a,b,f){var c=this,q=[],h=this._glyphSource;a=new Set;for(var g=1/256,m=0;m<f.length;m++)a.add(Math.floor(f[m]*g));var x=[];a.forEach(function(g){if(256>=g){var e=b+g;c._rangePromises.has(e)?x.push(c._rangePromises.get(e)):(g=h.getRange(b,g).then(function(){c._rangePromises["delete"](e)},function(){c._rangePromises["delete"](e)}),c._rangePromises.set(e,g),x.push(g))}});return u.all(x).then(function(g){var e=c._glyphIndex[b];
e||(e={},c._glyphIndex[b]=e);for(var a=0;a<f.length;a++){g=f[a];var p=e[g];if(p)q[g]={sdf:!0,rect:p.rect,metrics:p.metrics,page:p.page};else{var t=h.getGlyph(b,g);if(t&&t.metrics){var p=t.metrics,m=void 0;if(0===p.width)m=new d(0,0,0,0);else{var x=p.width+6,n=p.height+6,y=x%4?4-x%4:4,l=n%4?4-n%4:4;1===y&&(y=5);1===l&&(l=5);m=c._binPack.allocate(x+y,n+l);m.isEmpty&&(c._dirties[c._currentPage]||(c._glyphData[c._currentPage]=null),c._currentPage=c._glyphData.length,c._glyphData.push(new Uint8Array(c.width*
c.height)),c._dirties.push(!0),c._textures.push(void 0),c._binPack=new k(c.width-4,c.height-4),m=c._binPack.allocate(x+y,n+l));var y=c._glyphData[c._currentPage],t=t.bitmap,u=l=void 0;if(t)for(var v=0;v<n;v++)for(var l=x*v,u=c.width*(m.y+v+1)+m.x,w=0;w<x;w++)y[u+w+1]=t[l+w]}e[g]={rect:m,metrics:p,tileIDs:null,page:c._currentPage};q[g]={sdf:!0,rect:m,metrics:p,page:c._currentPage};c._dirties[c._currentPage]=!0}}}return q})};n.prototype.removeGlyphs=function(a){for(var b in this._glyphIndex){var c=
this._glyphIndex[b];if(c){var n=void 0,q;for(q in c)if(n=c[q],n.tileIDs["delete"](a),0===n.tileIDs.size){for(var h=this._glyphData[n.page],g=n.rect,m=void 0,x=void 0,p=0;p<g.height;p++)for(m=this.width*(g.y+p)+g.x,x=0;x<g.width;x++)h[m+x]=0;delete c[q];this._dirties[n.page]=!0}}}};n.prototype.bind=function(c,b,f,n){void 0===n&&(n=0);this._textures[f]||(this._textures[f]=new a(c,{pixelFormat:6406,dataType:5121,width:this.width,height:this.height},new Uint8Array(this.width*this.height)));var q=this._textures[f];
q.setSamplingMode(b);this._dirties[f]&&q.setData(this._glyphData[f]);c.bindTexture(q,n);this._dirties[f]=!1};n.prototype.dispose=function(){this._binPack=null;for(var a=0,b=this._textures;a<b.length;a++){var f=b[a];f&&f.dispose()}this._textures.length=0};return n}()})},"esri/views/vectorTiles/Rect":function(){define(["require","exports"],function(w,v){return function(){function l(l,d,k,a){void 0===l&&(l=0);void 0===d&&(d=0);void 0===k&&(k=0);void 0===a&&(a=0);this.x=l;this.y=d;this.width=k;this.height=
a}Object.defineProperty(l.prototype,"isEmpty",{get:function(){return 0>=this.width||0>=this.height},enumerable:!0,configurable:!0});return l}()})},"esri/views/vectorTiles/RectangleBinPack":function(){define(["require","exports","./Rect"],function(w,v,l){return function(){function u(d,k){this._height=this._width=0;this._free=[];this._width=d;this._height=k;this._free.push(new l(0,0,d,k))}Object.defineProperty(u.prototype,"width",{get:function(){return this._width},enumerable:!0,configurable:!0});Object.defineProperty(u.prototype,
"height",{get:function(){return this._height},enumerable:!0,configurable:!0});u.prototype.allocate=function(d,k){if(d>this._width||k>this._height)return new l;for(var a=null,n=-1,c=0;c<this._free.length;++c){var b=this._free[c];d<=b.width&&k<=b.height&&(null===a||b.y<=a.y&&b.x<=a.x)&&(a=b,n=c)}if(null===a)return new l;this._free.splice(n,1);a.width<a.height?(a.width>d&&this._free.push(new l(a.x+d,a.y,a.width-d,k)),a.height>k&&this._free.push(new l(a.x,a.y+k,a.width,a.height-k))):(a.width>d&&this._free.push(new l(a.x+
d,a.y,a.width-d,a.height)),a.height>k&&this._free.push(new l(a.x,a.y+k,d,a.height-k)));return new l(a.x,a.y,d,k)};u.prototype.release=function(d){for(var k=0;k<this._free.length;++k){var a=this._free[k];if(a.y===d.y&&a.height===d.height&&a.x+a.width===d.x)a.width+=d.width;else if(a.x===d.x&&a.width===d.width&&a.y+a.height===d.y)a.height+=d.height;else if(d.y===a.y&&d.height===a.height&&d.x+d.width===a.x)a.x=d.x,a.width+=d.width;else if(d.x===a.x&&d.width===a.width&&d.y+d.height===a.y)a.y=d.y,a.height+=
d.height;else continue;this._free.splice(k,1);this.release(d)}this._free.push(d)};return u}()})},"esri/views/vectorTiles/GlyphSource":function(){define(["require","exports","../../request","../../core/pbf","../../core/promiseUtils"],function(w,v,l,u,d){var k=function(){function a(a){this._metrics=[];this._bitmaps=[];if(a)for(;a.next();)switch(a.tag()){case 1:for(var b=a.getMessage();b.next();)switch(b.tag()){case 3:for(var c=b.getMessage(),n=void 0,q=void 0,h=void 0,g=void 0,m=void 0,x=void 0,p=void 0;c.next();)switch(c.tag()){case 1:n=
c.getUInt32();break;case 2:q=c.getBytes();break;case 3:h=c.getUInt32();break;case 4:g=c.getUInt32();break;case 5:m=c.getSInt32();break;case 6:x=c.getSInt32();break;case 7:p=c.getUInt32();break;default:c.skip()}n&&(this._metrics[n]={width:h,height:g,left:m,top:x,advance:p},this._bitmaps[n]=q);break;default:b.skip()}break;default:a.skip()}}a.prototype.getMetrics=function(a){return this._metrics[a]};a.prototype.getBitmap=function(a){return this._bitmaps[a]};return a}(),a=function(){function a(){this._ranges=
[]}a.prototype.getRange=function(a){return this._ranges[a]};a.prototype.addRange=function(a,b){this._ranges[a]=b};return a}();return function(){function n(a){this._glyphInfo={};this._baseURL=a}n.prototype.getRange=function(a,b){var c=this._getFontStack(a);if(c.getRange(b))return d.resolve();var n=256*b,q=n+255;a=this._baseURL.replace("{fontstack}",a).replace("{range}",n+"-"+q);return l(a,{responseType:"array-buffer"}).then(function(a){c.addRange(b,new k(new u(new Uint8Array(a.data),new DataView(a.data))))}).catch(function(){c.addRange(b,
new k)})};n.prototype.getGlyph=function(a,b){if(a=this._getFontStack(a)){var c=Math.floor(b/256);if(!(256<c)&&(a=a.getRange(c)))return{metrics:a.getMetrics(b),bitmap:a.getBitmap(b)}}};n.prototype._getFontStack=function(c){var b=this._glyphInfo[c];b||(b=this._glyphInfo[c]=new a);return b};return n}()})},"esri/views/vectorTiles/SpriteMosaic":function(){define("require exports ./GeometryUtils ./Rect ./RectangleBinPack ../webgl/Texture".split(" "),function(w,v,l,u,d,k){return function(){function a(a,
c,b){void 0===b&&(b=0);this._size=[];this._mosaicsData=[];this._textures=[];this._dirties=[];this._pageHeight=this._pageWidth=this._currentPage=this._maxItemSize=0;this._mosaicRects={};this.pixelRatio=1;(0>=a||0>=c)&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!");this._pageWidth=a;this._pageHeight=c;0<b&&(this._maxItemSize=b);this._binPack=new d(a-4,c-4)}a.prototype.getWidth=function(a){return a>=this._size.length?-1:this._size[a][0]};a.prototype.getHeight=
function(a){return a>=this._size.length?-1:this._size[a][1]};a.prototype.setSpriteSource=function(a){this.dispose();this.pixelRatio=a.devicePixelRatio;if(0===this._mosaicsData.length){this._binPack=new d(this._pageWidth-4,this._pageHeight-4);var c=new Uint32Array(Math.floor(this._pageWidth)*Math.floor(this._pageHeight));this._mosaicsData[0]=c;this._dirties.push(!0);this._size.push([this._pageWidth,this._pageHeight]);this._textures.push(void 0)}this._sprites=a};a.prototype.getSpriteItem=function(a,
c){void 0===c&&(c=!1);var b=this._mosaicRects[a];if(b)return b;if(!this._sprites||"loaded"!==this._sprites.loadStatus)return null;b=this._sprites.getSpriteInfo(a);if(!b||!b.width||!b.height||0>b.width||0>b.height)return null;var f=b.width,n=b.height,q=this._allocateImage(f,n),h=q[0],g=q[1];if(0>=h.width)return null;this._copy(h,b,g,q[2],c);b={rect:h,width:f,height:n,anchorX:0,anchorY:0,sdf:b.sdf,simplePattern:!1,pixelRatio:b.pixelRatio,page:g};return this._mosaicRects[a]=b};a.prototype.preloadSpriteItems=
function(){for(var a=0,c=this._sprites.spriteNames;a<c.length;a++)this.getSpriteItem(c[a],!0)};a.prototype.getSpriteItems=function(a){for(var c={},b=0;b<a.length;b++){var f=a[b];c[f]=this.getSpriteItem(f)}return c};a.prototype.getMosaicItemPosition=function(a,c){c=(a=this.getSpriteItem(a,c))&&a.rect;if(!c)return null;c.width=a.width;c.height=a.height;return{size:[a.width,a.height],tl:[(c.x+2)/this._size[a.page][0],(c.y+2)/this._size[a.page][1]],br:[(c.x+2+a.width)/this._size[a.page][0],(c.y+2+a.height)/
this._size[a.page][1]],page:a.page}};a.prototype.bind=function(a,c,b,f){void 0===b&&(b=0);void 0===f&&(f=0);this._textures[b]||(this._textures[b]=new k(a,{pixelFormat:6408,dataType:5121,width:this._size[b][0],height:this._size[b][1]},new Uint8Array(this._mosaicsData[b].buffer)));var d=this._textures[b];d.setSamplingMode(c);this._dirties[b]&&d.setData(new Uint8Array(this._mosaicsData[b].buffer));a.bindTexture(d,f);this._dirties[b]=!1};a._copyBits=function(a,c,b,f,d,q,h,g,m,x,p){var e=f*c+b;h=g*q+h;
if(p)for(h-=q,p=-1;p<=x;p++,e=((p+x)%x+f)*c+b,h+=q)for(g=-1;g<=m;g++)d[h+g]=a[e+(g+m)%m];else for(p=0;p<x;p++){for(g=0;g<m;g++)d[h+g]=a[e+g];e+=c;h+=q}};a.prototype._copy=function(d,c,b,f,k,q){if(this._sprites&&"loaded"===this._sprites.loadStatus&&!(b>=this._mosaicsData.length)){var h=new Uint32Array(q?q.buffer:this._sprites.image.buffer),g=this._mosaicsData[b];g&&h||console.error("Source or target images are uninitialized!");a._copyBits(h,q?c.width:this._sprites.width,c.x,c.y,g,f[0],d.x+2,d.y+2,
c.width,c.height,k);this._dirties[b]=!0}};a.prototype._allocateImage=function(a,c){a+=2;c+=2;var b=Math.max(a,c);if(this._maxItemSize&&this._maxItemSize<b){var b=Math.pow(2,Math.ceil(l.log2(a))),f=Math.pow(2,Math.ceil(l.log2(c)));a=new u(0,0,a,c);this._mosaicsData.push(new Uint32Array(b*f));this._dirties.push(!0);this._size.push([b,f]);this._textures.push(void 0);return[a,this._mosaicsData.length-1,[b,f]]}b=a%4?4-a%4:4;f=c%4?4-c%4:4;1===b&&(b=5);1===f&&(f=5);b=this._binPack.allocate(a+b,c+f);return 0>=
b.width?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new d(this._pageWidth-4,this._pageHeight-4),this._allocateImage(a,c)):[b,this._currentPage,[this._pageWidth,this._pageHeight]]};a.prototype.dispose=function(){this._binPack=null;this._mosaicRects=
{};for(var a=0,c=this._textures;a<c.length;a++){var b=c[a];b&&b.dispose()}this._textures.length=0};return a}()})},"esri/views/vectorTiles/TileIndex":function(){define(["require","exports","../../core/promiseUtils","../../layers/support/TilemapCache","../2d/tiling/TileKey"],function(w,v,l,u,d){return function(){function k(a){if(a instanceof u)this._tilemapCache=a;else if(a&&"index"in a)this._tilemap=a.index;else throw Error("Invalid tilemap!");}k.prototype.dataKey=function(a){if(this._tilemapCache){var k=
a.level,c=a.row,b=a.col,f=new d(a);return this._tilemapCache.fetchAvailabilityUpsample(k,c,b,f).then(function(){return f}).catch(function(a){if(a&&"cancel"===a.dojoType)throw a;f.level=k;f.row=c;f.col=b;return f})}return this._getIndexedDataKey(a)};k.prototype.forEach=function(a,d,c,b,f){this._callback=f;this._maxLevel=d+a;this._forEach(this._tilemap,d,c,b)};k.prototype._forEach=function(a,d,c,b){0!==a&&(this._callback(d,c,b),d!==this._maxLevel&&"object"===typeof a&&(this._forEach(a[0],d+1,2*c,2*
b),this._forEach(a[1],d+1,2*c,2*b+1),this._forEach(a[2],d+1,2*c+1,2*b),this._forEach(a[3],d+1,2*c+1,2*b+1)))};k.prototype._getIndexedDataKey=function(a){var k=[a];if(0>a.level||0>a.row||0>a.col||0<a.row>>a.level||0<a.col>>a.level)return l.resolve(null);for(;0!==a.level;)a=new d(a.level-1,a.row>>1,a.col>>1,a.world),k.push(a);a=this._tilemap;var c=k.pop(),b,f;if(1===a)return l.resolve(c);for(;k.length;)if(b=k.pop(),f=(b.col&1)+((b.row&1)<<1),a){if(0===a[f]){c=null;break}if(1===a[f]){c=b;break}c=b;a=
a[f]}return l.resolve(c)};return k}()})},"esri/layers/support/TilemapCache":function(){define("require exports ../../core/tsSupport/assignHelper ../../core/tsSupport/declareExtendsHelper ../../core/tsSupport/decorateHelper dojo/io-query ../../request ../../core/Accessor ../../core/Error ../../core/Handles ../../core/Logger ../../core/LRUCache ../../core/PooledArray ../../core/promiseUtils ../../core/watchUtils ../../core/accessorSupport/decorators ./Tilemap".split(" "),function(w,v,l,u,d,k,a,n,c,
b,f,y,q,h,g,m,x){var p=f.getLogger("esri.layers.support.TilemapCache");return function(e){function r(g){g=e.call(this)||this;g._handles=new b;g._pendingTilemapRequests={};g._availableLevels={};g.levels=5;g.cacheByteSize=2097152;g.request=a;return g}u(r,e);f=r;r.prototype.initialize=function(){var e=this;this._tilemapCache=new y(this.cacheByteSize);this._handles.add([this.watch(["layer.parsedUrl","layer.tileServers?"],function(){return e._initializeTilemapDefinition()}),g.init(this,"layer.tileInfo.lods",
function(a){return e._initializeAvailableLevels(a)},!0)]);this._initializeTilemapDefinition()};r.prototype.destroy=function(){this._handles&&(this._handles.destroy(),this._handles=null)};r.prototype.castLevels=function(e){return 2>=e?(p.error("Minimum levels for Tilemap is 3, but got ",e),3):e};Object.defineProperty(r.prototype,"size",{get:function(){return 1<<this.levels},enumerable:!0,configurable:!0});r.prototype.getTilemap=function(e,a,g){return this._tilemapFromCache(e,a,g,this._tmpTilemapDefinition)};
r.prototype.fetchTilemap=function(e,a,g,b){var r=this;if(!this._availableLevels[e])return h.reject(new c("tilemap-cache:level-unavailable","Level "+e+" is unavailable in the service"));var t=this._tmpTilemapDefinition;if(e=this._tilemapFromCache(e,a,g,t))return h.resolve(e);var p=x.tilemapDefinitionId(t),m=this._pendingTilemapRequests[p];m||(m=x.Tilemap.fromDefinition(t,b).then(function(e){r._tilemapCache.put(p,e,e.byteSize);delete r._pendingTilemapRequests[p];return e}).catch(function(e){delete r._pendingTilemapRequests[p];
return h.reject(e)}),this._pendingTilemapRequests[p]=m);return h.create(function(e,a){m.then(e,a)})};r.prototype.getAvailability=function(e,a,g){return this._availableLevels[e]?(e=this.getTilemap(e,a,g))?e.getAvailability(a,g):"unknown":"unavailable"};r.prototype.getAvailabilityUpsample=function(e,a,g,b){b.level=e;b.row=a;b.col=g;e=this.layer.tileInfo;for(e.updateTileInfo(b);;)if(a=this.getAvailability(b.level,b.row,b.col),"unavailable"===a){if(!e.upsampleTile(b))return"unavailable"}else return a};
r.prototype.fetchAvailability=function(e,a,g,b){return this._availableLevels[e]?this.fetchTilemap(e,a,g,b).catch(function(e){return e}).then(function(b){return b instanceof x.Tilemap?(b=b.getAvailability(a,g),"unavailable"===b?h.reject(new c("tile-map:tile-unavailable","Tile is not available",{level:e,row:a,col:g})):b):b&&"cancel"===b.dojoType?h.reject(b):"unknown"}):h.reject(new c("tilemap-cache:level-unavailable","Level "+e+" is unavailable in the service"))};r.prototype.fetchAvailabilityUpsample=
function(e,a,g,b,c){var r=this;b.level=e;b.row=a;b.col=g;var p=this.layer.tileInfo;p.updateTileInfo(b);var t=this.fetchAvailability(e,a,g,c).catch(function(e){return e&&"cancel"===e.dojoType?h.reject(e):p.upsampleTile(b)?r.fetchAvailabilityUpsample(b.level,b.row,b.col,b):h.reject(e)});if(t.isFulfilled())return t;var m={id:b.id,level:e,row:a,col:g};e=function(e){var a=x.fetchAvailability(m.level,m.row,m.col,c);f._prefetches.push(a);e=function(){return f._prefetches.removeUnordered(a)};t.then(function(){return a.cancel()},
function(){return a.cancel()});a.then(e,e)};var x=this;for(a=0;f._prefetches.length<f._maxPrefetch&&p.upsampleTile(m);++a)e(a);return t};r.prototype._initializeTilemapDefinition=function(){if(this.layer.parsedUrl){var e=this.layer.parsedUrl,a=e.query;this._tilemapCache.clear();this._tmpTilemapDefinition={service:{url:e.path,query:a?k.objectToQuery(a):null,tileServers:this.layer.tileServers,request:this.request,type:this.layer.type},width:this.size,height:this.size,level:0,row:0,col:0}}};r.prototype._tilemapFromCache=
function(e,a,g,b){e=this._getTilemapDefinition(e,a,g,b);e=x.tilemapDefinitionId(e);return this._tilemapCache.get(e)};r.prototype._getTilemapDefinition=function(e,a,g,b){b.level=e;b.row=a-a%this.size;b.col=g-g%this.size;return b};r.prototype._initializeAvailableLevels=function(e){var a=this;this._availableLevels={};e&&e.forEach(function(e){return a._availableLevels[e.level]=!0})};var f;r._maxPrefetch=4;r._prefetches=new q({initialSize:f._maxPrefetch});d([m.property({constructOnly:!0,type:Number})],
r.prototype,"levels",void 0);d([m.cast("levels")],r.prototype,"castLevels",null);d([m.property({readOnly:!0,dependsOn:["levels"],type:Number})],r.prototype,"size",null);d([m.property({constructOnly:!0,type:Number})],r.prototype,"cacheByteSize",void 0);d([m.property({constructOnly:!0})],r.prototype,"layer",void 0);d([m.property({constructOnly:!0})],r.prototype,"request",void 0);return r=f=d([m.subclass("esri.layers.support.TilemapCache")],r)}(m.declared(n))})},"esri/core/LRUCache":function(){define(["require",
"exports","./MemCache"],function(w,v,l){return function(){function u(d,k){this._storage=new l.Storage;this._storage.maxSize=d;k&&this._storage.registerRemoveFunc("",k)}u.prototype.put=function(d,k,a){this._storage.put(d,k,a)};u.prototype.pop=function(d){return this._storage.pop(d)};u.prototype.get=function(d){return this._storage.get(d)};u.prototype.clear=function(){this._storage.clearAll()};u.prototype.destroy=function(){this._storage.clearAll()};return u}()})},"esri/layers/support/Tilemap":function(){define("require exports ../../core/tsSupport/assignHelper ../../request ../../core/Error ../../core/lang ../../core/promiseUtils".split(" "),
function(w,v,l,u,d,k,a){function n(a){var b;"vector-tile"===a.service.type?b=a.service.url+"/tilemap/"+a.level+"/"+a.row+"/"+a.col+"/"+a.width+"/"+a.height:(b=a.service.tileServers,b=(b&&b.length?b[a.row%b.length]:a.service.url)+"/tilemap/"+a.level+"/"+a.row+"/"+a.col+"/"+a.width+"/"+a.height);(a=a.service.query)&&(b=b+"?"+a);return b}Object.defineProperty(v,"__esModule",{value:!0});w=function(){function c(){this.location={left:0,top:0,width:0,height:0};this.byteSize=40}c.prototype.getAvailability=
function(a,c){if(this._isAllAvailable)return"available";if(this._isAllUnvailable)return"unavailable";a=(a-this.location.top)*this.location.width+(c-this.location.left);c=a>>3;var b=this._tileAvailabilityBitSet;return 0>c||c>b.length?"unknown":b[c]&1<<a%8?"available":"unavailable"};c.prototype._updateFromData=function(a){for(var b=!0,c=!0,d=new Uint8Array(Math.ceil(this.location.width*this.location.height/8)),h=0,g=0;g<a.length;g++){var m=g%8;a[g]?(c=!1,d[h]|=1<<m):b=!1;7===m&&++h}this._isAllUnvailable=
c;this._isAllAvailable=b;this._isAllAvailable||this._isAllUnvailable||(this._tileAvailabilityBitSet=d,this.byteSize+=d.length)};c.fromDefinition=function(b,f){var k=b.service.request||u,q=b.row,h=b.col,g=b.width,m=b.height,x={query:{f:"json"}};f=f?l({},x,f):x;return k(n(b),f).then(function(a){return a.data}).catch(function(b){if(b&&b.details&&422===b.details.httpStatus){b=[];for(var e=0,c=g*m;e<c;e++)b[e]=0;return{location:{top:q,left:h,width:g,height:m},valid:!0,data:b}}return a.reject(b)}).then(function(a){if(a.location&&
(a.location.top!==q||a.location.left!==h||a.location.width!==g||a.location.height!==m))throw new d("tilemap:location-mismatch","Tilemap response for different location than requested",{response:a,definition:{top:q,left:h,width:g,height:m}});return c.fromJSON(a)})};c.fromJSON=function(a){c.validateJSON(a);var b=new c;b.location=Object.freeze(k.clone(a.location));b._updateFromData(a.data);return Object.freeze(b)};c.validateJSON=function(a){if(!a||!a.location)throw new d("tilemap:missing-location","Location missing from tilemap response");
if(!1===a.valid)throw new d("tilemap:invalid","Tilemap response was marked as invalid");if(!a.data)throw new d("tilemap:missing-data","Data missing from tilemap response");if(!Array.isArray(a.data))throw new d("tilemap:data-mismatch","Data must be an array of numbers");if(a.data.length!==a.location.width*a.location.height)throw new d("tilemap:data-mismatch","Number of data items does not match width/height of tilemap");};return c}();v.Tilemap=w;v.tilemapDefinitionId=function(a){return a.level+"/"+
a.row+"/"+a.col+"/"+a.width+"/"+a.height};v.tilemapDefinitionUrl=n;v.default=w})},"esri/views/vectorTiles/VectorTileDisplayObject":function(){define("require exports ../../core/tsSupport/extendsHelper ../../core/ObjectPool ../../core/libs/gl-matrix-2/mat4f32 ../../core/libs/gl-matrix-2/vec2f32 ../../geometry/support/spatialReferenceUtils ../2d/engine/DisplayObject ../2d/tiling/TileKey ./RenderBucket ../webgl/BufferObject".split(" "),function(w,v,l,u,d,k,a,n,c,b,f){var y="fillVertexBuffer fillDDVertexBuffer fillIndexBuffer outlineVertexBuffer outlineDDVertexBuffer outlineIndexBuffer lineVertexBuffer lineDDVertexBuffer lineIndexBuffer iconVertexBuffer iconDDVertexBuffer iconIndexBuffer textVertexBuffer textDDVertexBuffer textIndexBuffer circleVertexBuffer circleIndexBuffer".split(" ");
return function(q){function h(){for(var a,b=[],c=0;c<arguments.length;c++)b[c]=arguments[c];c=q.call(this)||this;c._renderBuckets=[];c._vectorTileData=null;c._symbolUpdateData=null;c.coords=[0,0];c.bounds=[0,0,0,0];c.tileTransform={transform:d.mat4f32.create(),displayCoord:k.vec2f32.create()};c.stencilData={mask:0,reference:0};0<b.length&&(a=c.acquire).call.apply(a,[c].concat(b));return c}l(h,q);h.prototype.reset=function(){c.pool.release(this.key);this.key=null;this.coords[0]=0;this.coords[1]=0;
this.bounds[0]=0;this.bounds[1]=0;this.bounds[2]=0;this.height=this.width=this.bounds[3]=0;this.resolution=null;this.rotation=0;this.id=this.client=this.styleLayers=this._vectorTileData=null;this.tileTransform.transform.fill(0);this.tileTransform.displayCoord.fill(0);this.stencilData.mask=0;this.stencilData.reference=0;this._renderBuckets.length=0;this.stage=this._symbolUpdateData=null};h.prototype.acquire=function(g,b,c,p){this.key=g;var e=b.lodAt(g.level),e=null!==e?e.resolution:0,r=b.size[0]*e,
m=b.origin,t=g.col*r,f=g.row*r,h=b.spatialReference,x=0;h&&(h._isWrappable?h._isWrappable():h.isWrappable)&&(h=a.getInfo(h),x=h.valid[1]-h.valid[0]);t=m.x+t+g.world*x;m=m.y-f;this.coords[0]=t;this.coords[1]=m;this.bounds[0]=t;this.bounds[1]=m;this.bounds[2]=t+r;this.bounds[3]=m-r;this.widthInPixels=b.size[1];this.coordRange=4096;this.resolution=e;this.rotation=p;this.styleLayers=c;this.id=g.id};h.prototype.setData=function(a,b){this._vectorTileData=a;this.client=b};h.prototype.updateSymbolData=function(a){a&&
(this._symbolUpdateData=a,this.requestRender())};h.prototype.updateTileData=function(a){this._vectorTileData=a;this.stage.requestRender()};h.prototype.dispose=function(){for(var a="fillVertexArrayObject fillDDVertexArrayObject outlineVertexArrayObject lineVertexArrayObject lineDDVertexArrayObject iconVertexArrayObject iconDDVertexArrayObject textVertexArrayObject textDDVertexArrayObject circleVertexArrayObject fillVertexBuffer fillDDVertexBuffer fillIndexBuffer outlineVertexBuffer outlineDDVertexBuffer outlineIndexBuffer lineVertexBuffer lineDDVertexBuffer lineIndexBuffer iconVertexBuffer iconDDVertexBuffer iconIndexBuffer textVertexBuffer textDDVertexBuffer textIndexBuffer circleVertexBuffer circleIndexBuffer texture".split(" "),
b=0;b<a.length;++b){var c=a[b];this[c]&&(this[c].dispose(),this[c]=null)}this._renderBuckets.length=0};h.prototype.getCpuMemoryUsage=function(){return null!=this._vectorTileData&&this._vectorTileData.bufferData?this._vectorTileData.bufferData.reduce(function(a,b){return a+b.byteLength},0)+this._vectorTileData.bufferDataInfo.byteLength+this._vectorTileData.bucketDataInfo.byteLength:0};h.prototype.getGpuMemoryUsage=function(){var a=this,b=y.reduce(function(g,b){return a[b]?g+a[b].size:g},0);this.texture&&
(b+=this.texture.descriptor.width*this.texture.descriptor.height*4);return b};h.prototype.attachWithContext=function(a){this.stage={context:a};this.attached=this.attach()};h.prototype._commitChanges=function(){this._vectorTileData&&(this.dispose(),this._createRenderBuckets(),this._createBufferObjects(),this._vectorTileData=null)};h.prototype._createRenderBuckets=function(){for(var a=new Uint32Array(this._vectorTileData.bucketDataInfo),c=a.length,h=0;h<c;){var p=a[h];switch(a[h+1]){case 0:var e=new b.BackgroundRenderBucket;
e.layerID=p;this._renderBuckets.push(e);h+=2;break;case 1:e=new b.FillRenderBucket;e.layerID=p;e.triangleElementStart=a[h+2];e.triangleElementCount=a[h+3];e.outlineElementStart=a[h+4];e.outlineElementCount=a[h+5];this._renderBuckets.push(e);h+=6;break;case 2:e=new b.LineRenderBucket;e.layerID=p;e.triangleElementStart=a[h+2];e.triangleElementCount=a[h+3];this._renderBuckets.push(e);h+=4;break;case 3:e=new b.SymbolRenderBucket;e.layerID=p;e.isSDF=0!==a[h+2];var r=h+3,p=a[r];r++;if(0<p)for(var f=void 0,
t=void 0,d=void 0,k=0;k<p;k++)f=a[r],t=a[r+1],d=a[r+2],e.markerPerPageElementsMap.set(f,[t,d]),r+=3;var q=a[r];r++;if(0<q)for(d=t=f=void 0,k=0;k<q;k++)f=a[r],t=a[r+1],d=a[r+2],e.glyphPerPageElementsMap.set(f,[t,d]),r+=3;this._renderBuckets.push(e);h+=5+3*p+3*q;break;case 4:e=new b.CircleRenderBucket;e.layerID=p;e.triangleElementStart=a[h+2];e.triangleElementCount=a[h+3];this._renderBuckets.push(e);h+=4;break;default:console.error("Bad bucket type!"),h+=2}}};h._createBufferToObject=function(){var a=
[];a[1]={create:f.createVertex,var:"fillVertexBuffer"};a[2]={create:f.createVertex,var:"fillDDVertexBuffer"};a[3]={create:f.createIndex,var:"fillIndexBuffer"};a[4]={create:f.createVertex,var:"outlineVertexBuffer"};a[5]={create:f.createVertex,var:"outlineDDVertexBuffer"};a[6]={create:f.createIndex,var:"outlineIndexBuffer"};a[7]={create:f.createVertex,var:"lineVertexBuffer"};a[8]={create:f.createVertex,var:"lineDDVertexBuffer"};a[9]={create:f.createIndex,var:"lineIndexBuffer"};a[10]={create:f.createVertex,
var:"iconVertexBuffer"};a[11]={create:f.createVertex,var:"iconDDVertexBuffer"};a[12]={create:f.createIndex,var:"iconIndexBuffer"};a[13]={create:f.createVertex,var:"textVertexBuffer"};a[14]={create:f.createVertex,var:"textDDVertexBuffer"};a[15]={create:f.createIndex,var:"textIndexBuffer"};a[16]={create:f.createVertex,var:"circleVertexBuffer"};a[17]={create:f.createIndex,var:"circleIndexBuffer"};return a};h.prototype._createBufferObjects=function(){for(var a=this.stage.context,b=new Uint32Array(this._vectorTileData.bufferDataInfo),
c=b.length,p=0,e=0;e<c;e+=2,p++){var r=b[e];if(!(0>=b[e+1]||0===this._vectorTileData.bufferData[p].byteLength)){var f=h.bufferToObject[r];f?this[f.var]?this[f.var].setData(this._vectorTileData.bufferData[p]):this[f.var]=f.create(a,35044,this._vectorTileData.bufferData[p]):console.error("Bad buffer type "+r)}}};h.prototype.detach=function(){this.isReady&&this.client.invoke("destructTileData",this.id);this.dispose();q.prototype.detach.call(this)};h.prototype.doRender=function(a){if(this.visible&&this.isReady){var b=
this.stage.context,g=a.renderer;if(b&&g){this._commitChanges();var c=a.drawphase;this._symbolUpdateData&&(this._updateSymbolData(a,this._symbolUpdateData),this._symbolUpdateData=null);b.setStencilFunction(514,this.stencilData.reference,this.stencilData.mask);var e=this.styleLayers,r,h=void 0!==a.layerOpacity?a.layerOpacity:1;if(0!==h){var t=this._renderBuckets.length;if(0===c)for(var f=t-1;0<=f;f--){var d=this._renderBuckets[f];r=e.layers[d.layerID];if(!d||!r)break;1!==d.type&&0!==d.type||!d.hasData()||
g.renderBucket(b,d,a.displayLevel,a.requiredLevel,c,this,r,h)}else for(f=0;f<t;f++){d=this._renderBuckets[f];r=e.layers[d.layerID];if(!d||!r)break;d.hasData()&&g.renderBucket(b,d,a.displayLevel,a.requiredLevel,c,this,r,h)}}}}};h.prototype._updateSymbolData=function(a,c){if(!c||!c.bucketDataInfo)return!0;a=new Uint32Array(c.bucketDataInfo);var g=a.length;if(0===g)return!0;if(!this.isReady)return this.requestRender(),!1;for(var h=this.stage.context,e=new Uint32Array(c.bufferDataInfo),r=e.length,d=0,
t=0;t<r;t+=2,d++)switch(e[t]){case 10:this.iconVertexBuffer&&(this.iconVertexBuffer.dispose(),this.iconVertexBuffer=null);this.iconVertexBuffer=f.createVertex(h,35044,c.bufferData[d]);break;case 11:this.iconDDVertexBuffer&&(this.iconDDVertexBuffer.dispose(),this.iconDDVertexBuffer=null);this.iconDDVertexBuffer=f.createVertex(h,35044,c.bufferData[d]);break;case 12:this.iconIndexBuffer&&(this.iconIndexBuffer.dispose(),this.iconIndexBuffer=null);this.iconIndexBuffer=f.createIndex(h,35044,c.bufferData[d]);
break;case 13:this.textVertexBuffer&&(this.textVertexBuffer.dispose(),this.textVertexBuffer=null);this.textVertexBuffer=f.createVertex(h,35044,c.bufferData[d]);break;case 14:this.textDDVertexBuffer&&(this.textDDVertexBuffer.dispose(),this.textDDVertexBuffer=null);this.textDDVertexBuffer=f.createVertex(h,35044,c.bufferData[d]);break;case 15:this.textIndexBuffer&&(this.textIndexBuffer.dispose(),this.textIndexBuffer=null),this.textIndexBuffer=f.createIndex(h,35044,c.bufferData[d])}c=[];for(h=0;h<this._renderBuckets.length;h++)this._renderBuckets[h]instanceof
b.SymbolRenderBucket||c.push(this._renderBuckets[h]);this._renderBuckets=c;for(h=0;h<g;){r=a[h];e=new b.SymbolRenderBucket;e.layerID=r;e.isSDF=0!==a[h+2];this.styleLayers.layers.length>e.layerID&&this.styleLayers.layers[e.layerID].type===e.type&&c.push(e);var m=h+3,r=a[m];m++;if(0<r)for(var k=t=d=void 0,q=0;q<r;q++)d=a[m],t=a[m+1],k=a[m+2],e.markerPerPageElementsMap.set(d,[t,k]),m+=3;var l=a[m];m++;if(0<l)for(k=t=d=void 0,q=0;q<l;q++)d=a[m],t=a[m+1],k=a[m+2],e.glyphPerPageElementsMap.set(d,[t,k]),
m+=3;h+=5+3*r+3*l}this.iconVertexArrayObject&&(this.iconVertexArrayObject.dispose(),this.iconVertexArrayObject=null);this.iconDDVertexArrayObject&&(this.iconDDVertexArrayObject.dispose(),this.iconDDVertexArrayObject=null);this.textVertexArrayObject&&(this.textVertexArrayObject.dispose(),this.textVertexArrayObject=null);this.textDDVertexArrayObject&&(this.textDDVertexArrayObject.dispose(),this.textDDVertexArrayObject=null);return!0};h.pool=new u(h);h.bufferToObject=h._createBufferToObject();return h}(n.DisplayObject)})},
"esri/views/vectorTiles/RenderBucket":function(){define(["require","exports","../../core/tsSupport/extendsHelper","../../core/tsSupport/decorateHelper"],function(w,v,l,u){Object.defineProperty(v,"__esModule",{value:!0});w=function(){return function(d){this.type=d}}();v.RenderBucket=w;u=function(d){function k(){var a=d.call(this,2)||this;a.triangleElementStart=0;a.triangleElementCount=0;return a}l(k,d);k.prototype.hasData=function(){return 0<this.triangleElementCount};return k}(w);v.LineRenderBucket=
u;u=function(d){function k(){var a=d.call(this,1)||this;a.triangleElementStart=0;a.triangleElementCount=0;a.outlineElementStart=0;a.outlineElementCount=0;return a}l(k,d);k.prototype.hasData=function(){return 0<this.triangleElementCount||0<this.outlineElementCount};return k}(w);v.FillRenderBucket=u;u=function(d){function k(){var a=d.call(this,3)||this;a.markerPerPageElementsMap=new Map;a.glyphPerPageElementsMap=new Map;a.isSDF=!1;return a}l(k,d);k.prototype.hasData=function(){return 0<this.markerPerPageElementsMap.size||
0<this.glyphPerPageElementsMap.size};return k}(w);v.SymbolRenderBucket=u;u=function(d){function k(){var a=d.call(this,4)||this;a.triangleElementStart=0;a.triangleElementCount=0;return a}l(k,d);k.prototype.hasData=function(){return 0<this.triangleElementCount};return k}(w);v.CircleRenderBucket=u;w=function(d){function k(){return d.call(this,0)||this}l(k,d);k.prototype.hasData=function(){return!0};return k}(w);v.BackgroundRenderBucket=w})},"esri/views/vectorTiles/VectorTileContainer":function(){define("require exports ../../core/tsSupport/extendsHelper ../../core/has ../../core/promiseUtils ../../core/libs/gl-matrix-2/mat4 ../../core/libs/gl-matrix-2/mat4f32 ../../core/libs/gl-matrix-2/vec3f32 ../2d/engine/Container ../2d/engine/webgl/enums ./GeometryUtils ./renderers/Renderer".split(" "),
function(w,v,l,u,d,k,a,n,c,b,f,y){return function(c){function h(){var b=null!==c&&c.apply(this,arguments)||this;b._renderer=new y;b._tileCoordinateScale=n.vec3f32.create();b._orientationVec=n.vec3f32.fromValues(0,0,1);b._displayScale=n.vec3f32.create();b._defaultTransform=a.mat4f32.create();b._displayWidth=0;b._displayHeight=0;b._pointToCallbacks=new Map;return b}l(h,c);h.prototype.initialize=function(a,b,c,h){this._renderer.initialize(a,b);this._tileInfoView=h;this._tileInfo=c};h.prototype.dispose=
function(){this._renderer&&this._renderer.dispose();c.prototype.dispose.call(this)};h.prototype.hitTest=function(a,b){var c=this,g=[a,b];return d.create(function(a,b){c._pointToCallbacks.set(g,{resolve:a,reject:b});c.requestRender()},function(){c._pointToCallbacks.has(g)&&c._pointToCallbacks.delete(g)})};h.prototype.renderChildren=function(a){var g=this;if(0!==this.children.length&&this._tileInfoView&&a&&a.state&&(a.drawPhase===b.WGLDrawPhase.MAP||a.drawPhase===b.WGLDrawPhase.HITTEST)){var h=a.state,
f=this.stage.context,e=this._renderer;e.initializeProgramCache(this.stage.context);e.setGlobalOpacity(f,a,this.opacity);f.setDepthWriteEnabled(!0);f.setStencilWriteMask(255);f.setClearDepth(1);f.setClearStencil(0);f.clear(f.gl.DEPTH_BUFFER_BIT|f.gl.STENCIL_BUFFER_BIT);f.setDepthWriteEnabled(!1);a.displayLevel=this._tileInfoView.scaleToLevel(h.scale);a.requiredLevel=this._tileInfoView.getSmallestInfoForScale(h.scale).level;a.renderer=this._renderer;this.sortChildren(function(a,e){return a.key.level-
e.key.level});for(var h=this.children.length,r=1;r<=h;r++){var d=this.children[r-1];d.attached&&d.visible&&(d.stencilData.reference=r,d.stencilData.mask=255)}this._updateTilesTransform(a.state,a.requiredLevel,this.children);f.setDepthWriteEnabled(!0);this._renderer.setStateParams(a.state,a.pixelRatio,a.displayLevel);this._renderer.drawClippingMasks(f,this.children);f.setStencilWriteMask(0);f.setBlendFunctionSeparate(1,771,1,771);f.setStencilOp(7680,7680,7681);f.setDepthFunction(515);f.setBlendingEnabled(!1);
f.setStencilTestEnabled(!0);f.setDepthTestEnabled(!0);f.setDepthWriteEnabled(!0);a.drawphase=0;c.prototype.renderChildren.call(this,a);f.setDepthWriteEnabled(!1);f.setBlendingEnabled(!0);a.drawphase=1;c.prototype.renderChildren.call(this,a);a.drawphase=2;c.prototype.renderChildren.call(this,a);f.setStencilTestEnabled(!1);f.setDepthTestEnabled(!1);e.applyGlobalOpacity(f,a,this.opacity);if(u("esri-vector-tiles-debug"))for(e=0,h=this.children;e<h.length;e++)r=h[e],r.attached&&r.visible&&this._renderer.renderTileInfo(f,
r);0<this._pointToCallbacks.size&&(this._pointToCallbacks.forEach(function(e,b){e.resolve(g._hitTest(a,b[0],b[1]))}),this._pointToCallbacks.clear());this._renderer.needsRedraw()&&this.requestRender()}};h.prototype.removeAllChildren=function(){for(var a=0;a<this.children.length;a++)this.children[a].dispose();c.prototype.removeAllChildren.call(this)};h.prototype._hitTest=function(a,b,c){var g=this._tileInfoView.getSmallestInfoForScale(a.state.scale).level,e=[0,0];a.state.toMap(e,[b,c]);var r=a.state.clone(),
h=r.viewpoint.clone(),f=h.targetGeometry;f.x=e[0];f.y=e[1];h.targetGeometry=f;r.viewpoint=h;r.size=[3,3];this._renderer.setStateParams(r,a.pixelRatio,a.displayLevel);return(a=this._renderer.hitTest({context:this.stage.context,drawPhase:0,pixelRatio:a.pixelRatio,stationary:a.stationary,globalOpacity:a.globalOpacity,displayLevel:a.displayLevel,requiredLevel:a.requiredLevel,renderer:a.renderer,layerOpacity:a.layerOpacity,state:r,drawphase:3},b,c,this.children,g,3,this._updateTilesTransform.bind(this)))&&
0!==a.length?a[0]:null};h.prototype._updateTilesTransform=function(a,b,c){var g=1/a.size[0],e=1/a.size[1],r=[0,0];this._calculateRelativeViewProjMat(this._tileInfo.lodAt(b).resolution,a.resolution,a.rotation,this._tileInfo.size[1],4096,a.size[0],a.size[1],this._defaultTransform);for(var h=0;h<c.length;h++){var f=c[h];a.toScreen(r,f.coords);r[1]=a.size[1]-r[1];f.tileTransform.displayCoord[0]=2*r[0]*g-1;f.tileTransform.displayCoord[1]=2*r[1]*e-1;f.key.level===b&&4096===f.coordRange?f.tileTransform.transform.set(this._defaultTransform):
this._calculateRelativeViewProjMat(this._tileInfo.lodAt(f.key.level).resolution,a.resolution,a.rotation,this._tileInfo.size[1],f.coordRange,a.size[0],a.size[1],f.tileTransform.transform)}};h.prototype._calculateRelativeViewProjMat=function(a,b,c,h,e,r,d,t){var g=.125;512!==h&&4096!==e&&(g=h/e);a=a/b*g;this._tileCoordinateScale.set([a,a,1]);if(r!==this._displayWidth||d!==this._displayHeight)this._displayScale.set([2/r,-2/d,1]),this._displayWidth=r,this._displayHeight=d;k.mat4.identity(t);k.mat4.scale(t,
t,this._tileCoordinateScale);k.mat4.rotate(t,t,-c*f.C_DEG_TO_RAD,this._orientationVec);k.mat4.scale(t,t,this._displayScale);k.mat4.transpose(t,t)};return h}(c.Container)})},"esri/views/vectorTiles/renderers/Renderer":function(){define("require exports ../../../core/libs/gl-matrix-2/mat4 ../../../core/libs/gl-matrix-2/mat4f32 ../../../core/libs/gl-matrix-2/vec3f32 ../../../core/libs/gl-matrix-2/vec4f32 ../../2d/engine/webgl/BitBlitRenderer ../GeometryUtils ./BackgroundRenderer ./CircleRenderer ./FadeRecorder ./FillRenderer ./LineRenderer ./SymbolRenderer ./TileInfoRenderer ./shaders/ProgramCache ../../webgl/FramebufferObject".split(" "),
function(w,v,l,u,d,k,a,n,c,b,f,y,q,h,g,m,x){return function(){function p(){this._extrudeMatrix=u.mat4f32.create();this._extrudeNoRotationMatrix=u.mat4f32.create();this._extrudeRotateVector=d.vec3f32.fromValues(0,0,1);this._extrudeScaleVector=d.vec3f32.fromValues(1,1,1);this._backgroundColor=k.vec4f32.fromValues(1,0,0,1);this._state={rotation:0,size:[0,0]};this._cachedRotation=this._cachedHeight=this._cachedWidth=0;this._blitRenderer=new a;this._programCache=this._boundFBO=this._globalOpacityFBO=null}
p.prototype.initialize=function(a,b,c){void 0===c&&(c=!0);this._SpriteMosaic=a;this._glyphMosaic=b;this._ignoreSpeed=!c;this._fadeRecorder=new f.FadeRecorder(300)};p.prototype.dispose=function(){this._backgroundRenderer&&(this._backgroundRenderer.dispose(),this._backgroundRenderer=null);this._lineRenderer&&(this._lineRenderer.dispose(),this._lineRenderer=null);this._fillRenderer&&(this._fillRenderer.dispose(),this._fillRenderer=null);this._symbolRenderer&&(this._symbolRenderer.dispose(),this._symbolRenderer=
null);this._circleRenderer&&(this._circleRenderer.dispose(),this._circleRenderer=null);this._tileInfoRenderer&&(this._tileInfoRenderer.dispose(),this._tileInfoRenderer=null);this._hittestFBO&&(this._hittestFBO.dispose(),this._hittestFBO=null);this._globalOpacityFBO&&(this._globalOpacityFBO.dispose(),this._globalOpacityFBO=null);this._blitRenderer&&(this._blitRenderer.dispose(),this._blitRenderer=null);this._boundFBO=null;this._programCache&&(this._programCache.dispose(),this._programCache=null);this._cachedRotation=
this._cachedHeight=this._cachedWidth=0};p.prototype.initializeProgramCache=function(a){if(null===this._programCache){var e=new m.default;e.initialize(a);this._backgroundRenderer=new c(e);this._lineRenderer=new q(e);this._fillRenderer=new y(e);this._symbolRenderer=new h(e);this._circleRenderer=new b(e);this._tileInfoRenderer=new g(e);this._programCache=e}};p.prototype.setStateParams=function(a,b,c){this._fadeRecorder.recordLevel(c);this._state=a;if(this._state.size[0]!==this._cachedWidth||this._state.size[1]!==
this._cachedHeight||this._state.rotation!==this._cachedRotation)this._extrudeScaleVector[0]=2/a.size[0],this._extrudeScaleVector[1]=-2/a.size[1],l.mat4.identity(this._extrudeMatrix),l.mat4.rotate(this._extrudeMatrix,this._extrudeMatrix,-a.rotation*n.C_DEG_TO_RAD,this._extrudeRotateVector),l.mat4.scale(this._extrudeMatrix,this._extrudeMatrix,this._extrudeScaleVector),l.mat4.transpose(this._extrudeMatrix,this._extrudeMatrix),l.mat4.identity(this._extrudeNoRotationMatrix),l.mat4.scale(this._extrudeNoRotationMatrix,
this._extrudeNoRotationMatrix,this._extrudeScaleVector),l.mat4.transpose(this._extrudeNoRotationMatrix,this._extrudeNoRotationMatrix),this._cachedWidth=this._state.size[0],this._cachedHeight=this._state.size[1],this._cachedRotation=this._state.rotation};p.prototype.drawClippingMasks=function(a,b){if(0!==b.length){a.setDepthWriteEnabled(!1);a.setDepthTestEnabled(!1);a.setStencilTestEnabled(!0);a.setBlendingEnabled(!1);a.setColorMask(!1,!1,!1,!1);a.setStencilOp(7680,7680,7681);a.setStencilWriteMask(255);
a.setClearStencil(0);a.clear(a.gl.STENCIL_BUFFER_BIT);for(var e=0;e<b.length;e++){var c=b[e];c.attached&&c.visible&&(a.setStencilFunctionSeparate(1032,519,c.stencilData.reference,c.stencilData.mask),this._backgroundRenderer.renderSolidColor(a,{u_matrix:c.tileTransform.transform,u_normalized_origin:c.tileTransform.displayCoord,u_coord_range:c.coordRange,u_depth:0,u_color:this._backgroundColor}))}a.setColorMask(!0,!0,!0,!0);a.setBlendingEnabled(!0)}};p.prototype.renderDebug=function(a,b){var e=b.key;
this._backgroundColor.set([e.col%2,e.row%2,0===e.col%2&&0===e.row%2?1:0,.5]);this._backgroundRenderer.renderSolidColor(a,{u_matrix:b.tileTransform.transform,u_normalized_origin:b.tileTransform.displayCoord,u_coord_range:b.coordRange,u_depth:0,u_color:this._backgroundColor})};p.prototype.renderBucket=function(a,b,c,g,h,f,d,m){if(d&&!(void 0!==d.minzoom&&d.minzoom>c+1E-6||f.key.level===g&&void 0!==d.maxzoom&&d.maxzoom<=c-1E-6))switch(b.type){case 0:2!==h&&this._renderBackground(a,b,c,h,f,d,m);break;
case 1:2!==h&&this._renderFill(a,b,c,h,f,d,m);break;case 2:1!==h&&3!==h||this._renderLine(a,b,c,h,f,d,m);break;case 3:2!==h&&3!==h||this._renderSymbol(a,b,c,h,g,f,d,m);break;case 4:2!==h&&3!==h||this._renderCircle(a,b,c,h,g,f,d,m)}};p.prototype.renderTileInfo=function(a,b){this._tileInfoRenderer.render(a,b)};p.prototype.setGlobalOpacity=function(a,b,c){if(1!==c){this._boundFBO=a.getBoundFramebufferObject();c=b.pixelRatio;var e=b.state.size;b=Math.round(e[0]*c);c=Math.round(e[1]*c);if(null===this._globalOpacityFBO||
this._globalOpacityFBO.width!==b||this._globalOpacityFBO.height!==c)null!==this._globalOpacityFBO&&this._globalOpacityFBO.dispose(),this._globalOpacityFBO=x.create(a,{colorTarget:0,depthStencilTarget:3,width:b,height:c});a.bindFramebuffer(this._globalOpacityFBO);a.setClearColor(0,0,0,0);a.clear(a.gl.COLOR_BUFFER_BIT)}};p.prototype.applyGlobalOpacity=function(a,b,c){if(1!==c){var e=b.pixelRatio,h=b.state.size;b=h[0];var h=h[1],g=a.getViewport();a.setViewport(0,0,e*b,e*h);a.bindFramebuffer(this._boundFBO);
this._blitRenderer.render(a,this._globalOpacityFBO.colorTexture,9728,c);a.setViewport(g.x,g.y,g.width,g.height);this._boundFBO=null}};p.prototype.needsRedraw=function(){return this._fadeRecorder.needsRedraw()};p.prototype.hitTest=function(a,b,c,h,g,f,d){var e=[0,0],r=[0,0],m=a.state;m.toMap(e,[0,0]);m.toMap(r,[f,f]);b=h.filter(function(a){return!(e[0]>a.bounds[2]||r[0]<a.bounds[0]||e[1]<a.bounds[3]||r[1]>a.bounds[1])});if(0===b.length)return[];b.sort(function(a,e){return a.key.level-e.key.level});
c=b.length;for(h=1;h<=c;h++){var k=b[h-1];k.attached&&(k.stencilData.reference=h,k.stencilData.mask=255)}d(m,g,b);g=a.context;this._hittestFBO||(this._hittestFBO=x.create(g,{colorTarget:0,depthStencilTarget:3,width:f,height:f}));d=g.getViewport();m=g.getBoundFramebufferObject();g.bindFramebuffer(this._hittestFBO);g.setViewport(0,0,f,f);h=g.gl;g.setDepthWriteEnabled(!0);g.setStencilWriteMask(255);g.setClearColor(1,1,1,1);g.setClearDepth(1);g.setClearStencil(0);g.clear(h.COLOR_BUFFER_BIT|h.DEPTH_BUFFER_BIT|
h.STENCIL_BUFFER_BIT);g.setDepthWriteEnabled(!1);this.drawClippingMasks(g,b);g.setBlendingEnabled(!1);g.setStencilWriteMask(0);g.setStencilOp(7680,7680,7681);g.setDepthFunction(515);g.setDepthTestEnabled(!0);g.setDepthWriteEnabled(!0);g.setStencilTestEnabled(!0);for(h=0;h<c;h++)k=b[h],k.attached&&k.doRender(a);g.setStencilTestEnabled(!1);g.setDepthTestEnabled(!1);this._readbackBuffer||(this._readbackBuffer=new Uint8Array(4*f*f),this._readbackBuffer32=new Uint32Array(this._readbackBuffer.buffer));
this._hittestFBO.readPixels(0,0,f,f,6408,5121,this._readbackBuffer);a=new Set;f*=f;b=this._readbackBuffer32[Math.round(f/2)];4294967295!==b&&a.add(b);for(h=0;h<f;h++)b=this._readbackBuffer32[h],4294967295!==b&&a.add(b);g.bindFramebuffer(m);g.setViewport(d.x,d.y,d.width,d.height);var q=[];a.forEach(function(a){q.push(a)});return q};p.prototype._renderBackground=function(a,b,c,g,h,f,d){this._backgroundRenderer.render(a,b,c,g,h,f,this._SpriteMosaic,this._SpriteMosaic.pixelRatio,d)};p.prototype._renderLine=
function(a,b,c,g,h,f,d){this._lineRenderer.render(a,b,c,g,this._state,h,f,this._SpriteMosaic,this._extrudeMatrix,this._SpriteMosaic.pixelRatio,d)};p.prototype._renderFill=function(a,b,c,g,h,f,d){this._fillRenderer.render(a,b,c,this._state.rotation,g,h,f,this._SpriteMosaic,this._extrudeMatrix,this._SpriteMosaic.pixelRatio,d)};p.prototype._renderCircle=function(a,b,c,g,h,f,d,m){var e=!0;h===f.key.level&&(e=!1);a.setStencilTestEnabled(e);this._circleRenderer.render(a,b,c,g,this._state.rotation,f,d,this._extrudeMatrix,
m)};p.prototype._renderSymbol=function(a,b,c,g,h,f,d,m){var e=!0;h===f.key.level&&(e=!1);a.setStencilTestEnabled(e);this._symbolRenderer.render(a,b,c,g,this._state.rotation,this._fadeRecorder.getFadeValues(this._ignoreSpeed),f,d,this._SpriteMosaic,this._glyphMosaic,this._extrudeMatrix,this._extrudeNoRotationMatrix,this._SpriteMosaic.pixelRatio,m)};return p}()})},"esri/views/vectorTiles/renderers/BackgroundRenderer":function(){define("require exports ../../../core/libs/gl-matrix-2/mat3 ../../../core/libs/gl-matrix-2/mat3f32 ../../../core/libs/gl-matrix-2/vec4f32 ../MemoryBuffer ./rendererUtils ../../webgl/BufferObject ../../webgl/VertexArrayObject".split(" "),
function(w,v,l,u,d,k,a,n,c){return function(){function b(a){this._patternMatrix=u.mat3f32.create();this._color=d.vec4f32.create();this._rendererInitialized=this._solidrendererInitialized=!1;this._programOptions={id:!1,pattern:!1};this._programCache=a;this._color.set([1,0,0,1])}b.prototype.dispose=function(){this._solidVertexArrayObject&&(this._solidVertexArrayObject.dispose(),this._solidVertexArrayObject=null);this._vertexArrayObject&&(this._vertexArrayObject.dispose(),this._vertexArrayObject=null)};
b.prototype.renderSolidColor=function(a,b){this._solidrendererInitialized||this._initializeSolidRenderer(a);a.bindVAO(this._solidVertexArrayObject);var c=this._programOptions;c.id=!1;c.pattern=!1;c=this._programCache.getProgram(0,0,c);a.bindProgram(c);c.setUniformMatrix4fv("u_transformMatrix",b.u_matrix);c.setUniform2fv("u_normalized_origin",b.u_normalized_origin);c.setUniform1f("u_coord_range",b.u_coord_range||4096);c.setUniform1f("u_depth",b.u_depth||0);c.setUniform4fv("u_color",b.u_color||this._color);
a.drawArrays(5,0,4);a.bindVAO()};b.prototype.render=function(b,c,d,h,g,m,k,p,e){this._rendererInitialized||this._initialize(b);var f=m.getPaintValue("background-color",d);e*=m.getPaintValue("background-opacity",d);var q=m.getPaintValue("background-pattern",d),t=void 0!==q,x=f[3]*e,n=t||1>x;if(!n||0!==h)if(n||1!==h){h=3===h;n=this._programOptions;n.id=h;n.pattern=t;n=this._programCache.getProgram(0,(h?1:0)<<1|(t?1:0),n);b.bindVAO(this._vertexArrayObject);b.bindProgram(n);n.setUniform1f("u_coord_range",
g.coordRange);n.setUniform1f("u_depth",m.z||0);n.setUniformMatrix4fv("u_transformMatrix",g.tileTransform.transform);n.setUniform2fv("u_normalized_origin",g.tileTransform.displayCoord);if(t){m=k.getMosaicItemPosition(q,!0);if(!m)return;d=512*Math.pow(2,Math.floor(d)-g.key.level)*p;l.mat3.identity(this._patternMatrix);g=d/m.size[1];this._patternMatrix[0]=d/m.size[0];this._patternMatrix[4]=g;k.bind(b,9729,m.page,5);n.setUniformMatrix3fv("u_pattern_matrix",this._patternMatrix);n.setUniform1f("u_opacity",
e);n.setUniform2f("u_pattern_tl",m.tl[0],m.tl[1]);n.setUniform2f("u_pattern_br",m.br[0],m.br[1]);n.setUniform1i("u_texture",5)}else this._color[0]=x*f[0],this._color[1]=x*f[1],this._color[2]=x*f[2],this._color[3]=x,n.setUniform4fv("u_color",this._color);h&&(c=a.int32To4Bytes(c.layerID),n.setUniform4f("u_id",c[0],c[1],c[2],c[3]));b.drawArrays(5,0,4);b.bindVAO()}};b.prototype._initializeSolidRenderer=function(a){if(this._solidrendererInitialized)return!0;var b=new Int8Array([0,0,1,0,0,1,1,1]),b=n.createVertex(a,
35044,b);this._solidVertexArrayObject=new c(a,this._programCache.getProgramAttributes(0),{geometry:[{name:"a_pos",count:2,type:5120,offset:0,stride:2,normalized:!1,divisor:0}]},{geometry:b});return this._solidrendererInitialized=!0};b.prototype._initialize=function(a){if(this._rendererInitialized)return!0;var b=[];b.push(k.i1616to32(0,0));b.push(k.i1616to32(1,0));b.push(k.i1616to32(0,1));b.push(k.i1616to32(1,1));b=new Uint32Array(b);b=n.createVertex(a,35044,b);this._vertexArrayObject=new c(a,{a_pos:0},
{geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:4,normalized:!1,divisor:0}]},{geometry:b});return this._rendererInitialized=!0};return b}()})},"esri/views/vectorTiles/MemoryBuffer":function(){define(["require","exports"],function(w,v){return function(){function l(l){this._array=[];0>=l&&console.error("strideInBytes must be positive!");this._stride=l}Object.defineProperty(l.prototype,"array",{get:function(){return this._array},enumerable:!0,configurable:!0});Object.defineProperty(l.prototype,
"index",{get:function(){return 4*this._array.length/this._stride},enumerable:!0,configurable:!0});Object.defineProperty(l.prototype,"itemSize",{get:function(){return this._stride},enumerable:!0,configurable:!0});Object.defineProperty(l.prototype,"sizeInBytes",{get:function(){return 4*this._array.length},enumerable:!0,configurable:!0});l.prototype.reset=function(){this.array.length=0};l.prototype.toBuffer=function(){return(new Uint32Array(this._array)).buffer};l.i1616to32=function(l,d){return 65535&
l|d<<16};l.i8888to32=function(l,d,k,a){return l&255|(d&255)<<8|(k&255)<<16|a<<24};l.i8816to32=function(l,d,k){return l&255|(d&255)<<8|k<<16};return l}()})},"esri/views/vectorTiles/renderers/rendererUtils":function(){define(["require","exports"],function(w,v){Object.defineProperty(v,"__esModule",{value:!0});var l=new Uint32Array(1),u=new Uint8Array(l.buffer);v.int32To4Bytes=function(d){l[0]=d|0;return[u[0],u[1],u[2],u[3]]}})},"esri/views/vectorTiles/renderers/CircleRenderer":function(){define("require exports ../../../core/libs/gl-matrix-2/mat4 ../../../core/libs/gl-matrix-2/mat4f32 ../../../core/libs/gl-matrix-2/vec3f32 ../../../core/libs/gl-matrix-2/vec4f32 ../GeometryUtils ./rendererUtils ../../webgl/VertexArrayObject".split(" "),
function(w,v,l,u,d,k,a,n,c){return function(){function b(a){this._viewProjMat=u.mat4f32.create();this._offsetVector=d.vec3f32.create();this._color=k.vec4f32.create();this._strokeColor=k.vec4f32.create();this._initialized=!1;this._programOptions={id:!1};this._programCache=a}b.prototype.dispose=function(){};b.prototype.render=function(b,c,d,h,g,m,k,p,e){if(0!==c.triangleElementCount){this._initialized||this._initialize(b);var f=k.hasDataDrivenRadius?1:k.getPaintValue("circle-radius",d),q=k.hasDataDrivenColor?
[1,1,1,1]:k.getPaintValue("circle-color",d),t=k.hasDataDrivenOpacity?1:k.getPaintValue("circle-opacity",d),x=k.hasDataDrivenStrokeWidth?1:k.getPaintValue("circle-stroke-width",d),u=k.hasDataDrivenStrokeColor?[1,1,1,1]:k.getPaintValue("circle-stroke-color",d),y=k.hasDataDrivenStrokeOpacity?1:k.getPaintValue("circle-stroke-opacity",d),v=k.hasDataDrivenBlur?0:k.getPaintValue("circle-blur",d),t=t*q[3]*e;this._color[0]=t*q[0];this._color[1]=t*q[1];this._color[2]=t*q[2];this._color[3]=t;t=y*u[3]*e;this._strokeColor[0]=
t*u[0];this._strokeColor[1]=t*u[1];this._strokeColor[2]=t*u[2];this._strokeColor[3]=t;e=m.tileTransform.transform;q=k.getPaintValue("circle-translate",d);if(0!==q[0]||0!==q[1])l.mat4.copy(this._viewProjMat,m.tileTransform.transform),e=q[0],q=q[1],y=u=0,y=(1<<m.key.level)/Math.pow(2,d)*(m.coordRange/512),1===k.getPaintValue("circle-translate-anchor",d)?(g*=-a.C_DEG_TO_RAD,d=Math.sin(g),g=Math.cos(g),u=y*(e*g-q*d),y*=e*d+q*g):(u=y*e,y*=q),this._offsetVector[0]=u,this._offsetVector[1]=y,this._offsetVector[2]=
0,l.mat4.translate(this._viewProjMat,this._viewProjMat,this._offsetVector),e=this._viewProjMat;if(d=this._getCircleVAO(b,m))b.bindVAO(d),h=3===h,d=this._programOptions,d.id=h,d=this._programCache.getProgram(5,h?1:0,d),b.bindProgram(d),d.setUniformMatrix4fv("u_transformMatrix",e),d.setUniformMatrix4fv("u_extrudeMatrix",p),d.setUniform2fv("u_normalized_origin",m.tileTransform.displayCoord),d.setUniform1f("u_depth",k.z),d.setUniform1f("u_radius",f),d.setUniform4fv("u_color",this._color),d.setUniform1f("u_blur",
v),d.setUniform1f("u_stroke_width",x),d.setUniform4fv("u_stroke_color",this._strokeColor),d.setUniform1f("u_antialiasingWidth",1.2),h&&(m=n.int32To4Bytes(c.layerID),d.setUniform4f("u_id",m[0],m[1],m[2],m[3])),b.drawElements(4,c.triangleElementCount,5125,12*c.triangleElementStart),b.bindVAO()}};b.prototype._initialize=function(a){if(this._initialized)return!0;this._vertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:16,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,
offset:4,stride:16,normalized:!0,divisor:0},{name:"a_stroke_color",count:4,type:5121,offset:8,stride:16,normalized:!0,divisor:0},{name:"a_data",count:4,type:5121,offset:12,stride:16,normalized:!1,divisor:0}]};return this._initialized=!0};b.prototype._getCircleVAO=function(a,b){if(b.circleVertexArrayObject)return b.circleVertexArrayObject;var d=b.circleVertexBuffer,h=b.circleIndexBuffer;if(!d||!h)return null;b.circleVertexArrayObject=new c(a,this._programCache.getProgramAttributes(5),this._vertexAttributes,
{geometry:d},h);return b.circleVertexArrayObject};return b}()})},"esri/views/vectorTiles/renderers/FadeRecorder":function(){define(["require","exports","../../../core/now"],function(w,v,l){Object.defineProperty(v,"__esModule",{value:!0});(function(){return function(l,d){this.level=l;this.now=d}})();w=function(){return function(l,d,k,a){this.fadeSpeed=l;this.minfadeLevel=d;this.maxfadeLevel=k;this.fadeChange=a}}();v.FadeProperties=w;w=function(){function u(d){void 0===d&&(d=300);this._levelSnapshots=
[];this._duration=d}u.prototype.recordLevel=function(d){var k=l(),a=this._levelSnapshots;0===a.length&&(a.push({level:d,now:0}),a.push({level:d,now:0}));2!==a.length&&a[0].level===d||a.push({level:d,now:k})};u.prototype.needsRedraw=function(){if(0===this._levelSnapshots.length)return!1;for(var d=this._duration,k=this._levelSnapshots,a=k.length,l=k[a-1],c=-1;a>c+1&&k[c+1].now+d<l.now;)c++;for(0>c&&(c=0);c<a;c++)if(k[c].level!==l.level)return!0;return!1};u.prototype.getFadeValues=function(d){void 0===
d&&(d=!1);for(var k=this._duration,a=l(),n=this._levelSnapshots;3<n.length&&n[1].now+k<a;)n.shift();n[1].now+k<a&&(n[0].level=n[1].level);var c=n[0].level,b=n[n.length-1],f=b.level,u=Math.min(c,f),c=Math.max(c,f),n=(b.level-n[1].level)/((b.now-n[1].now)/k);return d?{fadeSpeed:0,minfadeLevel:u,maxfadeLevel:c,fadeChange:0}:{fadeSpeed:n,minfadeLevel:u,maxfadeLevel:c,fadeChange:(a-b.now)/k*n}};return u}();v.FadeRecorder=w})},"esri/views/vectorTiles/renderers/FillRenderer":function(){define("require exports ../../../core/libs/gl-matrix-2/mat3 ../../../core/libs/gl-matrix-2/mat3f32 ../../../core/libs/gl-matrix-2/mat4 ../../../core/libs/gl-matrix-2/mat4f32 ../../../core/libs/gl-matrix-2/vec3f32 ../../../core/libs/gl-matrix-2/vec4f32 ../GeometryUtils ./rendererUtils ../../webgl/VertexArrayObject".split(" "),
function(w,v,l,u,d,k,a,n,c,b,f){var y=1/65536;return function(){function q(b){this._viewProjMat=k.mat4f32.create();this._offsetVector=a.vec3f32.create();this._patternMatrix=u.mat3f32.create();this._color=n.vec4f32.create();this._outlineColor=n.vec4f32.create();this._initialized=!1;this._fillProgramOptions={id:!1,dd:!1,pattern:!1};this._outlineProgramOptions={id:!1,dd:!1};this._programCache=b}q.prototype.dispose=function(){};q.prototype.render=function(a,g,f,k,p,e,r,l,t,q,n){if(0!==g.triangleElementCount){this._initialized||
this._initialize(a);var h=void 0!==r.getPaintValue("fill-pattern",f),m=r.hasDataDrivenColor?[1,1,1,1]:r.getPaintValue("fill-color",f),x=r.hasDataDrivenOpacity?1:r.getPaintValue("fill-opacity",f),u=x*m[3]*n;this._color[0]=u*m[0];this._color[1]=u*m[1];this._color[2]=u*m[2];this._color[3]=u;var m=3===p,v;m&&(v=b.int32To4Bytes(g.layerID));var u=e.tileTransform.transform,A=e.coordRange/512,w=r.getPaintValue("fill-translate",f);if(0!==w[0]||0!==w[1]){d.mat4.copy(this._viewProjMat,e.tileTransform.transform);
var u=w[0],w=w[1],B=0,D=0,A=(1<<e.key.level)/Math.pow(2,f)*A;1===r.getPaintValue("fill-translate-anchor",f)?(B=-c.C_DEG_TO_RAD*k,k=Math.sin(B),D=Math.cos(B),B=A*(u*D-w*k),D=A*(u*k+w*D)):(B=A*u,D=A*w);this._offsetVector[0]=B;this._offsetVector[1]=D;this._offsetVector[2]=0;d.mat4.translate(this._viewProjMat,this._viewProjMat,this._offsetVector);u=this._viewProjMat}this._drawFill(a,g,f,p,e,r,l,u,q,n,m,v);if(r.getPaintValue("fill-antialias",f)&&!h&&0<g.outlineElementCount&&(1===p||3===p)){p=r.hasDataDrivenOutline;
if(r.outlineUsesFillColor){if(1!==this._color[3])return;this._outlineColor[0]=this._color[0];this._outlineColor[1]=this._color[1];this._outlineColor[2]=this._color[2];this._outlineColor[3]=this._color[3]}else f=r.hasDataDrivenOutlineColor?[1,1,1,1]:r.getPaintValue("fill-outline-color",f),n*=x*f[3],this._outlineColor[0]=n*f[0],this._outlineColor[1]=n*f[1],this._outlineColor[2]=n*f[2],this._outlineColor[3]=n;q=.75/q;if(n=this._getOutlineVAO(a,e,p))a.bindVAO(n),n=this._outlineProgramOptions,n.id=m,n.dd=
p,n=this._programCache.getProgram(2,(m?1:0)<<1|(p?1:0),n),a.bindProgram(n),n.setUniformMatrix4fv("u_transformMatrix",u),n.setUniformMatrix4fv("u_extrudeMatrix",t),n.setUniform2fv("u_normalized_origin",e.tileTransform.displayCoord),n.setUniform1f("u_depth",r.z+y),n.setUniform1f("u_outline_width",q),n.setUniform4fv("u_color",this._outlineColor),m&&n.setUniform4f("u_id",v[0],v[1],v[2],v[3]),a.drawElements(4,g.outlineElementCount,5125,12*g.outlineElementStart),a.bindVAO()}}};q.prototype._initialize=function(a){if(this._initialized)return!0;
this._fillVertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:4,normalized:!1,divisor:0}]};this._fillVertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:8,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:4,stride:8,normalized:!0,divisor:0}]};this._outlineVertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:8,normalized:!1,divisor:0},{name:"a_offset",count:2,type:5120,offset:4,stride:8,normalized:!1,divisor:0},
{name:"a_xnormal",count:2,type:5120,offset:6,stride:8,normalized:!1,divisor:0}]};this._outlineVertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:12,normalized:!1,divisor:0},{name:"a_offset",count:2,type:5120,offset:4,stride:12,normalized:!1,divisor:0},{name:"a_xnormal",count:2,type:5120,offset:6,stride:12,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:8,stride:12,normalized:!0,divisor:0}]};return this._initialized=!0};q.prototype._drawFill=function(a,
b,c,d,f,e,k,n,t,q,u,v){var g=e.getPaintValue("fill-pattern",c),h=void 0!==g,r=e.hasDataDrivenOpacity?1:q*e.getPaintValue("fill-opacity",c),m=e.hasDataDrivenColor?[1,1,1,1]:e.getPaintValue("fill-color",c);q*=r*m[3];this._color[0]=q*m[0];this._color[1]=q*m[1];this._color[2]=q*m[2];this._color[3]=q;m=e.hasDataDrivenFill;q=h||1>q||m;if(!q||0!==d)if(q||1!==d)if(d=this._getFillVAO(a,f,m)){a.bindVAO(d);d=this._fillProgramOptions;d.id=u;d.dd=m;d.pattern=h;d=this._programCache.getProgram(1,(u?1:0)<<2|(m?1:
0)<<1|(h?1:0),d);a.bindProgram(d);if(h){g=k.getMosaicItemPosition(g,!0);if(!g){a.bindVAO();a.bindProgram();return}c=f.coordRange/512/Math.pow(2,Math.round(c)-f.key.level)/t;l.mat3.identity(this._patternMatrix);t=1/(g.size[1]*c);this._patternMatrix[0]=1/(g.size[0]*c);this._patternMatrix[4]=t;k.bind(a,9729,g.page,5);d.setUniformMatrix3fv("u_pattern_matrix",this._patternMatrix);d.setUniform2f("u_pattern_tl",g.tl[0],g.tl[1]);d.setUniform2f("u_pattern_br",g.br[0],g.br[1]);d.setUniform1i("u_texture",5)}d.setUniformMatrix4fv("u_transformMatrix",
n);d.setUniform2fv("u_normalized_origin",f.tileTransform.displayCoord);d.setUniform1f("u_depth",e.z+y);d.setUniform4fv("u_color",this._color);u&&d.setUniform4f("u_id",v[0],v[1],v[2],v[3]);a.drawElements(4,b.triangleElementCount,5125,12*b.triangleElementStart);a.bindVAO()}};q.prototype._getFillVAO=function(a,b,c){if(c){if(b.fillDDVertexArrayObject)return b.fillDDVertexArrayObject;c=b.fillDDVertexBuffer;var d=b.fillIndexBuffer;if(!c||!d)return null;b.fillDDVertexArrayObject=new f(a,this._programCache.getProgramAttributes(1),
this._fillVertexAttributesDD,{geometry:c},d);return b.fillDDVertexArrayObject}if(b.fillVertexArrayObject)return b.fillVertexArrayObject;c=b.fillVertexBuffer;d=b.fillIndexBuffer;if(!c||!d)return null;b.fillVertexArrayObject=new f(a,this._programCache.getProgramAttributes(1),this._fillVertexAttributes,{geometry:c},d);return b.fillVertexArrayObject};q.prototype._getOutlineVAO=function(a,b,c){if(c){if(b.outlineDDVertexArrayObject)return b.outlineDDVertexArrayObject;c=b.outlineDDVertexBuffer;var d=b.outlineIndexBuffer;
if(!c||!d)return null;b.outlineDDVertexArrayObject=new f(a,this._programCache.getProgramAttributes(2),this._outlineVertexAttributesDD,{geometry:c},d);return b.outlineDDVertexArrayObject}if(b.outlineVertexArrayObject)return b.outlineVertexArrayObject;c=b.outlineVertexBuffer;d=b.outlineIndexBuffer;if(!c||!d)return null;b.outlineVertexArrayObject=new f(a,this._programCache.getProgramAttributes(2),this._outlineVertexAttributes,{geometry:c},d);return b.outlineVertexArrayObject};return q}()})},"esri/views/vectorTiles/renderers/LineRenderer":function(){define("require exports ../../../core/libs/gl-matrix-2/mat4 ../../../core/libs/gl-matrix-2/mat4f32 ../../../core/libs/gl-matrix-2/vec2f32 ../../../core/libs/gl-matrix-2/vec3f32 ../../../core/libs/gl-matrix-2/vec4f32 ../GeometryUtils ./rendererUtils ../../webgl/VertexArrayObject".split(" "),
function(w,v,l,u,d,k,a,n,c,b){return function(){function f(b){this._initialized=!1;this._viewProjMat=u.mat4f32.create();this._offsetVector=k.vec3f32.create();this._color=a.vec4f32.create();this._dashArray=d.vec2f32.create();this._programOptions={id:!1,dd:!1,pattern:!1};this._programCache=b}f.prototype.dispose=function(){};f.prototype.render=function(a,b,d,g,f,k,p,e,r,u,t){if(0!==b.triangleElementCount){this._initialized||this._initialize(a);var h=k.tileTransform.transform,m=k.coordRange/512,q=p.getPaintValue("line-translate",
d);if(0!==q[0]||0!==q[1]){l.mat4.copy(this._viewProjMat,k.tileTransform.transform);var h=q[0],q=q[1],x=0,v=0,v=(1<<k.key.level)/Math.pow(2,d)*m;f=f.rotation;if(1===p.getPaintValue("line-translate-anchor",d)){x=-n.C_DEG_TO_RAD*f;f=Math.sin(x);var y=Math.cos(x),x=v*(h*y-q*f),v=v*(h*f+q*y)}else x=v*h,v*=q;this._offsetVector[0]=x;this._offsetVector[1]=v;this._offsetVector[2]=0;l.mat4.translate(this._viewProjMat,this._viewProjMat,this._offsetVector);h=this._viewProjMat}q=p.getPaintValue("line-pattern",
d);v=void 0!==q;u=1/u;f=p.getPaintValue("line-blur",d);var y=p.hasDataDrivenColor?[1,1,1,1]:p.getPaintValue("line-color",d),A=p.hasDataDrivenOpacity?1:p.getPaintValue("line-opacity",d),x=p.hasDataDrivenWidth?1:p.getPaintValue("line-width",d);t*=A*y[3];this._color[0]=t*y[0];this._color[1]=t*y[1];this._color[2]=t*y[2];this._color[3]=t;t=p.hasDataDrivenLine;g=3===g;var w;g&&(w=c.int32To4Bytes(b.layerID));if(y=this._getLineVAO(a,k,t)){a.bindVAO(y);y=this._programOptions;y.id=g;y.dd=t;y.pattern=v;t=this._programCache.getProgram(3,
(g?1:0)<<2|(t?1:0)<<1|(v?1:0),y);a.bindProgram(t);t.setUniformMatrix4fv("u_transformMatrix",h);t.setUniformMatrix4fv("u_extrudeMatrix",r);t.setUniform2fv("u_normalized_origin",k.tileTransform.displayCoord);t.setUniform1f("u_depth",p.z);t.setUniform1f("u_blur",f);t.setUniform1f("u_antialiasing",u);t.setUniform4fv("u_color",this._color);t.setUniform1f("u_width",x);g&&t.setUniform4f("u_id",w[0],w[1],w[2],w[3]);if(v){if(d=e.getMosaicItemPosition(q,!0))e.bind(a,9729,d.page,5),t.setUniform2f("u_pattern_tl",
d.tl[0],d.br[1]),t.setUniform2f("u_pattern_br",d.br[0],d.tl[1]),t.setUniform2f("u_spriteSize",m*d.size[0],d.size[1]),t.setUniform1i("u_texture",5)}else e=p.getPaintValue("line-dasharray",d),2>e.length&&(e=[1,-1]),this._dashArray[0]=m*e[0],this._dashArray[1]=m*e[1],t.setUniform2fv("u_dasharray",this._dashArray);a.drawElements(4,b.triangleElementCount,5125,12*b.triangleElementStart);a.bindVAO()}}};f.prototype._initialize=function(a){if(this._initialized)return!0;this._vertexAttributes={geometry:[{name:"a_pos",
count:2,type:5122,offset:0,stride:12,normalized:!1,divisor:0},{name:"a_offsetAndNormal",count:4,type:5120,offset:4,stride:12,normalized:!1,divisor:0},{name:"a_accumulatedDistance",count:2,type:5123,offset:8,stride:12,normalized:!1,divisor:0}]};this._vertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:20,normalized:!1,divisor:0},{name:"a_offsetAndNormal",count:4,type:5120,offset:4,stride:20,normalized:!1,divisor:0},{name:"a_accumulatedDistance",count:2,type:5122,offset:8,
stride:20,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:12,stride:20,normalized:!0,divisor:0},{name:"a_width",count:1,type:5126,offset:16,stride:20,normalized:!1,divisor:0}]};return this._initialized=!0};f.prototype._getLineVAO=function(a,c,d){if(d){if(c.lineDDVertexArrayObject)return c.lineDDVertexArrayObject;d=c.lineDDVertexBuffer;var g=c.lineIndexBuffer;if(!d||!g)return null;c.lineDDVertexArrayObject=new b(a,this._programCache.getProgramAttributes(3),this._vertexAttributesDD,
{geometry:d},g);return c.lineDDVertexArrayObject}if(c.lineVertexArrayObject)return c.lineVertexArrayObject;d=c.lineVertexBuffer;g=c.lineIndexBuffer;if(!d||!g)return null;c.lineVertexArrayObject=new b(a,this._programCache.getProgramAttributes(3),this._vertexAttributes,{geometry:d},g);return c.lineVertexArrayObject};return f}()})},"esri/views/vectorTiles/renderers/SymbolRenderer":function(){define(["require","exports","./IconRenderer","./SDFRenderer"],function(w,v,l,u){return function(){function d(d){this._iconRenderer=
new l(d);this._sdfRenderer=new u(d)}d.prototype.dispose=function(){this._iconRenderer&&(this._iconRenderer.dispose(),this._iconRenderer=null);this._sdfRenderer&&(this._sdfRenderer.dispose(),this._sdfRenderer=null)};d.prototype.render=function(d,a,l,c,b,f,u,q,h,g,m,x,p,e){a.hasData()&&(0<a.markerPerPageElementsMap.size&&this._iconRenderer.render(d,a,l,c,b,f,u,q,h,m,x,e),0<a.glyphPerPageElementsMap.size&&this._sdfRenderer.render(d,a,l,c,b,f,u,q,g,m,x,p,e))};return d}()})},"esri/views/vectorTiles/renderers/IconRenderer":function(){define("require exports ../../../core/libs/gl-matrix-2/mat4 ../../../core/libs/gl-matrix-2/mat4f32 ../../../core/libs/gl-matrix-2/vec2f32 ../../../core/libs/gl-matrix-2/vec3f32 ../../../core/libs/gl-matrix-2/vec4f32 ../GeometryUtils ./rendererUtils ../../webgl/VertexArrayObject".split(" "),
function(w,v,l,u,d,k,a,n,c,b){return function(){function f(b){this._viewProjMat=u.mat4f32.create();this._offsetVector=k.vec3f32.create();this._spritesTextureSize=d.vec2f32.create();this._color=a.vec4f32.create();this._initialized=!1;this._programOptions={id:!1,dd:!1,sdf:!1};this._programCache=b}f.prototype.dispose=function(){};f.prototype.render=function(a,b,d,g,f,k,p,e,r,u,t,v){var h=this;this._initialized||this._initialize(a);var m=e.hasDataDrivenIconSize?1:e.getLayoutValue("icon-size",d),q=e.hasDataDrivenIconColor?
[1,1,1,1]:e.getPaintValue("icon-color",d),x=e.hasDataDrivenIconOpacity?1:e.getPaintValue("icon-opacity",d);v*=q[3]*x;this._color[0]=v*q[0];this._color[1]=v*q[1];this._color[2]=v*q[2];this._color[3]=v;q=e.getLayoutValue("icon-rotation-alignment",d);2===q&&(q=1===e.getLayoutValue("symbol-placement",d)?0:1);var y=0===q;v=b.isSDF;x=e.hasDataDrivenIcon;g=3===g;var q=n.degToByte(f),w=p.tileTransform.transform,A=e.getPaintValue("icon-translate",d);if(0!==A[0]||0!==A[1]){l.mat4.copy(this._viewProjMat,p.tileTransform.transform);
var w=A[0],A=A[1],B=0,E=0,E=(1<<p.key.level)/Math.pow(2,d)*(p.coordRange/512);if(1===e.getPaintValue("icon-translate-anchor",d)){B=-n.C_DEG_TO_RAD*f;f=Math.sin(B);var J=Math.cos(B),B=E*(w*J-A*f),E=E*(w*f+A*J)}else B=E*w,E*=A;this._offsetVector[0]=B;this._offsetVector[1]=E;this._offsetVector[2]=0;l.mat4.translate(this._viewProjMat,this._viewProjMat,this._offsetVector);w=this._viewProjMat}u=y?u:t;if(t=this._getIconVAO(a,p,x)){a.bindVAO(t);t=this._programOptions;t.id=g;t.dd=x;t.sdf=v;var z=this._programCache.getProgram(4,
(g?1:0)<<2|(x?1:0)<<1|(v?1:0),t);a.bindProgram(z);v&&(t=e.getPaintValue("icon-halo-color",d),v=e.getPaintValue("icon-halo-width",d),z.setUniform4f("u_outlineColor",t[0],t[1],t[2],t[3]),z.setUniform1f("u_outlineSize",v));z.setUniformMatrix4fv("u_transformMatrix",w);z.setUniformMatrix4fv("u_extrudeMatrix",u);z.setUniform2fv("u_normalized_origin",p.tileTransform.displayCoord);z.setUniform1f("u_depth",e.z);z.setUniform1f("u_mapRotation",q);z.setUniform1f("u_keepUpright",0);z.setUniform1f("u_level",10*
d);z.setUniform1f("u_fadeSpeed",10*k.fadeSpeed);z.setUniform1f("u_minfadeLevel",10*k.minfadeLevel);z.setUniform1f("u_maxfadeLevel",10*k.maxfadeLevel);z.setUniform1f("u_fadeChange",10*(d+k.fadeChange));z.setUniform1i("u_texture",5);z.setUniform1f("u_size",m);z.setUniform4fv("u_color",this._color);g&&(d=c.int32To4Bytes(b.layerID),z.setUniform4f("u_id",d[0],d[1],d[2],d[3]));b.markerPerPageElementsMap.forEach(function(b,e){h._spritesTextureSize[0]=r.getWidth(e)/4;h._spritesTextureSize[1]=r.getHeight(e)/
4;z.setUniform2fv("u_mosaicSize",h._spritesTextureSize);r.bind(a,9729,e,5);a.drawElements(4,b[1],5125,12*b[0])});a.bindVAO()}};f.prototype._initialize=function(a){if(this._initialized)return!0;this._vertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:16,normalized:!1,divisor:0},{name:"a_vertexOffset",count:2,type:5122,offset:4,stride:16,normalized:!1,divisor:0},{name:"a_tex",count:4,type:5121,offset:8,stride:16,normalized:!1,divisor:0},{name:"a_levelInfo",count:4,type:5121,
offset:12,stride:16,normalized:!1,divisor:0}]};this._vertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:24,normalized:!1,divisor:0},{name:"a_vertexOffset",count:2,type:5122,offset:4,stride:24,normalized:!1,divisor:0},{name:"a_tex",count:4,type:5121,offset:8,stride:24,normalized:!1,divisor:0},{name:"a_levelInfo",count:4,type:5121,offset:12,stride:24,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:16,stride:24,normalized:!0,divisor:0},{name:"a_size",count:1,
type:5126,offset:20,stride:24,normalized:!1,divisor:0}]};return this._initialized=!0};f.prototype._getIconVAO=function(a,c,d){if(d){if(c.iconDDVertexArrayObject)return c.iconDDVertexArrayObject;d=c.iconDDVertexBuffer;var g=c.iconIndexBuffer;if(!d||!g)return null;c.iconDDVertexArrayObject=new b(a,this._programCache.getProgramAttributes(4),this._vertexAttributesDD,{geometry:d},g);return c.iconDDVertexArrayObject}if(c.iconVertexArrayObject)return c.iconVertexArrayObject;d=c.iconVertexBuffer;g=c.iconIndexBuffer;
if(!d||!g)return null;c.iconVertexArrayObject=new b(a,this._programCache.getProgramAttributes(4),this._vertexAttributes,{geometry:d},g);return c.iconVertexArrayObject};return f}()})},"esri/views/vectorTiles/renderers/SDFRenderer":function(){define("require exports ../../../core/has ../../../core/libs/gl-matrix-2/mat4 ../../../core/libs/gl-matrix-2/mat4f32 ../../../core/libs/gl-matrix-2/vec2f32 ../../../core/libs/gl-matrix-2/vec3f32 ../../../core/libs/gl-matrix-2/vec4f32 ../GeometryUtils ./rendererUtils ../../webgl/VertexArrayObject".split(" "),
function(w,v,l,u,d,k,a,n,c,b,f){var y=1/65536;return function(){function q(b){this._viewProjMat=d.mat4f32.create();this._offsetVector=a.vec3f32.create();this._extrudeMat=d.mat4f32.create();this._scaleVec=a.vec3f32.create();this._haloColor=n.vec4f32.create();this._sdfColor=n.vec4f32.create();this._initialized=!1;this._programOptions={id:!1,dd:!1};this._programCache=b}q.prototype.dispose=function(){};q.prototype.render=function(a,d,f,n,p,e,r,q,t,v,w,H,I){var g=this;if(!l("esri-vector-tiles-avoid-text")){this._initialized||
this._initialize(a);var h=c.degToByte(p),m=q.getLayoutValue("text-rotation-alignment",f);2===m&&(m=1===q.getLayoutValue("symbol-placement",f)?0:1);var x=0===m,m=q.getLayoutValue("text-keep-upright",f)&&x;n=3===n;H=.8*3/H;var A=q.hasDataDrivenTextSize?1:q.getLayoutValue("text-size",f),B=q.hasDataDrivenTextColor?[1,1,1,1]:q.getPaintValue("text-color",f),D=q.hasDataDrivenTextOpacity?1:q.getPaintValue("text-opacity",f),z=B[3]*D*I;this._sdfColor[0]=z*B[0];this._sdfColor[1]=z*B[1];this._sdfColor[2]=z*B[2];
this._sdfColor[3]=z;this._glyphTextureSize||(this._glyphTextureSize=k.vec2f32.fromValues(t.width/4,t.height/4));B=r.tileTransform.transform;z=q.getPaintValue("text-translate",f);if(0!==z[0]||0!==z[1]){u.mat4.copy(this._viewProjMat,r.tileTransform.transform);var B=z[0],z=z[1],G=0,F=0,F=(1<<r.key.level)/Math.pow(2,f)*(r.coordRange/512);if(1===q.getPaintValue("text-translate-anchor",f)){G=-c.C_DEG_TO_RAD*p;p=Math.sin(G);var K=Math.cos(G),G=F*(B*K-z*p),F=F*(B*p+z*K)}else G=F*B,F*=z;this._offsetVector[0]=
G;this._offsetVector[1]=F;this._offsetVector[2]=0;u.mat4.translate(this._viewProjMat,this._viewProjMat,this._offsetVector);B=this._viewProjMat}x?u.mat4.copy(this._extrudeMat,v):u.mat4.copy(this._extrudeMat,w);this._scaleVec[0]=1/24;this._scaleVec[1]=1/24;this._scaleVec[2]=1;u.mat4.scale(this._extrudeMat,this._extrudeMat,this._scaleVec);v=q.hasDataDrivenText;if(w=this._getSDFVAO(a,r,v)){a.bindVAO(w);w=this._programOptions;w.id=n;w.dd=v;var C=this._programCache.getProgram(6,(n?1:0)<<1|(v?1:0),w);a.bindProgram(C);
C.setUniformMatrix4fv("u_transformMatrix",B);C.setUniformMatrix4fv("u_extrudeMatrix",this._extrudeMat);C.setUniform2fv("u_normalized_origin",r.tileTransform.displayCoord);C.setUniform1f("u_depth",q.z+y);C.setUniform2fv("u_mosaicSize",this._glyphTextureSize);C.setUniform1f("u_mapRotation",h);C.setUniform1f("u_keepUpright",m?1:0);C.setUniform1f("u_level",10*f);C.setUniform1f("u_fadeSpeed",10*e.fadeSpeed);C.setUniform1f("u_minfadeLevel",10*e.minfadeLevel);C.setUniform1f("u_maxfadeLevel",10*e.maxfadeLevel);
C.setUniform1f("u_fadeChange",10*(f+e.fadeChange));C.setUniform1i("u_texture",6);C.setUniform1f("u_size",A);C.setUniform1f("u_antialiasingWidth",H);n&&(e=b.int32To4Bytes(d.layerID),C.setUniform4f("u_id",e[0],e[1],e[2],e[3]));d.glyphPerPageElementsMap.forEach(function(b,c){g._renderGlyphRange(a,b,c,q,t,C,f,D*I,3)});a.bindVAO()}}};q.prototype._renderGlyphRange=function(a,b,c,d,f,e,k,l,n){f.bind(a,9729,c,6);f=d.getPaintValue("text-halo-color",k);c=d.getPaintValue("text-halo-width",k);0<f[3]&&0<c&&(l*=
f[3],this._haloColor[0]=l*f[0],this._haloColor[1]=l*f[1],this._haloColor[2]=l*f[2],this._haloColor[3]=l,d=d.getPaintValue("text-halo-blur",k)*n,n*=c,e.setUniform4fv("u_color",this._haloColor),e.setUniform1f("u_halo",1),e.setUniform1f("u_edgeDistance",n),e.setUniform1f("u_edgeBlur",d),a.drawElements(4,b[1],5125,12*b[0]));0<this._sdfColor[3]&&(e.setUniform4fv("u_color",this._sdfColor),e.setUniform1f("u_halo",0),e.setUniform1f("u_edgeDistance",0),e.setUniform1f("u_edgeBlur",0),a.drawElements(4,b[1],
5125,12*b[0]))};q.prototype._initialize=function(a){if(this._initialized)return!0;this._vertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:16,normalized:!1,divisor:0},{name:"a_vertexOffset",count:2,type:5122,offset:4,stride:16,normalized:!1,divisor:0},{name:"a_tex",count:4,type:5121,offset:8,stride:16,normalized:!1,divisor:0},{name:"a_levelInfo",count:4,type:5121,offset:12,stride:16,normalized:!1,divisor:0}]};this._vertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,
offset:0,stride:24,normalized:!1,divisor:0},{name:"a_vertexOffset",count:2,type:5122,offset:4,stride:24,normalized:!1,divisor:0},{name:"a_tex",count:4,type:5121,offset:8,stride:24,normalized:!1,divisor:0},{name:"a_levelInfo",count:4,type:5121,offset:12,stride:24,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:16,stride:24,normalized:!0,divisor:0},{name:"a_size",count:1,type:5126,offset:20,stride:24,normalized:!1,divisor:0}]};return this._initialized=!0};q.prototype._getSDFVAO=function(a,
b,c){if(c){if(b.textDDVertexArrayObject)return b.textDDVertexArrayObject;c=b.textDDVertexBuffer;var d=b.textIndexBuffer;if(!c||!d)return null;b.textDDVertexArrayObject=new f(a,this._programCache.getProgramAttributes(6),this._vertexAttributesDD,{geometry:c},d);return b.textDDVertexArrayObject}if(b.textVertexArrayObject)return b.textVertexArrayObject;c=b.textVertexBuffer;d=b.textIndexBuffer;if(!c||!d)return null;b.textVertexArrayObject=new f(a,this._programCache.getProgramAttributes(6),this._vertexAttributes,
{geometry:c},d);return b.textVertexArrayObject};return q}()})},"esri/views/vectorTiles/renderers/TileInfoRenderer":function(){define("require exports ../../../core/libs/gl-matrix-2/vec4f32 ../GeometryUtils ../../webgl/BufferObject ../../webgl/Texture ../../webgl/VertexArrayObject".split(" "),function(w,v,l,u,d,k,a){return function(){function n(a){this._initialized=!1;this._color=l.vec4f32.fromValues(1,0,0,1);this._maxWidth=0;this._programOptions={id:!1,pattern:!1};this._programCache=a}n.prototype.dispose=
function(){this._outlineVertexArrayObject&&(this._outlineVertexArrayObject.dispose(),this._outlineVertexArrayObject=null);this._tileInfoVertexArrayObject&&(this._tileInfoVertexArrayObject.dispose(),this._tileInfoVertexArrayObject=null)};n.prototype.render=function(a,b){this._initialized||this._initialize(a);var c=this._programCache.getProgram(0,0,this._programOptions);if(c&&(a.bindVAO(this._outlineVertexArrayObject),a.bindProgram(c),c.setUniformMatrix4fv("u_transformMatrix",b.tileTransform.transform),
c.setUniform2fv("u_normalized_origin",b.tileTransform.displayCoord),c.setUniform1f("u_coord_range",b.coordRange),c.setUniform1f("u_depth",0),c.setUniform4fv("u_color",this._color),a.drawArrays(3,0,4),a.bindVAO(),c=this._getTexture(a,b))){var d=this._programCache.getProgram(7,0,null);d&&(a.bindVAO(this._tileInfoVertexArrayObject),a.bindProgram(d),a.bindTexture(c,0),d.setUniformMatrix4fv("u_transformMatrix",b.tileTransform.transform),d.setUniform2fv("u_normalized_origin",b.tileTransform.displayCoord),
d.setUniform1f("u_depth",0),d.setUniform1f("u_coord_ratio",b.coordRange/512),d.setUniform2f("u_delta",8,8),d.setUniform2f("u_dimensions",c.descriptor.width,c.descriptor.height),a.drawArrays(5,0,4),a.bindVAO())}};n.prototype._initialize=function(c){if(this._initialized)return!0;var b={geometry:[{name:"a_pos",count:2,type:5120,offset:0,stride:2,normalized:!1,divisor:0}]},f=new Int8Array([0,0,1,0,1,1,0,1]),f=d.createVertex(c,35044,f),f=new a(c,this._programCache.getProgramAttributes(0),b,{geometry:f}),
k=new Int8Array([0,0,1,0,0,1,1,1]),k=d.createVertex(c,35044,k);c=new a(c,this._programCache.getProgramAttributes(7),b,{geometry:k});this._outlineVertexArrayObject=f;this._tileInfoVertexArrayObject=c;return this._initialized=!0};n.prototype._getTexture=function(a,b){if(b.texture)return b.texture;this._canvas||(this._canvas=document.createElement("canvas"),this._canvas.setAttribute("id","canvas2d"),this._canvas.setAttribute("width","256"),this._canvas.setAttribute("height","32"),this._canvas.setAttribute("style",
"display:none"));var c=b.key.id,d=this._canvas.getContext("2d");d.font="24px sans-serif";d.textAlign="left";d.textBaseline="middle";var l=d.measureText(c),l=Math.pow(2,Math.ceil(u.log2(l.width+2)));l>this._maxWidth&&(this._maxWidth=l);d.clearRect(0,0,this._maxWidth,32);d.fillStyle="blue";d.fillStyle="red";d.fillText(c,0,16);b.texture=new k(a,{target:3553,pixelFormat:6408,dataType:5121,samplingMode:9728},this._canvas);return b.texture};return n}()})},"esri/views/vectorTiles/renderers/shaders/ProgramCache":function(){define(["require",
"exports","./Programs","../../../webgl/programUtils"],function(w,v,l,u){Object.defineProperty(v,"__esModule",{value:!0});w=function(){function d(){this._cache=Array(8);for(var d=0;8>d;d++)this._cache[d]={}}d.prototype.dispose=function(){this._programRepo&&(this._programRepo.dispose(),this._programRepo=null)};d.prototype.getProgram=function(d,a,l){var c=this._cache[d];c[a]||(d=this._programRepo.getProgram(this._getProgramTemplate(d),l),c[a]=d);return c[a]};d.prototype.getProgramAttributes=function(d){switch(d){case 0:return l.background.attributes;
case 5:return l.circle.attributes;case 1:return l.fill.attributes;case 4:return l.icon.attributes;case 3:return l.line.attributes;case 2:return l.outline.attributes;case 6:return l.text.attributes;case 7:return l.tileInfo.attributes}};d.prototype.initialize=function(d){this._programRepo||(this._programRepo=new u.ProgramCache(d))};d.prototype._getProgramTemplate=function(d){switch(d){case 0:return l.background;case 5:return l.circle;case 1:return l.fill;case 4:return l.icon;case 3:return l.line;case 2:return l.outline;
case 6:return l.text;case 7:return l.tileInfo}};return d}();v.default=w})},"esri/views/vectorTiles/renderers/shaders/Programs":function(){define(["require","exports","./sources/resolver","../../../webgl/programUtils"],function(w,v,l,u){Object.defineProperty(v,"__esModule",{value:!0});v.background={name:"background",shaders:function(a){return{vertexShader:u.glslifyDefineMap({ID:a.id,PATTERN:a.pattern})+l.resolveIncludes("background/background.vert"),fragmentShader:u.glslifyDefineMap({ID:a.id,PATTERN:a.pattern})+
l.resolveIncludes("background/background.frag")}},attributes:{a_pos:0}};v.circle={name:"circle",shaders:function(a){return{vertexShader:u.glslifyDefineMap({ID:a.id})+l.resolveIncludes("circle/circle.vert"),fragmentShader:u.glslifyDefineMap({ID:a.id})+l.resolveIncludes("circle/circle.frag")}},attributes:{a_pos:0,a_color:1,a_stroke_color:2,a_data:3}};var d=function(a){return u.glslifyDefineMap({ID:a.id,DD:a.dd,PATTERN:a.pattern})};v.fill={name:"fill",shaders:function(a){return{vertexShader:d(a)+l.resolveIncludes("fill/fill.vert"),
fragmentShader:d(a)+l.resolveIncludes("fill/fill.frag")}},attributes:{a_pos:0,a_color:1}};v.outline={name:"outline",shaders:function(a){return{vertexShader:u.glslifyDefineMap({ID:a.id,DD:a.dd})+l.resolveIncludes("outline/outline.vert"),fragmentShader:u.glslifyDefineMap({ID:a.id,DD:a.dd})+l.resolveIncludes("outline/outline.frag")}},attributes:{a_pos:0,a_offset:1,a_xnormal:2,a_color:3}};v.icon={name:"icon",shaders:function(a){return{vertexShader:u.glslifyDefineMap({ID:a.id,DD:a.dd,SDF:a.sdf})+l.resolveIncludes("icon/icon.vert"),
fragmentShader:u.glslifyDefineMap({ID:a.id,DD:a.dd,SDF:a.sdf})+l.resolveIncludes("icon/icon.frag")}},attributes:{a_pos:0,a_vertexOffset:1,a_tex:2,a_levelInfo:3,a_color:4,a_size:5}};var k=function(a){return u.glslifyDefineMap({ID:a.id,DD:a.dd,PATTERN:a.pattern})};v.line={name:"line",shaders:function(a){return{vertexShader:k(a)+l.resolveIncludes("line/line.vert"),fragmentShader:k(a)+l.resolveIncludes("line/line.frag")}},attributes:{a_pos:0,a_offsetAndNormal:1,a_accumulatedDistance:2,a_color:3,a_width:4}};
v.text={name:"text",shaders:function(a){return{vertexShader:u.glslifyDefineMap({ID:a.id,DD:a.dd})+l.resolveIncludes("text/text.vert"),fragmentShader:u.glslifyDefineMap({ID:a.id,DD:a.dd})+l.resolveIncludes("text/text.frag")}},attributes:{a_pos:0,a_vertexOffset:1,a_tex:2,a_levelInfo:3,a_color:4,a_size:5}};v.tileInfo={name:"tileInfo",shaders:{vertexShader:l.resolveIncludes("tileInfo/tileInfo.vert"),fragmentShader:l.resolveIncludes("tileInfo/tileInfo.frag")},attributes:{a_pos:0}}})},"esri/views/vectorTiles/renderers/shaders/sources/resolver":function(){define(["require",
"exports","./shaderRepository","../../../../webgl/ShaderCompiler"],function(w,v,l,u){Object.defineProperty(v,"__esModule",{value:!0});var d=new u(function(d){var a=l;d.split("/").forEach(function(d){a&&(a=a[d])});return a});v.resolveIncludes=function(k){return d.resolveIncludes(k)}})},"esri/views/vectorTiles/renderers/shaders/sources/shaderRepository":function(){define(["require","exports"],function(w,v){return{background:{"background.frag":"#ifdef PATTERN\r\nuniform lowp float u_opacity;\r\nuniform mediump vec2 u_pattern_tl;\r\nuniform mediump vec2 u_pattern_br;\r\nuniform sampler2D u_texture;\r\n\r\nvarying mediump vec2 v_tileTextureCoord;\r\n#else\r\nuniform lowp vec4 u_color;\r\n#endif // PATTERN\r\n\r\n#ifdef ID\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\nvoid main() {\r\n#ifdef PATTERN\r\n  // normalize the calculated texture coordinate such that it fits in the range of 0 to 1.\r\n  mediump vec2 normalizedTextureCoord \x3d mod(v_tileTextureCoord, 1.0);\r\n\r\n  // interpolate the image coordinate between the top-left and the bottom right to get the actual position to sample.\r\n  // after normalizing the position, we get a value ranging between 0 and 1 which refers to the entire texture, however\r\n  // we need to only sample from area that has our sprite in the mosaic.\r\n  mediump vec2 samplePos \x3d mix(u_pattern_tl, u_pattern_br, normalizedTextureCoord);\r\n\r\n  // sample the sprite mosaic\r\n  lowp vec4 color \x3d texture2D(u_texture, samplePos);\r\n  gl_FragColor \x3d u_opacity * color;\r\n#else\r\n  gl_FragColor \x3d u_color;\r\n#endif // PATTERN\r\n\r\n#ifdef ID\r\n  if (gl_FragColor.a \x3c 1.0 / 255.0) {\r\n    discard;\r\n  }\r\n  gl_FragColor \x3d v_id;\r\n#endif // ID\r\n}\r\n",
"background.vert":"precision mediump float;\r\n\r\nattribute vec2 a_pos;\r\n\r\n#ifdef ID\r\nuniform mediump vec4 u_id;\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\nuniform highp mat4 u_transformMatrix;\r\nuniform mediump vec2 u_normalized_origin;\r\nuniform mediump float u_coord_range;\r\nuniform mediump float u_depth;\r\n\r\n#ifdef PATTERN\r\nuniform mediump mat3 u_pattern_matrix; // can we use medium precision?\r\nvarying mediump vec2 v_tileTextureCoord;\r\n#endif // PATTERN\r\n\r\nvoid main() {\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(u_coord_range * a_pos, 0.0, 1.0);\r\n\r\n#ifdef PATTERN\r\n  // calculate the texture coordinates of the current vertex. It will of course get interpolated.\r\n  // The pattern matrix is a 3x3 scale matrix which 'tiles' the texture inside the tile, translating from tile coordinates\r\n  v_tileTextureCoord \x3d (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\r\n#endif // PATTERN\r\n\r\n#ifdef ID\r\n  v_id \x3d u_id / 255.0;\r\n#endif // ID\r\n}\r\n"},
circle:{"circle.frag":"precision lowp float;\r\n\r\nvarying lowp vec4 v_color;\r\nvarying lowp vec4 v_stroke_color;\r\nvarying mediump float v_blur;\r\nvarying mediump float v_stroke_width;\r\nvarying mediump float v_radius;\r\nvarying mediump vec2 v_offset;\r\n\r\n#ifdef ID\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\nvoid main()\r\n{\r\n  mediump float dist \x3d length(v_offset);\r\n\r\n  mediump float alpha \x3d smoothstep(0.0, -v_blur, dist - 1.0);\r\n\r\n  lowp float color_mix_ratio \x3d v_stroke_width \x3c 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\r\n\r\n  gl_FragColor \x3d alpha * mix(v_color, v_stroke_color, color_mix_ratio);\r\n\r\n#ifdef ID\r\n  if (gl_FragColor.a \x3c 1.0 / 255.0) {\r\n    discard;\r\n  }\r\n  gl_FragColor \x3d v_id;\r\n#endif // ID\r\n}\r\n",
"circle.vert":"precision mediump float;\r\n\r\nattribute vec2 a_pos;\r\nattribute vec4 a_color;\r\nattribute vec4 a_stroke_color;\r\nattribute vec4 a_data;\r\n\r\nconst float sizePrecision \x3d 0.25; // 1/4\r\nconst float blurPrecision \x3d 0.03125; // 1/32\r\n\r\nvarying lowp vec4 v_color;\r\nvarying lowp vec4 v_stroke_color;\r\nvarying mediump float v_blur;\r\nvarying mediump float v_stroke_width;\r\nvarying mediump float v_radius;\r\nvarying mediump vec2 v_offset;\r\n\r\n#ifdef ID\r\nuniform mediump vec4 u_id;\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\r\n// relative to the tile's upper left corner\r\n// the extrusion vector.\r\nuniform highp mat4 u_transformMatrix;\r\n\r\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\r\nuniform highp mat4 u_extrudeMatrix;\r\n\r\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\r\nuniform highp vec2 u_normalized_origin;\r\n\r\n// the z of the layer. Given by the order of the layers in the style\r\nuniform mediump float u_depth;\r\n\r\n// the opacity of the layer given by the painter\r\nuniform mediump float u_radius;\r\nuniform lowp vec4 u_color;\r\nuniform mediump float u_blur;\r\nuniform mediump float u_stroke_width;\r\nuniform lowp vec4 u_stroke_color;\r\n\r\nuniform mediump float u_antialiasingWidth; // antialiasing (factors in the pixel_ratio for high res devices)\r\n\r\nvoid main()\r\n{\r\n  v_color \x3d a_color * u_color;\r\n  v_stroke_color \x3d a_stroke_color * u_stroke_color;\r\n  v_stroke_width \x3d a_data[1] * sizePrecision * u_stroke_width;\r\n  v_radius \x3d a_data[2] * u_radius;\r\n  v_blur \x3d max(a_data[0] * blurPrecision + u_blur, u_antialiasingWidth / (v_radius + v_stroke_width));\r\n\r\n  mediump vec2 offset \x3d vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\r\n  v_offset \x3d offset;\r\n\r\n#ifdef ID\r\n  v_id \x3d u_id / 255.0;\r\n#endif // ID\r\n\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos * 0.5, 0.0, 1.0) + u_extrudeMatrix * (v_radius + v_stroke_width) * vec4(offset, 0.0, 0.0);\r\n}\r\n"},
fill:{"fill.frag":"precision lowp float;\r\n\r\n#ifdef PATTERN\r\nuniform mediump vec2 u_pattern_tl;\r\nuniform mediump vec2 u_pattern_br;\r\nuniform lowp sampler2D u_texture;\r\nvarying mediump vec2 v_tileTextureCoord;\r\n#endif // PATTERN\r\n\r\n#ifdef ID\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\nvarying lowp vec4 v_color;\r\n\r\nvec4 mixColors(vec4 color1, vec4 color2) {\r\n  // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending)\r\n  // we use pre-multiplied colors hence the need for this kind of mixing. At lease we save ourselves an extra division...\r\n  float compositeAlpha \x3d color2.a + color1.a * (1.0 - color2.a);\r\n  vec3 compositeColor \x3d color2.rgb + color1.rgb * (1.0 - color2.a);\r\n\r\n  return vec4(compositeColor, compositeAlpha);\r\n}\r\n\r\nvoid main()\r\n{\r\n#ifdef PATTERN\r\n  // normalize the calculated texture coordinate such that it fits in the range of 0 to 1.\r\n  mediump vec2 normalizedTextureCoord \x3d mod(v_tileTextureCoord, 1.0);\r\n\r\n  // interpolate the image coordinate between the top-left and the bottom right to get the actual position to sample.\r\n  // after normalizing the position, we get a value ranging between 0 and 1 which refers to the entire texture, however\r\n  // we need to only sample from area that has our sprite in the mosaic.\r\n  mediump vec2 samplePos \x3d mix(u_pattern_tl, u_pattern_br, normalizedTextureCoord);\r\n\r\n  // sample the sprite mosaic\r\n  lowp vec4 color \x3d texture2D(u_texture, samplePos);\r\n  gl_FragColor \x3d v_color[3] * color;\r\n#else\r\n  gl_FragColor \x3d v_color;\r\n#endif // PATTERN\r\n\r\n#ifdef ID\r\n  if (gl_FragColor.a \x3c 1.0 / 255.0) {\r\n    discard;\r\n  }\r\n  gl_FragColor \x3d v_id;\r\n#endif // ID\r\n}\r\n",
"fill.vert":"precision mediump float;\r\n\r\nattribute vec2 a_pos;\r\n\r\nuniform highp mat4 u_transformMatrix;\r\nuniform highp vec2 u_normalized_origin;\r\nuniform mediump float u_depth;\r\n\r\n#ifdef PATTERN\r\nuniform mediump mat3 u_pattern_matrix;\r\nvarying mediump vec2 v_tileTextureCoord;\r\n#endif // PATTERN\r\n\r\n#ifdef ID\r\nuniform mediump vec4 u_id;\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\n#ifdef DD\r\nattribute vec4 a_color;\r\n#endif // DD\r\nuniform lowp vec4 u_color;\r\nvarying lowp vec4 v_color;\r\n\r\nvoid main()\r\n{\r\n#ifdef DD\r\n  v_color \x3d a_color * u_color;\r\n#else\r\n  v_color \x3d u_color;\r\n#endif // DD\r\n\r\n#ifdef ID\r\n  v_id \x3d u_id / 255.0;\r\n#endif // ID\r\n\r\n#ifdef PATTERN\r\n  // calculate the texture coordinates of the current vertex. It will of course get interpolated.\r\n  // The pattern matrix is a 3x3 scale matrix which 'tiles' the texture inside the tile, translating from tile coordinates\r\n  // (-4k to 8k -1) to texture coordinates.\r\n  v_tileTextureCoord \x3d (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\r\n#endif // PATTERN\r\n\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0, 1.0);\r\n}\r\n"},
icon:{"icon.frag":"precision mediump float;\r\n\r\nuniform lowp sampler2D u_texture; // SDF texture\r\n#ifdef SDF\r\nuniform lowp vec4 u_color; // a color to override the one of the vertex\r\nuniform lowp vec4 u_outlineColor;\r\nuniform mediump float u_outlineSize;\r\n#endif // SDF\r\n\r\nvarying mediump vec2 v_tex;\r\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\r\n// opacity of the layer given by the painter\r\nvarying lowp float v_transparency;\r\n\r\nvarying mediump vec2 v_size;\r\n\r\nvarying lowp vec4 v_color;\r\n\r\n#ifdef ID\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\n// we need the conversion function from RGBA to float\r\n#include \x3cutil/encoding.glsl\x3e\r\n\r\nvec4 mixColors(vec4 color1, vec4 color2) {\r\n  // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending)\r\n  // we use pre-multiplied colors hence the need for this kind of mixing. At lease we save ourselves an extra division...\r\n  float compositeAlpha \x3d color2.a + color1.a * (1.0 - color2.a);\r\n  vec3 compositeColor \x3d color2.rgb + color1.rgb * (1.0 - color2.a);\r\n\r\n  return vec4(compositeColor, compositeAlpha);\r\n}\r\n\r\nvoid main()\r\n{\r\n#ifdef SDF\r\n  lowp vec4 fillPixelColor \x3d v_color;\r\n\r\n  // calculate the distance from the edge [-0.5, 0.5]\r\n  float d \x3d rgba2float(texture2D(u_texture, v_tex)) - 0.5;\r\n\r\n  // the soft edge ratio is about 1.5 pixels allocated for the soft edge.\r\n  // 1 / 86 represents a single pixel given the size of the SDF is 128 and we add 4 pixels margins to deal with\r\n  // other non SDF types.\r\n  // The rasterized geometry takes only 86 pixels because of the extra 16 pixels margin for the outline.\r\n  const float sofetEdgeRatio \x3d 0.248062016; // \x3d\x3d\x3e (32.0 / 86.0) / 1.5;\r\n  float size \x3d max(v_size.x, v_size.y);\r\n  float dist \x3d d * sofetEdgeRatio * size;\r\n\r\n  // set the fragment's transparency according to the distance from the edge\r\n  fillPixelColor *\x3d clamp(0.5 - dist, 0.0, 1.0);\r\n\r\n  // count for the outline\r\n  // therefore tint the entire icon area.\r\n  if (u_outlineSize \x3e 0.25) {\r\n    lowp vec4 outlinePixelColor \x3d u_outlineColor;\r\n    // the outline limit ratio is derived from the 16 pixels allocated for the outline and the fact that 1/86 represents\r\n    // a single pixel.\r\n    const float outlineLimitRatio \x3d (16.0 / 86.0);\r\n    float clampedOutlineSize \x3d sofetEdgeRatio * min(u_outlineSize, outlineLimitRatio * max(v_size.x, v_size.y));\r\n\r\n    outlinePixelColor *\x3d clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\r\n\r\n    // finally combine the outline and the fill colors\r\n    gl_FragColor \x3d v_transparency * mixColors(fillPixelColor, outlinePixelColor);\r\n  }\r\n  else {\r\n    gl_FragColor \x3d v_transparency * fillPixelColor;\r\n  }\r\n#else // not an SDF\r\n  lowp vec4 texColor \x3d texture2D(u_texture, v_tex);\r\n  gl_FragColor \x3d v_transparency * texColor;\r\n#endif // SDF\r\n\r\n#ifdef ID\r\n  if (gl_FragColor.a \x3c 1.0 / 255.0) {\r\n    discard;\r\n  }\r\n  gl_FragColor \x3d v_id;\r\n#endif // ID\r\n}\r\n",
"icon.vert":"attribute vec2 a_pos;\r\nattribute vec2 a_vertexOffset;\r\nattribute vec4 a_tex;\r\nattribute vec4 a_levelInfo;\r\n\r\n#ifdef DD\r\nattribute vec4 a_color;\r\nattribute mediump float a_size;\r\n#endif // DD\r\nuniform lowp vec4 u_color;\r\nuniform mediump float u_size;\r\n\r\n#ifdef ID\r\nuniform mediump vec4 u_id;\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\nvarying lowp vec4 v_color;\r\n\r\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\r\n// relative to the tile's upper left corner\r\n// the extrusion vector.\r\nuniform highp mat4 u_transformMatrix;\r\n\r\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\r\nuniform highp mat4 u_extrudeMatrix;\r\n\r\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\r\nuniform highp vec2 u_normalized_origin;\r\n\r\n// the size of the mosaic given in pixels\r\nuniform vec2 u_mosaicSize;\r\n\r\n// the z of the layer. Given by the order of the layers in the style\r\nuniform mediump float u_depth;\r\n\r\n// the map's rotation from the north\r\nuniform mediump float u_mapRotation;\r\nuniform mediump float u_level;\r\n\r\n// indicate whether the current set of iconst should be kept upright when the map is rotated\r\nuniform lowp float u_keepUpright;\r\n\r\n// the rate of the change in the opacity (fade) of the icons\r\nuniform mediump float u_fadeSpeed;\r\n\r\n// the low level we transition (to/from)\r\nuniform mediump float u_minfadeLevel;\r\n\r\n// the high level we transition (to/from)\r\nuniform mediump float u_maxfadeLevel;\r\n\r\n// the amount of fade given teh current time past the last recorded level\r\nuniform mediump float u_fadeChange;\r\n\r\n// the opacity of the layer given by the painter\r\nuniform mediump float u_opacity;\r\n\r\n// the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\r\nvarying mediump vec2 v_tex;\r\n\r\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\r\n// opacity of the layer given by the painter\r\nvarying lowp float v_transparency;\r\n\r\nvarying mediump vec2 v_size;\r\n\r\n// the vertex offsets are given in integers, therefore in order to maintain a reasonable precision we multiply the values\r\n// by 8 and then at the shader devide by the same number\r\nconst float C_OFFSET_PRECISION \x3d 1.0 / 8.0;\r\n\r\nconst float C_256_TO_RAD \x3d 3.14159265359 / 128.0;\r\nconst float C_DEG_TO_RAD \x3d 3.14159265359 / 180.0;\r\nconst float tileCoordRatio \x3d 1.0 / 8.0;\r\n\r\nvoid main()\r\n{\r\n  mediump float a_labelMinLevel \x3d a_levelInfo[0];\r\n  mediump float a_angle         \x3d a_levelInfo[1];\r\n  mediump float a_minLevel      \x3d a_levelInfo[2];\r\n  mediump float a_maxLevel      \x3d a_levelInfo[3];\r\n\r\n  // if the given vertex should not be visible simply clip it by adding it a value that will push it outside the clipping plane\r\n  mediump float delta_z \x3d 0.0;\r\n\r\n  // If the label rotates with the map, and if the rotated label is upside down, hide it\r\n  mediump float rotated \x3d mod(a_angle + u_mapRotation, 256.0);\r\n  delta_z +\x3d (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated)); //ie. z +\x3d (flip \x3e 0) \x26\x26 (64 \x3c\x3d rotated) \x26\x26 (rotated \x3c 192)\r\n\r\n  // u_level is the current service level adjusted for the change in font size\r\n  delta_z +\x3d 1.0 - step(a_minLevel, u_level); // Test if (level \x3c minLevel)\r\n  delta_z +\x3d step(a_maxLevel, u_level); // Test if (maxLevel \x3c\x3d level)\r\n\r\n  // calculate the alpha given the change in the fade and the fade-speed\r\n  lowp float alpha \x3d clamp((u_fadeChange - a_labelMinLevel) / u_fadeSpeed, 0.0, 1.0);\r\n\r\n  // if the speed is positive we are zooming in and therefore we need to 'fade-in'. Else we need to 'fade-out'\r\n  v_transparency \x3d (u_fadeSpeed \x3e\x3d 0.0 ? alpha : 1.0 - alpha);\r\n\r\n  // now deal with the min/max fade-levels. If we exceeded the level we simply snap to 0 or 1\r\n  if (u_maxfadeLevel \x3c a_labelMinLevel)\r\n  {\r\n    v_transparency \x3d 0.0;\r\n  }\r\n  if (u_minfadeLevel \x3e\x3d a_labelMinLevel)\r\n  {\r\n    v_transparency \x3d 1.0;\r\n  }\r\n\r\n  // if label had been faded out, clip it\r\n  delta_z +\x3d step(v_transparency, 0.0);\r\n\r\n  vec2 offset \x3d C_OFFSET_PRECISION * a_vertexOffset;\r\n\r\n  v_size \x3d abs(offset);\r\n\r\n#ifdef SDF\r\n  offset \x3d (120.0 / 86.0) * offset;\r\n#endif // SDF\r\n\r\n#ifdef DD\r\n  mediump float icon_size \x3d a_size * u_size;\r\n#else\r\n  mediump float icon_size \x3d u_size;\r\n#endif // DD\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * icon_size * vec4(offset, delta_z, 0.0);\r\n\r\n#ifdef DD\r\n  v_color \x3d a_color * u_color;\r\n#else\r\n  v_color \x3d u_color;\r\n#endif // DD\r\n\r\n#ifdef ID\r\n  v_id \x3d u_id / 255.0;\r\n#endif // ID\r\n\r\n  v_tex \x3d a_tex.xy / u_mosaicSize;\r\n  v_transparency *\x3d v_color.w;\r\n}\r\n"},
line:{"line.frag":"varying mediump vec2 v_normal;\r\nvarying highp float v_accumulatedDistance;\r\n\r\nvarying mediump float v_lineHalfWidth;\r\nvarying lowp vec4 v_color;\r\n\r\nvarying mediump float v_blur;\r\n\r\n#ifdef PATTERN\r\nuniform mediump vec2 u_pattern_tl;\r\nuniform mediump vec2 u_pattern_br;\r\nuniform mediump vec2 u_spriteSize;\r\nuniform sampler2D u_texture;\r\n\r\n// Horizontal scale is used to scale the horizontal texture coordinate v_normal.x before adding it as an offset to the\r\n// accumulated distance. Most vertices will have v_normal.x \x3d\x3d 0, because the pattern must be sampled only depending on\r\n// the v_accumulatedDistance value. But tessellation at caps can have vertices with v_normal.x !\x3d 0, thus allowing to\r\n// \"keep moving\" for a few more pixel even when the line has ended or has not started yet.\r\nconst mediump float tileCoordRatio \x3d 8.0;\r\n#else\r\nvarying mediump vec2 v_dasharray;\r\n#endif\r\n\r\n#ifdef ID\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\nvoid main()\r\n{\r\n  // dist represent the distance of the fragment from the line. 1.0 or -1.0 will be the values on the edge of the line,\r\n  // and any value in between will be inside the line (the sign represent the direction - right or left).\r\n  // since u_linewidth.s (half line width) is represented in pixels, dist is also given in pixels\r\n  mediump float fragDist \x3d length(v_normal) * v_lineHalfWidth;\r\n\r\n  // calculate the alpha given the difference between the line-width and the distance of the fragment from the center-line.\r\n  // We need to count for both sides of the line.\r\n  lowp float alpha \x3d clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\r\n\r\n#ifdef PATTERN\r\n  // we need to calculate the relative portion of the line texture along the line given the accumulated distance aliong the line\r\n  // The computed value should is anumber btween 0 and 1 which will later be used to interpolate btween the BR and TL values\r\n  mediump float relativeTexX \x3d mod((v_accumulatedDistance + v_normal.x * v_lineHalfWidth * tileCoordRatio) / u_spriteSize.x, 1.0);\r\n\r\n  // in order to calculate the texture coordinates perpendicular to the line (Y axis), we use the interpolated normal values\r\n  // which range from -1.0 to 1.0. On the line's centerline, the value of the interpolated normal is 0.0, however the relative\r\n  // texture value should be 0.5 (given that at the bottom of the line, the texture coordinate must be equal to 0.0)\r\n  // (TL) ---------------------------      --\x3e left edge of line. Interpolated normal is 1.0\r\n  //              | -\x3e line-width / 2\r\n  //      - - - - - - - - - - - - - -\r\n  //              | -\x3e line-width / 2\r\n  //      ---------------------------- (BR)--\x3e right edge of line. Interpolated normal is -1.0\r\n\r\n  mediump float relativeTexY \x3d 0.5 + (v_normal.y * v_lineHalfWidth / u_spriteSize.y);\r\n\r\n  // claculate the actual texture coordinates by interpolating between the TL/BR pattern coordinates\r\n  mediump vec2 texCoord \x3d mix(u_pattern_tl, u_pattern_br, vec2(relativeTexX, relativeTexY));\r\n\r\n  // get the color from the texture\r\n  lowp vec4 color \x3d texture2D(u_texture, texCoord);\r\n\r\n  // finally write the fragment value\r\n  gl_FragColor \x3d alpha * v_color[3] * color;\r\n#else\r\n  // now calculate the dashes given the accumulated distance of the line:\r\n  // start with calculating a normalized position along the line\r\n  lowp float dashPos \x3d  mod(v_accumulatedDistance, v_dasharray.x + v_dasharray.y);\r\n\r\n  // calculate the contribution to the alpha of the dash part. It is provided by the shortest portion of the position along the dash.\r\n  // we must clamp since the value might be bigger than 1 or smaller than zero (when over a dash).\r\n  //   | \x3c--- pos along the dash part\r\n  // -------_______-------_______\r\n  // when the dashPos is over the 'gap' part of the dash dasharray.x - dashPos is negative and therefore the alpha will\r\n  // get clamped to zero.\r\n  // when dasharray.x - dashPos is positive, or when dashPos is smaller than 1.0, it gives us a soft edge to each dash part.\r\n  // along the direction of the line.\r\n  lowp float dashAlpha \x3d clamp(min(dashPos, v_dasharray.x - dashPos) + 0.5, 0.0, 1.0);\r\n\r\n  // if we don't have a no-data part to the dash then it is a solid line\r\n  dashAlpha \x3d max(sign(-v_dasharray.y), dashAlpha);\r\n  // finally multiply the fragment's alpha by the calculated dash-alpha\r\n  alpha *\x3d dashAlpha;\r\n\r\n  // output the fragment color\r\n  gl_FragColor \x3d alpha * v_color;\r\n#endif // PATTERN\r\n\r\n#ifdef ID\r\n  if (gl_FragColor.a \x3c 1.0 / 255.0) {\r\n    discard;\r\n  }\r\n  gl_FragColor \x3d v_id;\r\n#endif // ID\r\n}\r\n",
"line.vert":"/* The implementation of the renderer is based on the article and implementation of MB described here:\r\n* https://www.mapbox.com/blog/drawing-antialiased-lines/\r\n*/\r\n\r\nattribute vec2 a_pos;\r\nattribute vec4 a_offsetAndNormal;\r\nattribute vec2 a_accumulatedDistance;\r\n\r\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\r\n// relative to the tile's upper left corner\r\n// the extrusion vector.\r\nuniform highp mat4 u_transformMatrix;\r\n\r\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\r\nuniform highp mat4 u_extrudeMatrix;\r\n\r\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\r\nuniform highp vec2 u_normalized_origin;\r\n\r\nuniform mediump float u_blur;\r\nuniform mediump float u_antialiasing; // the feather distance at which the line edge fades out\r\n\r\n// the z of the layer. Given by the order of the layers in the style\r\nuniform mediump float u_depth;\r\n\r\n// the interpolated normal to the line. the information is packed into the two LSBs of the vertex coordinate\r\nvarying mediump vec2 v_normal;\r\n\r\n// the accumulated distance along the line. We need this information in order to render the dashes.\r\nvarying highp float v_accumulatedDistance;\r\n\r\nconst float scale \x3d 1.0 / 31.0;\r\n\r\n#ifdef DD\r\nattribute vec4 a_color;\r\nattribute mediump float a_width;\r\n#endif // DD\r\nuniform lowp vec4 u_color;\r\nuniform mediump float u_width;\r\n\r\n#ifdef ID\r\nuniform mediump vec4 u_id;\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\nvarying lowp vec4 v_color;\r\nvarying mediump float v_lineHalfWidth; // the inset and outset of the line\r\nvarying mediump float v_blur;\r\n\r\n#ifndef PATTERN\r\nuniform mediump vec2 u_dasharray;\r\nvarying mediump vec2 v_dasharray;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n  v_normal \x3d a_offsetAndNormal.zw * scale;\r\n\r\n#ifdef DD\r\n  v_lineHalfWidth \x3d a_width * u_width;\r\n#else\r\n  v_lineHalfWidth \x3d u_width;\r\n#endif // DD\r\n\r\n  v_lineHalfWidth +\x3d u_antialiasing;\r\n  v_lineHalfWidth *\x3d 0.5;\r\n\r\n#ifndef PATTERN\r\n#ifdef DD\r\n  v_dasharray \x3d u_dasharray * a_width;\r\n#else\r\n  v_dasharray \x3d u_dasharray * u_width;\r\n#endif // DD\r\n#endif\r\n\r\n  // calculate the relative distance from the centerline to the edge of the line. Since offset is given in integers (for the\r\n  // sake of using less attribute memory, we need to scale it back to the original range of ~ 0: 1)\r\n  mediump vec2 dist \x3d v_lineHalfWidth * a_offsetAndNormal.xy * scale;\r\n\r\n  // transform the vertex\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * vec4(dist, 0.0, 0.0);\r\n\r\n  // the accumulated distance will be used to calculate the dashes (or the no-data...)\r\n  v_accumulatedDistance \x3d a_accumulatedDistance.x;\r\n\r\n  v_blur \x3d u_blur + u_antialiasing;\r\n\r\n  #ifdef DD\r\n    v_color \x3d a_color * u_color;\r\n  #else\r\n    v_color \x3d u_color;\r\n  #endif // DD\r\n\r\n  #ifdef ID\r\n    v_id \x3d u_id / 255.0;\r\n  #endif // ID\r\n}\r\n"},
outline:{"outline.frag":"varying lowp vec4 v_color;\r\nvarying mediump vec2 v_normal;\r\n\r\n#ifdef ID\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\nvoid main()\r\n{\r\n  // Calculate the distance of the pixel from the line in pixels.\r\n  lowp float dist \x3d abs(v_normal.y);\r\n\r\n  lowp float alpha \x3d smoothstep(1.0, 0.0, dist);\r\n  gl_FragColor \x3d alpha * v_color;\r\n\r\n#ifdef ID\r\n  if (gl_FragColor.a \x3c 1.0 / 255.0) {\r\n    discard;\r\n  }\r\n  gl_FragColor \x3d v_id;\r\n#endif // ID\r\n}\r\n",
"outline.vert":"attribute vec2 a_pos;\r\nattribute vec2 a_offset;\r\nattribute vec2 a_xnormal;\r\n\r\n#ifdef DD\r\nattribute vec4 a_color;\r\n#endif // DD\r\nuniform lowp vec4 u_color;\r\nvarying lowp vec4 v_color;\r\n\r\n#ifdef ID\r\nuniform mediump vec4 u_id;\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\nuniform highp mat4 u_transformMatrix;\r\nuniform highp mat4 u_extrudeMatrix;\r\nuniform highp vec2 u_normalized_origin;\r\nuniform mediump float u_depth;\r\nuniform mediump float u_outline_width;\r\n\r\nvarying lowp vec2 v_normal;\r\n\r\nconst float scale \x3d 1.0 / 15.0;\r\n\r\nvoid main()\r\n{\r\n#ifdef DD\r\n  v_color \x3d a_color * u_color;\r\n#else\r\n  v_color \x3d u_color;\r\n#endif // DD\r\n\r\n#ifdef ID\r\n  v_id \x3d u_id / 255.0;\r\n#endif // ID\r\n\r\n  v_normal \x3d a_xnormal;\r\n\r\n  // calculate the relative distance from the centerline to the edge of the line. Since offset is given in integers (for the\r\n  // sake of using less attribute memory, we need to scale it back to the original range of ~ 0: 1)\r\n  mediump vec4 dist \x3d vec4(u_outline_width * a_offset * scale, 0.0, 0.0);\r\n\r\n  // Remove the texture normal bit of the position before scaling it with the\r\n  // model/view matrix. Add the extrusion vector *after* the model/view matrix\r\n  // because we're extruding the line in pixel space, regardless of the current\r\n  // tile's zoom level.\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * dist;\r\n}\r\n"},
text:{"text.frag":"uniform lowp sampler2D u_texture;\r\nuniform mediump float u_edgeDistance;\r\n\r\nvarying lowp vec2 v_tex;\r\nvarying lowp float v_transparency;\r\nvarying lowp vec4 v_color;\r\nvarying mediump float v_edgeWidth;\r\nvarying mediump float v_edgeDistance;\r\n\r\n#ifdef ID\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\n// this is taken from http://www.valvesoftware.com/publications/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf\r\n// and https://www.mapbox.com/blog/text-signed-distance-fields/\r\n// http://metalbyexample.com/rendering-text-in-metal-with-signed-distance-fields/\r\n\r\nvoid main()\r\n{\r\n  // read the distance from the SDF texture\r\n  lowp float dist \x3d texture2D(u_texture, v_tex).a;\r\n\r\n  // use a smooth-step in order to calculate the geometry of the shape given by the distance field\r\n  mediump float alpha \x3d smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist) * v_transparency;\r\n\r\n  gl_FragColor \x3d alpha * v_color;\r\n\r\n#ifdef ID\r\n  if (gl_FragColor.a \x3c 1.0 / 255.0) {\r\n    discard;\r\n  }\r\n  gl_FragColor \x3d v_id;\r\n#endif // ID\r\n}\r\n",
"text.vert":"attribute vec2 a_pos;\r\nattribute vec2 a_vertexOffset;\r\nattribute vec4 a_tex;\r\nattribute vec4 a_levelInfo;\r\n\r\nuniform lowp vec4 u_color; // always defined as halo does not support data driven but text does\r\n#ifdef DD\r\nattribute vec4 a_color;\r\n#endif // DD\r\nvarying lowp vec4 v_color;\r\n\r\nuniform mediump float u_size;\r\n#ifdef DD\r\nattribute mediump float a_size;\r\n#endif // DD\r\nvarying mediump float v_size;\r\n\r\n#ifdef ID\r\nuniform mediump vec4 u_id;\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\n\r\n// attribute bool a_visible; // --\x3e a one bit controlling the visibility of the vertex\r\n\r\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\r\n// relative to the tile's upper left corner\r\n// the extrusion vector.\r\nuniform highp mat4 u_transformMatrix;\r\n\r\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\r\nuniform highp mat4 u_extrudeMatrix;\r\n\r\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\r\nuniform highp vec2 u_normalized_origin;\r\n\r\n// the size of the mosaic given in pixels\r\nuniform vec2 u_mosaicSize;\r\n\r\n// the z of the layer. Given by the order of the layers in the style\r\nuniform mediump float u_depth;\r\n\r\n// the map's rotation from the north\r\nuniform mediump float u_mapRotation;\r\nuniform mediump float u_level;\r\n\r\n// indicate whether the current set of iconst should be kept upright when the map is rotated\r\nuniform lowp float u_keepUpright;\r\n\r\n// the rate of the change in the opacity (fade) of the icons\r\nuniform mediump float u_fadeSpeed;\r\n\r\n// the low level we transition (to/from)\r\nuniform mediump float u_minfadeLevel;\r\n\r\n// the high level we transition (to/from)\r\nuniform mediump float u_maxfadeLevel;\r\n\r\n// the amount of fade given teh current time past the last recorded level\r\nuniform mediump float u_fadeChange;\r\n\r\n// the opacity of the layer given by the painter\r\nuniform mediump float u_opacity;\r\n\r\n// the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\r\nvarying lowp vec2 v_tex;\r\n\r\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\r\n// opacity of the layer given by the painter\r\nvarying lowp float v_transparency;\r\n\r\n// the vertex offsets are given in integers, therefore in order to maintain a reasonable precision we multiply the values\r\n// by 8 and then at the shader divide by the same number\r\nconst float offsetPrecision \x3d 1.0 / 8.0;\r\n\r\n// outline position and appearance\r\nconst mediump float edgePos \x3d 0.75; // defined by the SDF encoding\r\nuniform mediump float u_edgeDistance;\r\nuniform mediump float u_edgeBlur;\r\nuniform mediump float u_antialiasingWidth; // antialiasing (factors in the pixel_ratio for high res devices)\r\n\r\nvarying mediump float v_edgeDistance; // will factor in the size\r\nvarying mediump float v_edgeWidth; // will factor in the size\r\n\r\nuniform lowp float u_halo; // needed to avoid using the color attribute for halo\r\n\r\nvoid main()\r\n{\r\n  mediump float a_labelMinLevel \x3d a_levelInfo[0];\r\n  mediump float a_angle        \x3d a_levelInfo[1];\r\n  mediump float a_minLevel    \x3d a_levelInfo[2];\r\n  mediump float a_maxLevel    \x3d a_levelInfo[3];\r\n\r\n  // if the given vertex should not be visible simply clip it by adding it a value that will push it outside the clipping plane\r\n  mediump float delta_z \x3d 0.0;\r\n\r\n  // TODO: force clipping the vertex in case that the vertex isn't visible\r\n  //delta_z +\x3d a_visible ? 0.0 : 1.0;\r\n\r\n  // If the label rotates with the map, and if the rotated label is upside down, hide it\r\n  mediump float rotated \x3d mod(a_angle + u_mapRotation, 256.0);\r\n  delta_z +\x3d (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated)); //ie. z +\x3d (flip \x3e 0) \x26\x26 (64 \x3c\x3d rotated) \x26\x26 (rotated \x3c 192)\r\n\r\n  // u_level is the current service level adjusted for the change in font size\r\n  delta_z +\x3d 1.0 - step(a_minLevel, u_level); // Test if (level \x3c minLevel)\r\n  delta_z +\x3d step(a_maxLevel, u_level); // Test if (maxLevel \x3c\x3d level)\r\n\r\n  // calculate the alpha given the change in the fade and the fade-speed\r\n  lowp float alpha \x3d clamp((u_fadeChange - a_labelMinLevel) / u_fadeSpeed, 0.0, 1.0);\r\n\r\n  // if the speed is positive we are zooming in and therefore we need to 'fade-in'. Else we need to 'fade-out'\r\n  v_transparency \x3d (u_fadeSpeed \x3e\x3d 0.0 ? alpha : 1.0 - alpha);\r\n\r\n  // now deal with the min/max fade-levels. If we exceeded the level we simply snap to 0 or 1\r\n  if (u_maxfadeLevel \x3c a_labelMinLevel)\r\n  {\r\n    v_transparency \x3d 0.0;\r\n  }\r\n  if (u_minfadeLevel \x3e\x3d a_labelMinLevel)\r\n  {\r\n    v_transparency \x3d 1.0;\r\n  }\r\n\r\n  // if label has been faded out, clip it\r\n  delta_z +\x3d step(v_transparency, 0.0);\r\n\r\n  v_tex \x3d a_tex.xy / u_mosaicSize;\r\n\r\n#ifdef DD\r\n  if (u_halo \x3e 0.5)\r\n  {\r\n    v_color \x3d u_color;\r\n  }\r\n  else\r\n  {\r\n    v_color \x3d a_color * u_color;\r\n    // opacity already factored in a_color\r\n  }\r\n#else\r\n  v_color \x3d u_color;\r\n#endif // DD\r\n\r\n#ifdef DD\r\n  v_size \x3d a_size * u_size;\r\n#else\r\n  v_size \x3d u_size;\r\n#endif // DD\r\n\r\n#ifdef ID\r\n  v_id \x3d u_id / 255.0;\r\n#endif // ID\r\n\r\n  v_edgeDistance \x3d edgePos - u_edgeDistance / v_size;\r\n  v_edgeWidth \x3d (u_antialiasingWidth + u_edgeBlur) / v_size;\r\n\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * v_size * vec4(offsetPrecision * a_vertexOffset, delta_z, 0.0);\r\n}\r\n"},
tileInfo:{"tileInfo.frag":"uniform mediump sampler2D u_texture;\r\nvarying mediump vec2 v_tex;\r\n\r\nvoid main(void) {\r\n  lowp vec4 color \x3d texture2D(u_texture, v_tex);\r\n  gl_FragColor \x3d 0.75 * color;\r\n}\r\n","tileInfo.vert":"attribute vec2 a_pos;\r\n\r\nuniform highp mat4 u_transformMatrix;\r\nuniform mediump vec2 u_normalized_origin;\r\nuniform mediump float u_depth;\r\nuniform mediump float u_coord_ratio;\r\nuniform mediump vec2 u_delta; // in tile coordinates\r\nuniform mediump vec2 u_dimensions; // in tile coordinates\r\n\r\nvarying mediump vec2 v_tex;\r\n\r\nvoid main() {\r\n  mediump vec2 offests \x3d u_coord_ratio * vec2(u_delta + a_pos * u_dimensions);\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(offests, 0.0, 1.0);\r\n\r\n  v_tex \x3d a_pos;\r\n}\r\n"},
util:{"encoding.glsl":"// Factors to convert rgba back to float\r\nconst vec4 rgba2float_factors \x3d vec4(\r\n    255.0 / (256.0),\r\n    255.0 / (256.0 * 256.0),\r\n    255.0 / (256.0 * 256.0 * 256.0),\r\n    255.0 / (256.0 * 256.0 * 256.0 * 256.0)\r\n  );\r\n\r\nfloat rgba2float(vec4 rgba) {\r\n  // Convert components from 0-\x3e1 back to 0-\x3e255 and then\r\n  // add the components together with their corresponding\r\n  // fixed point factors, i.e. (256^1, 256^2, 256^3, 256^4)\r\n  return dot(rgba, rgba2float_factors);\r\n}\r\n"}}})},
"*noref":1}});
define("require exports ../../../core/tsSupport/declareExtendsHelper ../../../core/tsSupport/decorateHelper ../../../Graphic ../../../core/Handles ../../../core/promiseUtils ../../../core/accessorSupport/decorators ./LayerView2D ../tiling/TileInfoViewPOT ../tiling/TileKey ../tiling/TileQueue ../tiling/TileStrategy ../../vectorTiles/TileHandler ../../vectorTiles/VectorTileContainer ../../vectorTiles/VectorTileDisplayObject".split(" "),function(w,v,l,u,d,k,a,n,c,b,f,y,q,h,g,m){return function(c){function p(){var a=null!==
c&&c.apply(this,arguments)||this;a._fetchQueue=null;a._tileRequests=new Map;a._handles=new k;a._invalidateStyle=!1;a.container=new g;return a}l(p,c);p.prototype.initialize=function(){var a=this;this._tileInfoView=new b(this.layer.tileInfo,this.layer.fullExtent);this._tileHandler=new h(this.layer,window.devicePixelRatio||1,!0,this.container);this.handles.add(this.watch("layer.currentStyleInfo",function(b){a._start()}))};p.prototype.destroy=function(){this._stop();this.container.dispose();this._tileHandler.destroy();
this._tileHandler=null};p.prototype.hitTest=function(b,c){var e=this;return this.suspended?a.resolve(null):this.container.hitTest(b,c).then(function(a){var b=e._tileHandler.getStyleRepository().layers;if(null===a||0>a||a>=b.length)return null;a=new d({attributes:{layerId:a,layerName:b[a].id}});a.layer=e.layer;a.sourceLayer=e.layer;return a})};p.prototype.update=function(a){this.notifyChange("updating");var b=this._tileHandlerPromise;if(b&&b.isFulfilled())if(a.pixelRatio!==this._tileHandler.devicePixelRatio)this._start(),
this._tileHandler.devicePixelRatio=a.pixelRatio;else{this._invalidateStyle&&(this._issueStyleInvalidation(a),this._invalidateStyle=!1);this._fetchQueue.pause();this._fetchQueue.state=a.state;this._tileStrategy.update(a);this._fetchQueue.resume();for(var b=0,c=this.container.children;b<c.length;b++)this._tileHandler.updateTile(c[b],a)}};p.prototype.attach=function(){var a=this;this._start();this._handles.add(this.layer.on("paint-change",function(b){return a.container.requestRender()}));this._handles.add(this.layer.on("layout-change",
function(b){a._invalidateStyle=!0;a.requestUpdate()}))};p.prototype.detach=function(){this._stop();this._handles.removeAll()};p.prototype.moveStart=function(){this.requestUpdate()};p.prototype.viewChange=function(){this.requestUpdate()};p.prototype.moveEnd=function(){this.requestUpdate()};p.prototype.canResume=function(){var a=this.inherited(arguments),b=this.layer;if(a&&b.currentStyleInfo){var c=this.view.scale;(b=b.currentStyleInfo)&&b.layerDefinition&&(b=b.layerDefinition,b.minScale&&b.minScale<
c&&(a=!1),b.maxScale&&b.maxScale>c&&(a=!1))}return a};p.prototype.isUpdating=function(){var a=!0;this._tileRequests.forEach(function(b){a=a&&b.isFulfilled()});return!this._tileHandlerPromise||!this._tileHandlerPromise.isFulfilled()||!a};p.prototype.acquireTile=function(b){var c=this,d=f.pool.acquire();d.set(b.level,b.row,b.col,b.world);b=this.updateParameters.state.rotation;var e=this._tileHandler.getStyleRepository(),g=m.pool.acquire(d,this.layer.tileInfo,e,b),h=this.layer.sourceNameToSource;if(1>
Object.keys(h).length)g.setData(null,null),g.once("attach",function(){return c.requestUpdate()}),this.container.addChild(g);else return this._tileHandlerPromise.then(function(){var b=[],e=[],f;for(f in h){var k=h[f].getRefKey(d);b.push(k);e.push(f)}b=a.eachAlways(b).then(function(a){for(var b={},d=0;d<a.length;d++)a[d].value&&(b[e[d]]=a[d].value);if(0===Object.keys(b).length)g.setData(null,null),g.once("attach",function(){return c.requestUpdate()}),c.container.addChild(g);else return c._fetchQueue.push(g.key).then(function(a){g.setData(a.tileData,
a.client);g.once("attach",function(){return c.requestUpdate()});c.container.addChild(g);c.notifyChange("updating")})});c._tileRequests.set(d.id,b);c.notifyChange("updating")}),g};p.prototype.releaseTile=function(a){var b=a.key.id,c=this._tileRequests.get(b);c&&(c.isFulfilled()||c.cancel(),this._tileRequests.delete(b));this.container.removeChild(a);this.requestUpdate();a.once("detach",function(){return m.pool.release(a)});this.notifyChange("updating")};p.prototype._start=function(){var a=this;this._stop();
if(this.layer.currentStyleInfo&&this.attached){var b=this._tileHandler.start().then(function(){a._tileHandlerPromise===b&&(a._tileStrategy=new q({cachePolicy:"keep",coveragePolicy:"smallest",acquireTile:function(b){return a.acquireTile(b)},releaseTile:function(b){return a.releaseTile(b)},tileInfoView:a._tileInfoView}),a._fetchQueue=new y({tileInfoView:a._tileInfoView,process:function(b){return a._getTileData(b)}}),a.container.initialize(a._tileHandler.spriteMosaic,a._tileHandler.glyphMosaic,a.layer.tileInfo,
a._tileInfoView),a.requestUpdate())});this._tileHandlerPromise=b}};p.prototype._stop=function(){this._tileHandlerPromise&&(this._tileHandlerPromise.isFulfilled()?this._tileHandlerPromise.isResolved()&&(this._tileHandlerPromise=null,this._fetchQueue.destroy(),this._fetchQueue=null,this._tileStrategy.destroy(),this._tileStrategy=null,this.container.removeAllChildren(),this._tileHandler.stop(),m.pool.prune()):(this._tileHandlerPromise.cancel(),this._tileHandlerPromise=null))};p.prototype._getTileData=
function(a){return this._tileHandler.getTileData(a,this.updateParameters.state.rotation)};p.prototype._issueStyleInvalidation=function(a){var b=this;this._tileHandler.updateStyle().then(function(){b._fetchQueue.pause();b._fetchQueue.clear();b._tileRequests.forEach(function(a,b){a.cancel()});b._tileRequests.clear();b._fetchQueue.resume();b.requestUpdate()})};u([n.property({dependsOn:["view.scale","layer.currentStyleInfo"]})],p.prototype,"suspended",void 0);return p=u([n.subclass("esri.views.2d.layers.VectorTileLayerView2D")],
p)}(n.declared(c))});