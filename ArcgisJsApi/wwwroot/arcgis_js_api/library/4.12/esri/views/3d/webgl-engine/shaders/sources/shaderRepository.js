// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.12/esri/copyright.txt for details.
//>>built
define(["require","exports"],function(a,b){return{edgeRenderer:{"adjustProjectedPosition.glsl":"uniform vec2 uDepthBias;\nuniform vec2 uViewportDimInv;\nbool isNaN(float val) {\n  return ( val \x3c 0.0 || 0.0 \x3c val || val \x3d\x3d 0.0 ) ? false : true;\n}\nvec2 calculateProjectedBiasXY(vec4 projPos, vec3 worldNormal) {\n  float offsetXY \x3d uDepthBias.x;\n  float offsetZ  \x3d uDepthBias.y;\n  vec4 projNormal \x3d uProj * uView * vec4(worldNormal, 0.0);\n  return offsetXY * projPos.w * 2.0 * uViewportDimInv * normalize(projNormal.xyz).xy;\n}\nfloat calculateProjectedBiasZ(vec4 projPos) {\n  float offsetZ \x3d uDepthBias.y;\n  return sqrt(projPos.z) * offsetZ;\n}\nvec4 adjustProjectedPosition(vec4 projPos, vec3 worldNormal, float lineWidth) {\n  vec2 offsetXY \x3d calculateProjectedBiasXY(projPos, worldNormal);\n  if (!isNaN(offsetXY.x) \x26\x26 !isNaN(offsetXY.y)) {\n    projPos.xy +\x3d offsetXY;\n  }\n  projPos.z +\x3d calculateProjectedBiasZ(projPos);\n  return projPos;\n}",
"edgeRenderer.frag":"#include \x3cutil/fsPrecision.glsl\x3e\n#include \x3cutil/slice.glsl\x3e\nvarying vec4 vColor;\nvarying float vRadius;\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying float vLineLengthPixels;\nvarying float vSizeFalloffFactor;\nvarying float vLineIndex;\n#define COVERAGE_TEST_THRESHOLD 0.01\n#include \x3cedgeRenderer/lineOffset.glsl\x3e\nvec2 lineWithCapsDistance(float radius, vec2 position, float lineLength) {\n  float lineOffset \x3d calculateLineOffset();\n  float positionX \x3d position.x - lineOffset;\n  if (radius \x3c 1.0) {\n    float coverageX \x3d clamp(min(radius, positionX + 0.5) - max(-radius, positionX - 0.5), 0.0, 1.0);\n    float coverageY \x3d clamp(min(lineLength, position.y + 0.5) - max(0.0, position.y - 0.5), 0.0, 1.0);\n    float coverage \x3d min(coverageX, coverageY);\n    return vec2(0.5 - coverage, 0.0);\n  }\n  else {\n    float positionOnCap \x3d position.y - clamp(position.y, 0.0, lineLength);\n    vec2 lineToPosition \x3d vec2(positionX, positionOnCap);\n    return vec2(length(lineToPosition) - radius, positionOnCap / radius);\n  }\n}\nvoid main() {\n  float radius \x3d vRadius * calculateLinePressure();\n  vec2 distance \x3d lineWithCapsDistance(radius, vPosition.xy, vLineLengthPixels);\n  float coverage \x3d clamp(0.5 - distance.x, 0.0, 1.0);\n#ifdef ANTIALIASING\n  const float coverageLimit \x3d COVERAGE_TEST_THRESHOLD;\n#else\n  float coverageLimit \x3d radius \x3c\x3d 0.5 ? COVERAGE_TEST_THRESHOLD : 0.75;\n#endif\n  if (coverage \x3c coverageLimit) {\n    discard;\n  }\n  discardBySlice(vWorldPosition);\n  float alpha \x3d vColor.a * coverage;\n  gl_FragColor \x3d vec4(vColor.rgb, alpha);\n}",
"edgeRenderer.vert":"#include \x3cutil/vsPrecision.glsl\x3e\nuniform mat4 uProj;\nuniform mat4 uView;\nuniform mat4 uModel;\nuniform vec3 uCameraPosition;\nuniform vec2 uPixelToNDC;\nuniform vec2 uNDCToPixel;\nuniform float uPixelRatio;\nattribute vec3 aPosition0;\nattribute vec3 aPosition1;\nattribute float aVariantOffset;\nattribute float aVariantStroke;\nattribute float aVariantExtension;\n#ifdef SILHOUETTE\nattribute vec3 aNormalA;\nattribute vec3 aNormalB;\n#else\nattribute vec3 aNormal;\n#endif\nattribute vec2 aSideness;\nattribute vec2 aPackedAttributes;\nstruct UnpackedAttributes {\nvec2 sideness;\nvec2 sidenessNorm;\nfloat lineWidthPixels;\nfloat extensionLengthPixels;\n#if (MODE \x3d\x3d MODE_UBER)\nfloat type;\n#endif\n};\nvarying vec4 vColor;\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying float vRadius;\nvarying float vLineLengthPixels;\nvarying float vSizeFalloffFactor;\n#include \x3cedgeRenderer/adjustProjectedPosition.glsl\x3e\n#include \x3cedgeRenderer/styleOutputs.glsl\x3e\n#include \x3cedgeRenderer/lineAmplitude.glsl\x3e\n#include \x3cedgeRenderer/util.glsl\x3e\nvec4 calculateGeometricOutputs(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\n  vec2 sideness \x3d unpackedAttributes.sideness;\n  vec2 sidenessNorm \x3d unpackedAttributes.sidenessNorm;\n  vWorldPosition \x3d mix(worldPosV0, worldPosV1, sidenessNorm.y).xyz;\n  vec4 viewPos \x3d mix(viewPosV0, viewPosV1, sidenessNorm.y);\n  vec4 projPosV0 \x3d uProj * viewPosV0;\n  vec4 projPosV1 \x3d uProj * viewPosV1;\n  vec4 projPos \x3d uProj * viewPos;\n  vec3 screenSpaceLineNDC \x3d (projPosV1.xyz / projPosV1.w - projPosV0.xyz / projPosV0.w);\n  vec2 screenSpaceLinePixels \x3d screenSpaceLineNDC.xy * uNDCToPixel;\n  float lineLengthPixels \x3d length(screenSpaceLinePixels);\n  float dzPerPixel \x3d screenSpaceLineNDC.z / lineLengthPixels;\n  vec2 screenSpaceDirection \x3d screenSpaceLinePixels / lineLengthPixels;\n  vec2 perpendicularScreenSpaceDirection \x3d vec2(screenSpaceDirection.y, -screenSpaceDirection.x) * sideness.x;\n  float falloffFactor \x3d distanceBasedPerspectiveFactor(-viewPos.z) * uPixelRatio;\n  float lineWidthPixels \x3d unpackedAttributes.lineWidthPixels * falloffFactor;\n  float extensionLengthPixels \x3d calculateExtensionLength(unpackedAttributes.extensionLengthPixels, lineLengthPixels) * falloffFactor;\n  float lineAmplitudePixels \x3d calculateLineAmplitude(unpackedAttributes) * uPixelRatio;\n  vSizeFalloffFactor \x3d falloffFactor;\n  float lineWidthAndAmplitudePixels \x3d lineWidthPixels + lineAmplitudePixels + lineAmplitudePixels;\n  float extendedLineLengthPixels \x3d lineLengthPixels + extensionLengthPixels + extensionLengthPixels;\n#ifdef ANTIALIASING\n  const float aaPaddingPixels \x3d 1.0;\n  float halfAAPaddedLineWidthAndAmplitudePixels \x3d lineWidthAndAmplitudePixels * 0.5 + aaPaddingPixels;\n  float aaPaddedRoundedCapSizePixels \x3d lineWidthPixels * 0.5 + aaPaddingPixels;\n  float aaPaddedLineLengthPixels \x3d extendedLineLengthPixels + aaPaddingPixels + aaPaddingPixels;\n  float halfAAPaddedLineLengthPixels \x3d aaPaddedLineLengthPixels * 0.5;\n#else\n  float halfAAPaddedLineWidthAndAmplitudePixels \x3d max(lineWidthAndAmplitudePixels, 1.0) * 0.5;\n  float aaPaddedRoundedCapSizePixels \x3d max(lineWidthPixels, 1.0) * 0.5;\n  float halfAAPaddedLineLengthPixels \x3d max(extendedLineLengthPixels, 1.0) * 0.5;\n#endif\n  vec2 halfAAPaddedLineWidthAndAmplitudeNDC \x3d halfAAPaddedLineWidthAndAmplitudePixels * uPixelToNDC;\n  vec2 aaPaddedRoundedCapSizeNDC \x3d aaPaddedRoundedCapSizePixels * uPixelToNDC;\n  vec2 extensionLengthNDC \x3d extensionLengthPixels * uPixelToNDC;\n  vec2 ndcOffset \x3d (\n      screenSpaceDirection * sideness.y * (aaPaddedRoundedCapSizeNDC + extensionLengthNDC)\n    + perpendicularScreenSpaceDirection * halfAAPaddedLineWidthAndAmplitudeNDC\n  );\n  projPos.xy +\x3d ndcOffset * projPos.w;\n  projPos.z +\x3d (dzPerPixel * (aaPaddedRoundedCapSizePixels + extensionLengthPixels)) * sideness.y * projPos.w;\n  projPos \x3d adjustProjectedPosition(projPos, worldNormal, 1.0 + max((lineWidthAndAmplitudePixels - 1.0) * 0.5, 0.0));\n  float aaPaddedLineWithCapsLengthPixels \x3d extendedLineLengthPixels + aaPaddedRoundedCapSizePixels + aaPaddedRoundedCapSizePixels;\n  float pixelPositionAlongLine \x3d aaPaddedLineWithCapsLengthPixels * sidenessNorm.y - aaPaddedRoundedCapSizePixels;\n  vPosition \x3d vec3(\n    halfAAPaddedLineWidthAndAmplitudePixels * sideness.x,\n    pixelPositionAlongLine,\n    pixelPositionAlongLine / extendedLineLengthPixels\n  );\n  vRadius \x3d lineWidthPixels * 0.5;\n  vLineLengthPixels \x3d extendedLineLengthPixels;\n#ifdef SILHOUETTE\n  gl_Position \x3d isSilhouetteEdge(viewPosV0, aNormalA, aNormalB) ? projPos : vec4(10.0, 10.0, 10.0, 1.0);\n#else\n  gl_Position \x3d projPos;\n#endif\n#if (MODE \x3d\x3d MODE_UBER)\n  if (unpackedAttributes.type \x3c\x3d 0.0 \x26\x26 lineLengthPixels \x3c\x3d 3.0) {\n    gl_Position \x3d vec4(10.0, 10.0, 10.0, 1.0);\n  }\n#elif (MODE \x3d\x3d MODE_SKETCH)\n  if (lineLengthPixels \x3c\x3d 3.0) {\n    gl_Position \x3d vec4(10.0, 10.0, 10.0, 1.0);\n  }\n#endif\n  return projPos;\n}\n#if (MODE \x3d\x3d MODE_UBER)\nUnpackedAttributes unpackAttributes(ComponentData component) {\n  vec2 sidenessNorm \x3d aSideness;\n  vec2 sideness \x3d sidenessNorm * 2.0 - 1.0;\n  float fType \x3d component.type;\n  float extensionLengthPixels \x3d component.extensionLength;\n  float lineWidth \x3d component.lineWidth;\n  if (fType \x3c\x3d 0.0) {\n    extensionLengthPixels *\x3d aVariantExtension * 2.0 - 1.0;\n  }\n  return UnpackedAttributes(sideness, sidenessNorm, lineWidth, extensionLengthPixels, fType);\n}\n#else\nUnpackedAttributes unpackAttributes(ComponentData component) {\n  vec2 sidenessNorm \x3d aSideness;\n  vec2 sideness \x3d sidenessNorm * 2.0 - 1.0;\n  float extensionLengthPixels \x3d component.extensionLength;\n#if (MODE \x3d\x3d MODE_SKETCH)\n  extensionLengthPixels *\x3d aVariantExtension * 2.0 - 1.0;\n#endif\n  float lineWidth \x3d component.lineWidth;\n  return UnpackedAttributes(sideness, sidenessNorm, lineWidth, extensionLengthPixels);\n}\n#endif\nvoid main() {\n  ComponentData component \x3d readComponentData();\n  UnpackedAttributes unpackedAttributes \x3d unpackAttributes(component);\n  vec4 worldPosV0 \x3d uModel * vec4(aPosition0, 1.0);\n  vec4 worldPosV1 \x3d uModel * vec4(aPosition1, 1.0);\n  vec4 viewPosV0 \x3d uView * worldPosV0;\n  vec4 viewPosV1 \x3d uView * worldPosV1;\n#ifdef SILHOUETTE\n  vec3 worldNormal \x3d silhouetteWorldNormal(aNormalA, aNormalB);\n#else\n  vec3 worldNormal \x3d modelToWorldNormal(aNormal);\n#endif\n  vec4 projPos \x3d calculateGeometricOutputs(viewPosV0, viewPosV1, worldPosV0, worldPosV1, worldNormal, unpackedAttributes);\n  vColor \x3d component.color;\n  calculateStyleOutputs(viewPosV0, viewPosV1, worldPosV0, worldPosV1, projPos, worldNormal, unpackedAttributes);\n}",
"lineAmplitude.glsl":"#if (MODE \x3d\x3d MODE_UBER || MODE \x3d\x3d MODE_SOLID)\n  float calculateLineAmplitudeSolid() {\n    return 0.0;\n  }\n#endif\n#if (MODE \x3d\x3d MODE_SOLID)\n  float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {\n    return calculateLineAmplitudeSolid();\n  }\n#endif\n#if (MODE \x3d\x3d MODE_UBER || MODE \x3d\x3d MODE_SKETCH)\n  uniform float uStrokesAmplitude;\n  float calculateLineAmplitudeSketch() {\n    return uStrokesAmplitude;\n  }\n#endif\n#if (MODE \x3d\x3d MODE_SKETCH)\n  float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {\n    return calculateLineAmplitudeSketch();\n  }\n#endif\n#if (MODE \x3d\x3d MODE_UBER)\n  float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {\n    float type \x3d unpackedAttributes.type;\n    if (type \x3c\x3d 0.0) {\n      return calculateLineAmplitudeSketch();\n    }\n    else {\n      return calculateLineAmplitudeSolid();\n    }\n  }\n#endif",
"lineOffset.glsl":"#include \x3cutil/encoding.glsl\x3e\n#if (MODE \x3d\x3d MODE_UBER || MODE \x3d\x3d MODE_SKETCH)\n  uniform sampler2D uStrokesTexture;\n  uniform float uStrokesNormalizationScale;\n  varying vec2 vStrokeUV;\n  float calculateLineOffsetSketch() {\n    float offsetNorm \x3d rgba2float(texture2D(uStrokesTexture, vStrokeUV));\n    return (offsetNorm - 0.5) * uStrokesNormalizationScale;\n  }\n  float calculateLinePressureSketch() {\n    return rgba2float(texture2D(uStrokesTexture, vStrokeUV + vec2(0.0, 0.5)));\n  }\n#endif\n#if (MODE \x3d\x3d MODE_SKETCH)\n  float calculateLineOffset() {\n    return calculateLineOffsetSketch();\n  }\n  float calculateLinePressure() {\n    return calculateLinePressureSketch();\n  }\n#endif\n#if (MODE \x3d\x3d MODE_UBER || MODE \x3d\x3d MODE_SOLID)\n  float calculateLineOffsetSolid() {\n    return 0.0;\n  }\n  float calculateLinePressureSolid() {\n    return 1.0;\n  }\n#endif\n#if (MODE \x3d\x3d MODE_SOLID)\n  float calculateLineOffset() {\n    return calculateLineOffsetSolid();\n  }\n  float calculateLinePressure() {\n    return calculateLinePressureSolid();\n  }\n#endif\n#if (MODE \x3d\x3d MODE_UBER)\n  varying float vType;\n  float calculateLineOffset() {\n    if (vType \x3c\x3d 0.0) {\n      return calculateLineOffsetSketch();\n    }\n    else {\n      return calculateLineOffsetSolid();\n    }\n  }\n  float calculateLinePressure() {\n    if (vType \x3c\x3d 0.0) {\n      return calculateLinePressureSketch();\n    }\n    else {\n      return calculateLinePressureSolid();\n    }\n  }\n#endif",
"styleOutputs.glsl":"#if (MODE \x3d\x3d MODE_UBER || MODE \x3d\x3d MODE_SKETCH)\n  uniform vec2 uStrokesTextureScale;\n  uniform float uStrokesLog2Resolution;\n  uniform float uStrokeVariants;\n  varying vec2 vStrokeUV;\n  varying float vLineIndex;\n  void calculateStyleOutputsSketch(float lineLength, UnpackedAttributes unpackedAttributes) {\n    vec2 sidenessNorm \x3d unpackedAttributes.sidenessNorm;\n    float lineIndex \x3d clamp(ceil(log2(lineLength)), 0.0, uStrokesLog2Resolution);\n    vStrokeUV \x3d vec2(exp2(lineIndex) * sidenessNorm.y, lineIndex * uStrokeVariants + aVariantStroke + 0.5) * uStrokesTextureScale;\n    vStrokeUV.x +\x3d aVariantOffset;\n    vLineIndex \x3d lineIndex;\n  }\n#endif\n#if (MODE \x3d\x3d MODE_SOLID)\n  void calculateStyleOutputs(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec4 projPos, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\n  }\n#elif (MODE \x3d\x3d MODE_SKETCH)\n  void calculateStyleOutputs(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec4 projPos, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\n    calculateStyleOutputsSketch(vLineLengthPixels, unpackedAttributes);\n  }\n#elif (MODE \x3d\x3d MODE_UBER)\n  varying float vType;\n  void calculateStyleOutputs(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec4 projPos, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\n    vType \x3d unpackedAttributes.type;\n    if (unpackedAttributes.type \x3c\x3d 0.0) {\n      calculateStyleOutputsSketch(vLineLengthPixels, unpackedAttributes);\n    }\n  }\n#endif",
"util.glsl":"uniform float uDistanceFalloffFactor;\nfloat distanceBasedPerspectiveFactor(float distance) {\n  return clamp(sqrt(uDistanceFalloffFactor / distance), 0.0, 1.0);\n}\nuniform sampler2D uComponentDataTex;\nuniform vec2 uComponentDataTexInvDim;\nattribute float aComponentIndex;\n#define COMPONENT_COLOR_FIELD_OFFSET 0.0\n#define COMPONENT_OTHER_FIELDS_OFFSET 1.0\n#define COMPONENT_FIELD_COUNT 2.0\n#define LINE_WIDTH_FRACTION_FACTOR 8.0\n#define EXTENSION_LENGTH_OFFSET 128.0\n#define COMPONENT_TEX_WIDTH 4096.0\nvec2 componentTextureCoords(float componentIndex, float fieldOffset) {\n  float fieldIndex \x3d COMPONENT_FIELD_COUNT * componentIndex + fieldOffset;\n  float rowIndex \x3d floor(fieldIndex / COMPONENT_TEX_WIDTH);\n  float colIndex \x3d mod(fieldIndex, COMPONENT_TEX_WIDTH);\n  vec2 linearIndex \x3d vec2(\n    (colIndex + 0.5) / COMPONENT_TEX_WIDTH,\n    (rowIndex + 0.5) * uComponentDataTexInvDim.y\n  );\n  return linearIndex;\n}\nstruct ComponentData {\n  vec4 color;\n  float lineWidth;\n  float extensionLength;\n  float type;\n};\nComponentData readComponentData() {\n  vec2 colorIndex \x3d componentTextureCoords(aComponentIndex, COMPONENT_COLOR_FIELD_OFFSET);\n  vec2 otherIndex \x3d componentTextureCoords(aComponentIndex, COMPONENT_OTHER_FIELDS_OFFSET);\n  vec4 colorValue \x3d texture2D(uComponentDataTex, colorIndex);\n  vec4 otherValue \x3d texture2D(uComponentDataTex, otherIndex);\n  return ComponentData(\n    vec4(colorValue.rgb, colorValue.a * otherValue.w),\n    otherValue.x * (255.0 / LINE_WIDTH_FRACTION_FACTOR),\n    otherValue.y * 255.0 - EXTENSION_LENGTH_OFFSET,\n    -(otherValue.z * 255.0) + 0.5\n  );\n}\nvec3 modelToWorldNormal(vec3 normal) {\n  return (uModel * vec4(normal, 0.0)).xyz;\n}\nvec3 silhouetteWorldNormal(vec3 normalA, vec3 normalB) {\n  return modelToWorldNormal(normalize(normalA + normalB));\n}\nfloat calculateExtensionLength(float extensionLength, float lineLength) {\n  return extensionLength / (log2(max(1.0, 256.0 / lineLength)) * 0.2 + 1.0);\n}\n#ifdef SILHOUETTE\nbool isSilhouetteEdge(vec4 viewPos, vec3 normalA, vec3 normalB) {\n  vec3 viewNormalA \x3d (uView * uModel * vec4(normalA, 0.0)).xyz;\n  vec3 viewNormalB \x3d (uView * uModel * vec4(normalB, 0.0)).xyz;\n  vec3 viewDir \x3d -viewPos.xyz;\n  float faceAVisible \x3d dot(viewDir, viewNormalA);\n  float faceBVisible \x3d dot(viewDir, viewNormalB);\n  return faceAVisible * faceBVisible \x3c 0.0;\n}\n#endif"},
environment:{"realisticAtmosphere.frag":"#include \x3cutil/fsPrecision.glsl\x3e\n#include \x3cutil/encoding.glsl\x3e\n#include \x3cutil/color.glsl\x3e\nuniform vec3 v3LightDir;\nuniform vec3 v3InvWavelength;\nuniform vec3 v3InvWavelengthScaled;\nconst float fKrESun \x3d 0.075;\nconst float fKmESun \x3d 0.015;\nuniform vec4 v4Radii;\n#define fInnerRadius v4Radii[0]\n#define fInnerRadius2 v4Radii[1]\n#define fOuterRadius v4Radii[2]\n#define fOuterRadius2 v4Radii[3]\nuniform vec4 v4AtmosParams1;\nuniform vec4 v4AtmosParams2;\n#define fScale v4AtmosParams1.x\n#define v2ScaleDepth vec2(v4AtmosParams1.y,v4AtmosParams2.y)\n#define v2ScaleOverScaleDepth vec2(v4AtmosParams1.z,v4AtmosParams2.z)\n#define v2OneOverScaleDepth vec2(v4AtmosParams1.w,v4AtmosParams2.w)\n#ifndef HAZE\nuniform vec4 v4AtmosParams3;\nuniform float fInnerFadeDistance;\nuniform float fAltitudeFade;\n#define fg v4AtmosParams2.x\n#define fg2 v4AtmosParams3.x\n#define fMiePhaseCoefficients v4AtmosParams3.y\n#define fLowerAlphaBlendBound v4AtmosParams3.z\n#define fOneOverOuterRadiusMinusAlphaBlendBound v4AtmosParams3.w\n#endif\nuniform vec3 v3CameraPos;\nuniform vec2 nearFar;\nuniform vec4 v4SphereComp;\n#define fCameraHeight v4SphereComp[0]\n#define fCameraHeight2 v4SphereComp[1]\n#define fC v4SphereComp[2]\n#define fCSur v4SphereComp[3]\n#ifdef HAZE\nconst float fExposure \x3d 1.5;\n#else\nconst float fExposure \x3d 2.0;\n#endif\n#ifdef HAZE\nuniform sampler2D tDepth;\n#endif\nuniform float showTest;\nvarying vec3 v3EyeDir;\nvarying vec3 v3WorldRay;\nvarying vec2 vtc;\nconst float fSamples \x3d 5.0;\nconst int maxSamples \x3d 5;\n#ifdef HAZE\n  const float fOneOverGamma \x3d 1.0;\n#else\n  const float fOneOverGamma \x3d 0.454545;\n#endif\nconst vec3 v3OneOverGamma \x3d vec3(fOneOverGamma);\nvec3 expTM(vec3 inputColor,float exposure){\n    return pow(1.0 - exp(inputColor * -exposure), v3OneOverGamma);\n}\n#ifndef HAZE\nvec3 reinhardTM(vec3 inputColor, float exposure){\n  vec3 intermediate \x3d inputColor *exposure;\n  intermediate /\x3d (1.0+intermediate);\n  return pow(intermediate, v3OneOverGamma);\n}\n#endif\nfloat scale(float fCos){\n  float x \x3d 1.0 - fCos;\n  return exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\nvoid main() {\n  vec3 cameraPosition \x3d v3CameraPos;\n  vec3 test \x3d vec3(0.0,0.0,0.0);\n  vec3 worldSpaceRay \x3d normalize(v3WorldRay);\n  float B \x3d 2.0 * dot(cameraPosition, worldSpaceRay);\n  float det \x3d B*B - 4.0 * fC;\n  float detSur \x3d B*B - 4.0 * fCSur;\n  float fMinRayStart \x3d 0.0;\n#ifndef HAZE\n  float fSurfaceBlend \x3d 0.0;\n  vec4 surfaceColor \x3d vec4(0.0);\n  if (detSur \x3e\x3d 0.0) {\n    float nearSurfaceT \x3d max(0.0, 0.5 *(-B - sqrt(detSur)));\n    float farSurfaceT \x3d max(0.0, 0.5 *(-B + sqrt(detSur)));\n    if (nearSurfaceT \x3d\x3d 0.0) {\n      fMinRayStart \x3d farSurfaceT;\n    }\n    vec3 vPos \x3d cameraPosition + worldSpaceRay * nearSurfaceT;\n    float fLightAngle \x3d dot(v3LightDir, normalize(vPos));\n    float fBrightness \x3d max(0.0, (smoothstep(-1.0, 0.8, 2.0 * fLightAngle)));\n    surfaceColor \x3d vec4(fBrightness, fBrightness, fBrightness, 1.0 - fAltitudeFade);\n    float fRelDist \x3d (farSurfaceT - nearSurfaceT) / fInnerFadeDistance;\n    if (fRelDist \x3e 1.0) {\n      gl_FragColor \x3d surfaceColor;\n      return;\n    }\n    fSurfaceBlend \x3d smoothstep(0.0, 1.0, fRelDist * fRelDist);\n  }\n#endif\n  if (det \x3e\x3d 0.0) {\n#ifdef HAZE\n    float depthSample \x3d texture2D(tDepth, vtc).r;\n    float zNear \x3d nearFar[0];\n    float zFar \x3d nearFar[1];\n    float zNorm \x3d 2.0 * depthSample - 1.0;\n    float linDepth \x3d 2.0 * zNear * zFar /\n      (zFar + zNear - zNorm * (zFar - zNear));\n    float rayEndT;\n    float altitudeAlpha \x3d 1.0;\n    if (depthSample \x3c 1.0 \x26\x26 depthSample \x3e 0.0) {\n      vec3 cameraSpaceRay \x3d normalize(v3EyeDir);\n      cameraSpaceRay /\x3d cameraSpaceRay.z;\n      cameraSpaceRay *\x3d linDepth;\n      float cameraSpaceRayLength \x3d length(cameraSpaceRay);\n      vec3 v3World \x3d cameraPosition + worldSpaceRay * cameraSpaceRayLength;\n      float v3WorldRadius2 \x3d dot(v3World, v3World);\n      float transitionStart \x3d fInnerRadius + 20000.0;\n      float transitionHeight \x3d 25000.0;\n      float transitionEnd \x3d transitionStart + transitionHeight;\n      float edge0 \x3d transitionStart * transitionStart;\n      float edge1 \x3d transitionEnd * transitionEnd;\n      altitudeAlpha \x3d 1.0 - clamp((v3WorldRadius2 - edge0) / (edge1 - edge0), 0.0, 1.0);\n      rayEndT \x3d cameraSpaceRayLength;\n      if (altitudeAlpha \x3e 0.0 \x26\x26 detSur \x3e 0.0) {\n        float nearSurfaceT \x3d 0.5 *(-B - sqrt(detSur));\n        float interp \x3d clamp(((fCameraHeight - fInnerRadius) - 2000000.0) / 6000000.0, 0.0, 1.0);\n        rayEndT \x3d mix(cameraSpaceRayLength, nearSurfaceT, interp);\n      }\n    }\n#endif\n    float rayStartT \x3d 0.5 *(-B - sqrt(det));\n#ifdef HAZE\n    float nearT \x3d abs(rayStartT);\n    float farT \x3d abs(rayEndT);\n#else\n    float rayEndT \x3d 0.5 *(-B + sqrt(det));\n#endif\n    float fDistance;\n    if (rayStartT \x3c fMinRayStart)\n    {\n      rayStartT \x3d fMinRayStart;\n#ifndef HAZE\n      fDistance \x3d fScale * min(0.0, fInnerRadius - fCameraHeight);\n#endif\n    }\n#ifndef HAZE\n    else\n    {\n      fDistance \x3d -1.0;\n    }\n#endif\n    vec3 v3Start \x3d cameraPosition + worldSpaceRay * rayStartT;\n#ifdef HAZE\n    vec3 v3End \x3d cameraPosition + worldSpaceRay * rayEndT;\n    float fEndLength \x3d length(v3End);\n    float fAltitudeEnd \x3d fEndLength - fInnerRadius;\n    float fAltitudeStart \x3d length(v3Start) - fInnerRadius;\n    if (fAltitudeStart \x3c 0.0) {\n      fAltitudeStart \x3d -fAltitudeStart;\n      fAltitudeEnd \x3d -fAltitudeEnd;\n    }\n    float fLightAngle \x3d dot(v3LightDir, v3End) / fEndLength;\n    if (nearT \x3e farT)\n    {\n      if (fAltitudeStart \x3c fAltitudeEnd)\n      {\n        v3End \x3d cameraPosition + worldSpaceRay * rayStartT;\n        v3Start \x3d cameraPosition + worldSpaceRay * rayEndT;\n        worldSpaceRay *\x3d -1.0;\n        float fTmp \x3d fAltitudeStart;\n        fAltitudeStart \x3d fAltitudeEnd;\n        fAltitudeEnd \x3d fTmp;\n      }\n      else if (fAltitudeStart \x3d\x3d fAltitudeEnd)\n      {\n        fAltitudeStart +\x3d 1.0;\n      }\n    }\n    float fCameraDepth;\n    float fCameraDepthBlue;\n    if (fAltitudeStart \x3e fOuterRadius - fInnerRadius)\n    {\n      fDistance \x3d fInnerRadius - fOuterRadius;\n    } else\n    {\n      fDistance \x3d fAltitudeEnd - fAltitudeStart;\n    }\n#endif\n    vec2 v2OpticalStartDepth \x3d exp(fDistance * v2OneOverScaleDepth);\n    float fRayLength \x3d rayEndT - rayStartT;\n    float fSampleLength \x3d fRayLength / fSamples;\n    float fScaledLength \x3d fSampleLength * fScale;\n    vec3 v3SampleRay \x3d worldSpaceRay * fSampleLength;\n    vec3 v3SamplePoint \x3d v3Start + v3SampleRay * 0.5;\n#ifdef HAZE\n    float fCameraAngle \x3d dot(-worldSpaceRay, v3End) / length(v3End);\n    float fScaleCameraAngle \x3d scale(fCameraAngle);\n    vec2 v2CameraOffset \x3d fScaleCameraAngle*v2OpticalStartDepth;\n    float scaledValues \x3d scale(fLightAngle) + fScaleCameraAngle;\n    vec2 v2ScaledValuesDepth \x3d scaledValues * v2ScaleDepth;\n#else\n    float fCameraAngle \x3d dot(worldSpaceRay, v3Start / length(v3Start));\n    float angleMultiplier \x3d fCameraAngle\x3e0.0?fCameraAngle:0.0;\n    float fScaleCameraAngle \x3d scale(fCameraAngle);\n    vec2 v2CameraOffset \x3d fScaleCameraAngle*v2OpticalStartDepth * v2ScaleDepth;\n#endif\n    vec3 v3FrontColor \x3d vec3(0.0, 0.0, 0.0);\n    vec3 v3FrontColorBlue \x3d vec3(0.0, 0.0, 0.0);\n    vec3 v3Attenuate\x3d vec3(0.0, 0.0, 0.0);\n    vec3 v3AttenuateBlue \x3d vec3(0.0, 0.0, 0.0);\n    for(int i\x3d0; i\x3cmaxSamples; i++) {\n      float fHeight \x3d length(v3SamplePoint);\n      float fAltitude \x3d abs(fHeight - fInnerRadius);\n      vec2 v2Depth \x3d exp(-fAltitude * v2ScaleOverScaleDepth);\n#ifdef HAZE\n      vec2 v2Scatter \x3d v2Depth*v2ScaledValuesDepth-v2CameraOffset;\n#else\n      float fLightAngle \x3d dot(v3LightDir, v3SamplePoint) / fHeight;\n      float fCameraAngle \x3d dot(worldSpaceRay, v3SamplePoint) / fHeight;\n      float fTempScaledValues \x3d scale(fLightAngle) - scale(fCameraAngle);\n      vec2 v2Scatter \x3d v2CameraOffset + fTempScaledValues*v2Depth* v2ScaleDepth;\n#endif\n      v3Attenuate \x3d exp(-v2Scatter.x * v3InvWavelengthScaled);\n      v3AttenuateBlue \x3d exp(-v2Scatter.y * v3InvWavelengthScaled);\n      v3FrontColor +\x3d v3Attenuate * v2Depth.x;\n      v3FrontColorBlue +\x3d v3AttenuateBlue * v2Depth.y;\n      v3SamplePoint +\x3d v3SampleRay;\n    }\n    float fCos \x3d clamp(dot(v3LightDir, -worldSpaceRay ),-0.9999999,1.0);\n    float fOnePlusCos2 \x3d fCos*fCos + 1.0;\n#ifdef HAZE\n    vec3 colorCoefficients \x3d (fScaledLength* 0.75 * fOnePlusCos2)*(fKrESun*v3InvWavelength+fKmESun);\n    vec3 v3Color \x3d colorCoefficients *v3FrontColor;\n    vec3 v3ColorBlue \x3d colorCoefficients *v3FrontColorBlue;\n#else\n    vec3 v3RayleighCoefficients \x3d (fScaledLength*0.75 * fOnePlusCos2*fKrESun)*v3InvWavelength;\n    float fMieCoefficients \x3d fScaledLength*fKmESun * fMiePhaseCoefficients * fOnePlusCos2 / pow(1.0 + fg2 - 2.0*fg*fCos, 1.5);\n    vec3 v3Color \x3d v3RayleighCoefficients * v3FrontColor + fMieCoefficients * v3FrontColor;\n    vec3 v3ColorBlue \x3d v3RayleighCoefficients * v3FrontColorBlue + fMieCoefficients * v3FrontColorBlue;\n#endif\n    vec3 ldrBlue \x3d expTM(v3ColorBlue,2.0*fExposure);\n    vec3 ldrRed \x3d expTM(v3Color,fExposure);\n    vec3 LDR \x3d mix(ldrBlue,ldrRed,0.2);\n#ifdef HAZE\n    LDR *\x3d (1.0-fCameraAngle);\n    vec3 hsv \x3d rgb2hsv(LDR);\n    hsv.y \x3d clamp(hsv.y*1.5,0.0,1.0);\n    LDR \x3d hsv2rgb(hsv);\n    vec3 finalColor \x3d LDR;\n#else\n    vec3 ldrReinhard \x3d reinhardTM(v3Color,fExposure);\n    LDR +\x3d angleMultiplier*ldrReinhard;\n    float side \x3d (rayEndT+rayStartT)*0.5;\n    float atmoHeight \x3d sqrt(fCameraHeight2 - side*side);\n    float h2 \x3d clamp(1.0-(atmoHeight-fLowerAlphaBlendBound)/(fOuterRadius-fLowerAlphaBlendBound),0.0,1.0);\n    vec3 finalColor \x3d LDR*h2;\n    vec3 hsv \x3d rgb2hsv(finalColor);\n    hsv.y \x3d clamp(hsv.y*1.5,0.0,1.0);\n    finalColor \x3d hsv2rgb(hsv);\n#endif\n#ifndef HAZE\n    float atmosStrength \x3d clamp((length(ldrRed)-0.05)*1.05,0.0,1.0);\n    gl_FragColor \x3d vec4(finalColor, atmosStrength*clamp(1.0-(atmoHeight-fInnerRadius)/(fOuterRadius-fInnerRadius),0.0,1.0));\n    if (fSurfaceBlend \x3e 0.0) {\n      gl_FragColor \x3d mix(gl_FragColor, surfaceColor, fSurfaceBlend);\n    }\n#else\n    gl_FragColor \x3d vec4(finalColor, 1.0) * altitudeAlpha;\n#endif\n    if(showTest\x3e0.0){\n      gl_FragColor \x3d vec4(test,1.0);\n    }\n  } else {\n    gl_FragColor \x3d vec4(0.0);\n  }\n}",
"realisticAtmosphere.vert":"#include \x3cutil/vsPrecision.glsl\x3e\nuniform vec2 halfSizeNearPlane;\nuniform vec3 v3CameraUp;\nuniform vec3 v3CameraRight;\nuniform vec3 v3CameraDir;\nuniform vec2 v2CameraCenterOffset;\nattribute vec3 position;\nattribute vec2 uv0;\nvarying vec3 v3WorldRay;\nvarying vec2 vtc;\n#ifdef HAZE\nvarying vec3 v3EyeDir;\n#endif\nvoid main(void) {\n  vec3 v3Pos \x3d position;\n  vtc \x3d uv0;\n  vec2 rayvtc \x3d uv0 - v2CameraCenterOffset;\n#ifdef HAZE\n  v3EyeDir \x3d vec3((2.0*halfSizeNearPlane *rayvtc)-halfSizeNearPlane,-1.0);\n#else\n  vec3 v3EyeDir \x3d vec3((2.0*halfSizeNearPlane *rayvtc)-halfSizeNearPlane,-1.0);\n#endif\n  v3WorldRay \x3d v3EyeDir.z*v3CameraDir + v3EyeDir.y*v3CameraUp + v3EyeDir.x*v3CameraRight;\n  gl_Position \x3d vec4(v3Pos, 1.0);\n}",
"simpleAtmosphere.frag":"#include \x3cutil/fsPrecision.glsl\x3e\nuniform sampler2D tex;\nvarying vec2 vtc;\nvarying float falloff;\n#ifndef PANORAMIC\nuniform float altitudeFade;\nvarying float innerFactor;\n#endif\nvoid main() {\n  vec4 texColor \x3d texture2D(tex, vtc);\n#ifdef PANORAMIC\n  gl_FragColor \x3d texColor * falloff;\n#else\n  vec4 atmosphereColor \x3d texColor * falloff;\n  vec4 innerColor \x3d vec4(texColor.rgb * falloff, 1.0 - altitudeFade);\n  gl_FragColor \x3d mix(atmosphereColor, innerColor, smoothstep(0.0, 1.0, innerFactor));\n#endif\n}",
"simpleAtmosphere.vert":"#include \x3cutil/vsPrecision.glsl\x3e\nuniform mat4 proj;\nuniform mat4 view;\n#ifndef PANORAMIC\nconst float TWICEPI \x3d 2.0*3.14159265;\nconst float ATMOSPHERE_RIM_SEGMENTS \x3d 128.0;\nuniform vec3 silCircleCenter;\nuniform vec3 silCircleV1;\nuniform vec3 silCircleV2;\nuniform vec2 texV;\nuniform float innerScale;\nvarying float innerFactor;\n#endif\nuniform vec3 lightDirection;\nattribute vec3 position;\nvarying vec2 vtc;\nvarying float falloff;\nvoid main(void) {\n#ifdef PANORAMIC\n  vec3 pos \x3d position;\n  float ndotl \x3d lightDirection.z;\n  vtc \x3d vec2(0.0, position.z+0.05);\n#else\n  innerFactor \x3d clamp(-position.z, 0.0, 1.0);\n  float scale \x3d position.y * (1.0 + innerFactor * innerScale);\n  float phi \x3d position.x * (TWICEPI / ATMOSPHERE_RIM_SEGMENTS) + 1.0;\n  vec3 pos \x3d  (silCircleCenter + sin(phi) * silCircleV1 + cos(phi) * silCircleV2) * scale;\n  float ndotl \x3d dot(normalize(position.y \x3e 0.0 ? pos: silCircleCenter), lightDirection);\n  vtc.x \x3d position.x / ATMOSPHERE_RIM_SEGMENTS;\n  vtc.y \x3d texV.x * (1.0 - position.z) + texV.y * position.z;\n#endif\n  falloff \x3d max(0.0, smoothstep(-1.0, 0.8, 2.0 * ndotl));\n  gl_Position \x3d proj * view * vec4(pos, 1.0);\n  gl_Position.z \x3d gl_Position.w;\n}",
"simpleAtmosphereFade.frag":"#include \x3cutil/fsPrecision.glsl\x3e\nvarying vec4 color;\nvoid main() {\n  gl_FragColor \x3d color;\n}","simpleAtmosphereFade.vert":"#include \x3cutil/vsPrecision.glsl\x3e\nattribute vec2 position;\nuniform vec3 lightDirection;\nuniform vec3 cameraPosition;\nuniform float undergroundFadeAlpha;\nvarying vec4 color;\nvoid main(void) {\n  float ndotl \x3d dot(normalize(cameraPosition), lightDirection);\n  float lighting \x3d max(0.0, smoothstep(-1.0, 0.8, 2.0 * ndotl));\n  color \x3d vec4(vec3(lighting), undergroundFadeAlpha);\n  gl_Position \x3d vec4(position.xy, 1.0, 1.0);\n}",
"stars.frag":"#include \x3cutil/fsPrecision.glsl\x3e\nvarying vec4 vcolor;\nvarying float vsize;\nvoid main() {\n  float cap \x3d 0.7;\n  float scale \x3d 1.0/cap;\n  float helper \x3d clamp(length(abs(gl_PointCoord-vec2(0.5))),0.0,cap);\n  float alpha \x3d clamp((cap-helper)*scale,0.0,1.0);\n  float intensity \x3d alpha*alpha*alpha;\n  if (vsize \x3c 3.0)\n    intensity *\x3d 0.5;\n  gl_FragColor \x3d vec4(1.0,1.0,1.0,intensity);\n  gl_FragColor.xyz *\x3d vcolor.xyz;\n}","stars.vert":"#include \x3cutil/vsPrecision.glsl\x3e\n#include \x3cutil/alignPixel.glsl\x3e\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nuniform vec4 viewport;\nuniform float pixelRatio;\nattribute vec3 position;\nattribute vec4 color;\nattribute float size;\nvarying vec4 vcolor;\nvarying float vsize;\nvoid main(void) {\n  vec4 posProj \x3d proj * view * model*vec4(position*1.0e25,1.0);\n  gl_Position \x3d alignToPixelCenter(posProj, viewport.zw);\n  gl_Position.z \x3d gl_Position.w;\n  vcolor \x3d color / 1.2;\n  vsize \x3d size * 5.0 * pixelRatio;\n  gl_PointSize \x3d vsize;\n}"},
materials:{checkerBoard:{"checkerBoard.frag":"#include \x3cutil/enableExtensions.glsl\x3e\n#include \x3cutil/fsPrecision.glsl\x3e\nuniform vec2 size;\nuniform vec4 color1;\nuniform vec4 color2;\nvarying vec2 vUV;\nvoid main() {\n  vec2 uvScaled \x3d vUV / (2.0 * size);\n  vec2 uv \x3d fract(uvScaled - 0.25);\n  vec2 ab \x3d clamp((abs(uv - 0.5) - 0.25) / fwidth(uvScaled), -0.5, 0.5);\n  float fade \x3d smoothstep(0.25, 0.5, max(fwidth(uvScaled.x), fwidth(uvScaled.y)));\n  float t \x3d mix(abs(ab.x + ab.y), 0.5, fade);\n  gl_FragColor \x3d mix(color2, color1, t);\n}",
"checkerBoard.vert":"#include \x3cutil/vsPrecision.glsl\x3e\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nattribute vec3 position;\nattribute vec2 uv0;\nvarying vec2 vUV;\nvoid main(void) {\n  vUV \x3d uv0;\n  gl_Position \x3d proj * view * vec4((model * vec4(position, 1.0)).xyz, 1.0);\n}"},color:{"color.frag":"#include \x3cutil/enableExtensions.glsl\x3e\n#include \x3cutil/fsPrecision.glsl\x3e\n#include \x3cutil/slice.glsl\x3e\nuniform vec4 eColor;\n#ifdef VERTEX_COLORS\nvarying vec4 vColor;\n#endif\nvarying vec3 vpos;\nvoid main() {\n  discardBySlice(vpos);\n#ifdef VERTEX_COLORS\n  gl_FragColor \x3d vColor * eColor;\n#else\n  gl_FragColor \x3d eColor;\n#endif\n  gl_FragColor \x3d highlightSlice(gl_FragColor, vpos);\n}",
"color.vert":"#include \x3cutil/vsPrecision.glsl\x3e\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nattribute vec3 position;\n#ifdef VERTEX_COLORS\nattribute vec4 color;\nvarying vec4 vColor;\n#endif\nvarying vec3 vpos;\nvoid main(void) {\n#ifdef VERTEX_COLORS\n  vColor \x3d color * 0.003921568627451;\n#endif\n  vpos \x3d (model * vec4(position, 1.0)).xyz;\n  gl_Position \x3d proj * view * vec4(vpos, 1.0);\n}"},defaultMaterial:{"colorMixMode.glsl":"#include \x3cutil/color.glsl\x3e\nvec4 decodeSymbolColor(vec4 symbolColor, out int colorMixMode) {\n  float symbolAlpha \x3d 0.0;\n  const float maxTint \x3d 85.0;\n  const float maxReplace \x3d 170.0;\n  const float scaleAlpha \x3d 3.0;\n  if (symbolColor.a \x3e maxReplace) {\n    colorMixMode \x3d 1;\n    symbolAlpha \x3d scaleAlpha * (symbolColor.a - maxReplace);\n  } else if (symbolColor.a \x3e maxTint) {\n    colorMixMode \x3d 3;\n    symbolAlpha \x3d scaleAlpha * (symbolColor.a - maxTint);\n  } else if (symbolColor.a \x3e 0.0) {\n    colorMixMode \x3d 0;\n    symbolAlpha \x3d scaleAlpha * symbolColor.a;\n  } else {\n    colorMixMode \x3d 1;\n    symbolAlpha \x3d 0.0;\n  }\n  return vec4(symbolColor.r, symbolColor.g, symbolColor.b, symbolAlpha);\n}\nvec3 mixExternalColor(vec3 internalColor, vec3 textureColor, vec3 externalColor, int mode) {\n  vec3 internalMixed \x3d internalColor * textureColor;\n  vec3 allMixed \x3d internalMixed * externalColor;\n  if (mode \x3d\x3d 1 ) {\n    return allMixed;\n  }\n  else if (mode \x3d\x3d 2  ) {\n    return internalMixed;\n  }\n  else if (mode \x3d\x3d 3  ) {\n    return externalColor;\n  }\n  else {\n    vec3 hsvIn \x3d rgb2hsv(internalMixed);\n    vec3 hsvTint \x3d rgb2hsv(externalColor);\n    vec3 hsvOut \x3d vec3(hsvTint.x, hsvTint.y, hsvIn.z * hsvTint.z);\n    return hsv2rgb(hsvOut);\n  }\n}\nfloat mixExternalOpacity(float internalOpacity, float textureOpacity, float externalOpacity, int mode) {\n  float internalMixed \x3d internalOpacity * textureOpacity;\n  float allMixed \x3d internalMixed * externalOpacity;\n  if (mode \x3d\x3d 2  ) {\n    return internalMixed;\n  }\n  else if (mode \x3d\x3d 3  ) {\n    return externalOpacity;\n  }\n  else {\n    return allMixed;\n  }\n}",
"colorPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\n#include \x3cutil/fsPrecision.glsl\x3e\n#include \x3cutil/slice.glsl\x3e\n#include \x3cutil/sceneLighting.glsl\x3e\n#include \x3cmaterials/defaultMaterial/texturingInputs.glsl\x3e\n#define FRAGMENT_SHADER\n#include \x3cmaterials/defaultMaterial/vertexTangents.glsl\x3e\n#include \x3cmaterials/defaultMaterial/textureNormals.glsl\x3e\nuniform vec3 camPos;\nuniform vec3 localOrigin;\nuniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 specular;\nuniform float opacity;\nuniform float layerOpacity;\n#if defined(SYMBOLVERTEXCOLORS) || defined(COMPONENTCOLORS)\nvarying mediump float colorMixMode;\n#else\nuniform int colorMixMode;\n#endif\n#ifdef RECEIVE_SHADOWS\nuniform sampler2D depthTex;\nuniform int shadowMapNum;\nuniform vec4 shadowMapDistance;\nuniform mat4 shadowMapMatrix[4];\nuniform float depthHalfPixelSz;\n#endif\n#ifdef RECEIVE_SSAO\nuniform sampler2D ssaoTex;\nuniform vec4 viewportPixelSz;\n#endif\nvarying vec3 vpos;\nvarying vec3 localvpos;\n#if (NORMALS \x3d\x3d NORMALS_COMPRESSED) || (NORMALS \x3d\x3d NORMALS_DEFAULT)\n  varying vec3 vnormal;\n#endif\n#if defined(VERTEXCOLORS)\nvarying vec4 vcolor;\n#endif\nvarying vec4 vcolorExt;\n#ifdef RECEIVE_SHADOWS\nvarying float linearDepth;\n#include \x3cutil/shadow.glsl\x3e\n#endif\n#ifdef TREE_RENDERING\n  uniform mat4 view;\n#endif\n#ifdef USE_PBR\n    uniform float roughnessFactor;\n    uniform float metalnessFactor;\n    uniform vec3 emissionFactor;\n  #ifdef PBR_TEX_METALLNESS_ROUGHNESS\n    uniform sampler2D texMetallicRoughness;\n  #endif\n  #ifdef PBR_TEX_EMISSION\n    uniform sampler2D texEmission;\n  #endif\n  #ifdef PBR_TEX_OCCLUSION\n    uniform sampler2D texOcclusion;\n  #endif\n#endif\n#ifdef TEXTURING\n#include \x3cmaterials/defaultMaterial/texturing.glsl\x3e\n#endif\n#include \x3cmaterials/defaultMaterial/colorMixMode.glsl\x3e\nvoid main() {\n  discardBySlice(vpos);\n#if defined(TEXTURING) \x26\x26 defined(TEXTURE_COLOR)\n  vec4 texColor \x3d textureLookup(tex, vtc);\n  #if defined(TEXTURE_ALPHA_PREMULTIPLIED)\n    texColor.rgb /\x3d texColor.a;\n  #endif\n  discardOrAdjustTextureAlpha(texColor);\n#else\n  vec4 texColor \x3d vec4(1.0);\n#endif\n  vec3 viewDir \x3d vpos - camPos;\n#ifdef GROUND_NORMAL_SHADING\n  #if VIEWING_MODE \x3d\x3d VIEWING_MODE_GLOBAL\n    vec3 normal \x3d normalize(vpos + localOrigin);\n  #else\n    vec3 normal \x3d vec3(0.0, 0.0, 1.0);\n  #endif\n#else\n  #if (NORMALS \x3d\x3d NORMALS_SCREEN_DERIVATIVE)\n    vec3 normal \x3d normalize(cross(dFdx(localvpos),dFdy(localvpos)));\n  #else\n    #ifdef DOUBLESIDED\n      vec3 normal \x3d dot(vnormal, viewDir)\x3e0.0 ? -vnormal : vnormal;\n    #elif defined(WINDINGORDERDOUBLESIDED)\n      vec3 normal \x3d gl_FrontFacing ? vnormal : -vnormal;\n    #else\n      vec3 normal \x3d vnormal;\n    #endif\n    normal \x3d normalize(normal);\n  #endif\n#endif\n#ifdef USE_PBR\n    float roughness \x3d roughnessFactor;\n    float metalness \x3d metalnessFactor;\n  #ifdef PBR_TEX_METALLNESS_ROUGHNESS\n    vec3 metalicRoughness \x3d texture2D(texMetallicRoughness, vtc).rgb;\n    roughness *\x3d metalicRoughness.g ;\n    metalness *\x3d metalicRoughness.b ;\n  #endif\n    vec3 emission \x3d emissionFactor;\n  #ifdef PBR_TEX_EMISSION\n    emission *\x3d texture2D(texEmission, vtc).rgb;\n  #endif\n    float bakedOcclusion \x3d 1.0;\n  #ifdef PBR_TEX_OCCLUSION\n    bakedOcclusion *\x3d texture2D(texOcclusion, vtc).r;\n  #endif\n#endif\n#ifdef RECEIVE_SSAO\n  float ssao \x3d texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n  ssao \x3d viewportPixelSz.z \x3c 0.0 ? 1.0 : ssao;\n#else\n  float ssao \x3d 1.0;\n#endif\n#ifdef USE_PBR\n  ssao *\x3d bakedOcclusion;\n#endif\n  float additionalAmbientScale;\n  vec3 additionalLight \x3d sceneLightingAdditionalLightGlobal(vpos + localOrigin, ssao, additionalAmbientScale);\n  float shadow \x3d 0.0;\n#ifdef RECEIVE_SHADOWS\n  shadow \x3d evalShadow(vpos, linearDepth, depthTex, shadowMapNum, shadowMapDistance, shadowMapMatrix, depthHalfPixelSz);\n#elif VIEWING_MODE \x3d\x3d VIEWING_MODE_GLOBAL\n  shadow \x3d lightingGlobalFactor * (1.0 - additionalAmbientScale);\n#endif\n  vec3 matColor \x3d max(ambient, diffuse);\n#if defined(VERTEXCOLORS)\n  vec3 albedo_ \x3d mixExternalColor(vcolor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n  float opacity_ \x3d layerOpacity * mixExternalOpacity(vcolor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n#else\n  vec3 albedo_ \x3d mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n  float opacity_ \x3d layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n#endif\n  #if defined(TEXTURE_NORMALS)\n    #ifdef VERTEX_TANGENTS\n      mat3 tangentSpace \x3d computeTangentSpace(normal);\n    #else\n      mat3 tangentSpace \x3d computeTangentSpace(normal, vpos, vtc);\n    #endif\n    vec3 shadingNormal \x3d computeTextureNormal(tangentSpace);\n  #else\n    vec3 shadingNormal \x3d normal;\n  #endif\n  #ifdef TREE_RENDERING\n    shadingNormal \x3d normalize(vnormal);\n    albedo_ *\x3d 1.2;\n    vec3 viewForward \x3d - vec3(view[0][2], view[1][2], view[2][2]);\n    float alignmentLightView \x3d clamp(dot(-viewForward, lightingMainDirection), 0.0, 1.0);\n    float transmittance \x3d 1.0 - clamp(dot(-viewForward, shadingNormal), 0.0, 1.0);\n    float treeRadialFalloff \x3d vcolor.r;\n    float backLightFactor \x3d 0.5 * treeRadialFalloff * alignmentLightView * transmittance * (1.0 - shadow);\n    additionalLight +\x3d backLightFactor * lightingMainIntensity;\n  #endif\n  #ifdef USE_PBR\n    vec3 normalGround \x3d normalize(vpos + localOrigin);\n    vec3 shadedColor \x3d evaluateSceneLightingPBR(shadingNormal, albedo_, shadow, 1.0 - ssao, additionalLight, viewDir, normalGround, roughness, metalness, emission);\n  #else\n    vec3 shadedColor \x3d evaluateSceneLighting(shadingNormal, albedo_, shadow, 1.0 - ssao, additionalLight);\n  #endif\n  gl_FragColor \x3d highlightSlice(vec4(shadedColor, opacity_), vpos);\n}",
"colorPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\n#include \x3cmaterials/defaultMaterial/commonInputs.glsl\x3e\n#define VERTEX_SHADER\n#include \x3cmaterials/defaultMaterial/vertexTangents.glsl\x3e\n#ifdef INSTANCEDCOLOR\nattribute vec4 instanceColor;\n#endif\nattribute vec3 position;\n#if (NORMALS \x3d\x3d NORMALS_COMPRESSED)\n  attribute vec2 normalCompressed;\n  varying vec3 vnormal;\n#elif (NORMALS \x3d\x3d NORMALS_DEFAULT)\n  attribute vec3 normal;\n  varying vec3 vnormal;\n#endif\nvarying vec3 vpos;\nvarying vec3 localvpos;\n#ifdef TEXTURE_COORDINATES\n    attribute vec2 uv0;\n    varying vec2 vtc;\n  #ifdef TEXTURE_ATLAS\n    attribute vec4 region;\n    varying vec4 regionV;\n  #endif\n#endif\n#ifdef COMPONENTCOLORS\n#include \x3cmaterials/defaultMaterial/componentColors.glsl\x3e\n#endif\n#ifdef RECEIVE_SHADOWS\nvarying float linearDepth;\n#endif\n#ifdef VERTEXCOLORS\nattribute vec4 color;\n#endif\n#ifdef SYMBOLVERTEXCOLORS\nattribute vec4 symbolColor;\n#endif\n#if defined(VERTEXCOLORS)\nvarying vec4 vcolor;\n#endif\nuniform vec4 externalColor;\nvarying vec4 vcolorExt;\n#if defined(SYMBOLVERTEXCOLORS) || defined(COMPONENTCOLORS)\nvarying mediump float colorMixMode;\n#endif\n#include \x3cutil/visualVariables.glsl\x3e\n#if defined(VV_SIZE) || defined(VV_COLOR)\nattribute vec4 instanceFeatureAttribute;\n#endif\n#include \x3cmaterials/defaultMaterial/colorMixMode.glsl\x3e\n#include \x3cmaterials/defaultMaterial/commonFunctions.glsl\x3e\n#include \x3cmaterials/defaultMaterial/constants.glsl\x3e\n#include \x3cmaterials/defaultMaterial/localCenter.glsl\x3e\n#include \x3cmaterials/defaultMaterial/localNormal.glsl\x3e\nvoid main() {\n#ifdef VERTEXCOLORS\n  vcolor \x3d color * 0.003921568627451;\n#endif\n  vcolorExt \x3d externalColor;\n#ifdef INSTANCEDCOLOR\n  vcolorExt *\x3d instanceColor;\n#endif\n#ifdef VV_COLOR\n  vcolorExt *\x3d vvGetColor(instanceFeatureAttribute, vvColorValues, vvColorColors);\n#endif\n#ifdef SYMBOLVERTEXCOLORS\n  int symbolColorMixMode;\n  vcolorExt *\x3d decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451;\n  colorMixMode \x3d float(symbolColorMixMode) + 0.5;\n#endif\n#ifdef COMPONENTCOLORS\n  int symbolColorMixMode;\n  vcolorExt *\x3d decodeSymbolColor(readComponentColor() * 255.0, symbolColorMixMode) * 0.003921568627451;\n  colorMixMode \x3d float(symbolColorMixMode) + 0.5;\n#endif\n  if (vcolorExt.a \x3c SYMBOL_ALPHA_CUTOFF) {\n    gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0);\n  }\n  else {\n    vpos \x3d calculateVPos();\n    localvpos \x3d vpos - view[3].xyz;\n#ifdef INSTANCED_DOUBLE_PRECISION\n  #if (NORMALS \x3d\x3d NORMALS_COMPRESSED) || (NORMALS \x3d\x3d NORMALS_DEFAULT)\n    vnormal \x3d normalize(modelNormal * localNormal().xyz);\n  #endif\n  vec3 originDelta \x3d dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n  #ifdef IOS_SAFARI_FIX\n    originDelta \x3d originDelta - fract(originDelta * 1000000.0) * (1.0 / 1000000.0);\n  #endif\n  vpos -\x3d originDelta;\n#else\n  #if (NORMALS \x3d\x3d NORMALS_COMPRESSED) || (NORMALS \x3d\x3d NORMALS_DEFAULT)\n    vnormal \x3d normalize((modelNormal * localNormal()).xyz);\n  #endif\n#endif\n    #ifdef VERTICAL_OFFSET\n      vpos +\x3d calculateVerticalOffset(vpos, localOrigin);\n    #endif\n    #if defined(VERTEX_TANGENTS)\n      transformVertexTangent(mat3(modelNormal));\n    #endif\n    gl_Position \x3d proj * view * vec4(vpos, 1.0);\n  }\n#ifdef RECEIVE_SHADOWS\n  linearDepth \x3d gl_Position.w;\n#endif\n#ifdef TEXTURING\n  #ifndef FLIPV\n    vtc \x3d uv0;\n  #else\n    vtc \x3d vec2(uv0.x, 1.0-uv0.y);\n  #endif\n  #ifdef TEXTURE_ATLAS\n    regionV \x3d region;\n  #endif\n#endif\n}",
"commonFunctions.glsl":"#include \x3cmaterials/defaultMaterial/localPosition.glsl\x3e\n#include \x3cutil/doublePrecision.glsl\x3e\nvec3 calculateVPos() {\n#ifdef INSTANCED_DOUBLE_PRECISION\n  return model * localPosition().xyz;\n#else\n  return (model * localPosition()).xyz;\n#endif\n}\n#ifdef VERTICAL_OFFSET\n#ifdef SCREEN_SIZE_PERSPECTIVE\n#include \x3cutil/screenSizePerspective.glsl\x3e\n#endif\nvec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {\n  float viewDistance \x3d length((view * vec4(worldPos, 1.0)).xyz);\n#if VIEWING_MODE \x3d\x3d VIEWING_MODE_GLOBAL\n  vec3 worldNormal \x3d normalize(worldPos + localOrigin);\n#else\n  vec3 worldNormal \x3d vec3(0.0, 0.0, 1.0);\n#endif\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  float cosAngle \x3d dot(worldNormal, normalize(worldPos - camPos));\n  float verticalOffsetScreenHeight \x3d screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);\n#else\n  float verticalOffsetScreenHeight \x3d verticalOffset.x;\n#endif\n  float worldOffset \x3d clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);\n  return worldNormal * worldOffset;\n}\n#endif",
"commonInputs.glsl":"uniform mat4 proj;\nuniform mat4 view;\n#ifdef INSTANCED_DOUBLE_PRECISION\nuniform vec3 viewOriginHi;\nuniform vec3 viewOriginLo;\n#endif\nuniform vec3 camPos;\nuniform vec3 localOrigin;\n#ifdef INSTANCED\n#ifdef INSTANCED_DOUBLE_PRECISION\nattribute vec3 modelOriginHi;\nattribute vec3 modelOriginLo;\nattribute mat3 model;\nattribute mat3 modelNormal;\n#else\nattribute mat4 model;\nattribute mat4 modelNormal;\n#endif\n#else\nuniform mat4 model;\nuniform mat4 modelNormal;\n#endif\n#ifdef VERTICAL_OFFSET\nuniform vec4 verticalOffset;\n#ifdef SCREEN_SIZE_PERSPECTIVE\nuniform vec4 screenSizePerspectiveAlignment;\n#endif\n#endif",
"componentColors.glsl":"uniform sampler2D uComponentColorTex;\nuniform vec2 uComponentColorTexInvDim;\nattribute float componentIndex;\nvec4 readComponentColor() {\n  float normalizedIndex \x3d (componentIndex + 0.5) * uComponentColorTexInvDim.x;\n  vec2 indexCoord \x3d vec2(\n    mod(normalizedIndex, 1.0),\n    (floor(normalizedIndex) + 0.5) * uComponentColorTexInvDim.y\n  );\n  vec4 componentColor \x3d texture2D(uComponentColorTex, indexCoord);\n  return vec4( componentColor.r, componentColor.g, componentColor.b - mod(componentColor.b*255.0, 2.0)/255.0, componentColor.a);\n}\nbool readComponentCastShadowsFlag(){\n  float normalizedIndex \x3d (componentIndex + 0.5) * uComponentColorTexInvDim.x;\n  vec2 indexCoord \x3d vec2(\n    mod(normalizedIndex, 1.0),\n    (floor(normalizedIndex) + 0.5) * uComponentColorTexInvDim.y\n  );\n  if( mod(texture2D(uComponentColorTex, indexCoord).b*255.0, 2.0) \x3c 1.0 )\n      return false;\n  return true;\n}",
"constants.glsl":"#define SYMBOL_ALPHA_CUTOFF 0.001","depthPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\n#include \x3cutil/fsPrecision.glsl\x3e\n#include \x3cutil/encoding.glsl\x3e\n#include \x3cutil/depth.glsl\x3e\n#include \x3cutil/slice.glsl\x3e\nvarying float depth;\nvarying vec3 vpos;\n#if defined(TEXTURING)\n  #include \x3cmaterials/defaultMaterial/texturingInputs.glsl\x3e\n  #include \x3cmaterials/defaultMaterial/texturing.glsl\x3e\n#endif\nvoid main() {\n  discardBySlice(vpos);\n  #if defined(TEXTURING)\n    vec4 texColor \x3d textureLookup(tex, vtc);\n    discardOrAdjustTextureAlpha(texColor);\n  #endif\n  #ifndef BIAS_SHADOWMAP\n    gl_FragColor \x3d float2rgba(depth);\n  #else\n    gl_FragColor \x3d float2rgba(calcFragDepth(depth));\n  #endif\n}",
"depthPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\n#include \x3cmaterials/defaultMaterial/commonInputs.glsl\x3e\nuniform vec2 nearFar;\nattribute vec3 position;\nvarying float depth;\nvarying vec3 vpos;\n#ifdef TEXTURING\nattribute vec2 uv0;\nvarying vec2 vtc;\n#ifdef TEXTURE_ATLAS\nattribute vec4 region;\nvarying vec4 regionV;\n#endif\n#endif\n#include \x3cutil/visualVariables.glsl\x3e\n#if defined(VV_CUSTOM_MODEL_MATRIX)\nattribute vec4 instanceFeatureAttribute;\n#endif\n#include \x3cmaterials/defaultMaterial/commonFunctions.glsl\x3e\n#include \x3cmaterials/defaultMaterial/localCenter.glsl\x3e\n#if defined(COMPONENTCOLORS)\n#include \x3cmaterials/defaultMaterial/componentColors.glsl\x3e\n#endif\nvoid main(void) {\n  vpos \x3d calculateVPos();\n#if defined(COMPONENTCOLORS)\n  if( !readComponentCastShadowsFlag() ){\n    gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0);\n  }else\n  {\n#endif\n#ifdef INSTANCED_DOUBLE_PRECISION\n  vec3 originDelta \x3d dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n#ifdef IOS_SAFARI_FIX\n  originDelta \x3d originDelta - fract(originDelta * 1000000.0) * (1.0 / 1000000.0);\n#endif\n  vpos -\x3d originDelta;\n#endif\n  #ifdef VERTICAL_OFFSET\n    vpos +\x3d calculateVerticalOffset(vpos, localOrigin);\n  #endif\n  vec4 eye \x3d view * vec4(vpos, 1.0);\n  gl_Position \x3d proj * eye;\n  depth \x3d (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;\n#if defined(COMPONENTCOLORS)\n  }\n#endif\n#ifdef TEXTURING\n#ifndef FLIPV\n  vtc \x3d uv0;\n#else\n  vtc \x3d vec2(uv0.x, 1.0-uv0.y);\n#endif\n#ifdef TEXTURE_ATLAS\n  regionV \x3d region;\n#endif\n#endif\n}",
"highlightPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\n#include \x3cutil/fsPrecision.glsl\x3e\n#include \x3cutil/slice.glsl\x3e\n#include \x3cutil/highlight.glsl\x3e\nvarying vec3 vpos;\nuniform sampler2D depthTex;\nuniform vec4 highlightViewportPixelSz;\n#if defined(TEXTURING)\n  #include \x3cmaterials/defaultMaterial/texturingInputs.glsl\x3e\n  #include \x3cmaterials/defaultMaterial/texturing.glsl\x3e\n#endif\nvoid main() {\n  discardBySlice(vpos);\n  #if defined(TEXTURING)\n    vec4 texColor \x3d textureLookup(tex, vtc);\n    discardOrAdjustTextureAlpha(texColor);\n  #endif\n  gl_FragColor \x3d highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n}",
"highlightPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\n#include \x3cmaterials/defaultMaterial/commonInputs.glsl\x3e\nattribute vec3 position;\nvarying vec3 vpos;\n#ifdef TEXTURING\nattribute vec2 uv0;\nvarying vec2 vtc;\n#ifdef TEXTURE_ATLAS\nattribute vec4 region;\nvarying vec4 regionV;\n#endif\n#endif\n#include \x3cutil/visualVariables.glsl\x3e\n#if defined(VV_CUSTOM_MODEL_MATRIX)\nattribute vec4 instanceFeatureAttribute;\n#endif\n#include \x3cmaterials/defaultMaterial/commonFunctions.glsl\x3e\n#include \x3cmaterials/defaultMaterial/localCenter.glsl\x3e\nvoid main(void) {\n  vpos \x3d calculateVPos();\n#ifdef INSTANCED_DOUBLE_PRECISION\n  vec3 originDelta \x3d dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n#ifdef IOS_SAFARI_FIX\n  originDelta \x3d originDelta - fract(originDelta * 1000000.0) * (1.0 / 1000000.0);\n#endif\n  vpos -\x3d originDelta;\n#endif\n  #ifdef VERTICAL_OFFSET\n    vpos +\x3d calculateVerticalOffset(vpos, localOrigin);\n  #endif\n  gl_Position \x3d proj * view * vec4(vpos, 1.0);\n#ifdef TEXTURING\n#ifndef FLIPV\n  vtc \x3d uv0;\n#else\n  vtc \x3d vec2(uv0.x, 1.0-uv0.y);\n#endif\n#ifdef TEXTURE_ATLAS\n  regionV \x3d region;\n#endif\n#endif\n}",
"localCenter.glsl":"#ifdef VV_CUSTOM_MODEL_MATRIX\n# ifdef VERTICAL_OFFSET\nvec4 localCenter() { return vvTransformPosition(vec3(0.0), instanceFeatureAttribute); }\n# endif\n#else\n# ifdef VERTICAL_OFFSET\nvec4 localCenter() { return vec4(vec3(0.0), 1.0); }\n# endif\n#endif","localNormal.glsl":"#include \x3cutil/normalEncoding.glsl\x3e\n#ifdef VV_CUSTOM_MODEL_MATRIX\n  # if (NORMALS \x3d\x3d NORMALS_COMPRESSED)\n    vec4 localNormal() { return vvTransformNormal(decodeNormal(normalCompressed), instanceFeatureAttribute); }\n  # elif (NORMALS \x3d\x3d NORMALS_DEFAULT)\n    vec4 localNormal() { return vvTransformNormal(normal, instanceFeatureAttribute); }\n  # endif\n#else\n  # if (NORMALS \x3d\x3d NORMALS_COMPRESSED)\n    vec4 localNormal() { return vec4(decodeNormal(normalCompressed), 1.0); }\n  # elif (NORMALS \x3d\x3d NORMALS_DEFAULT)\n    vec4 localNormal() { return vec4(normal, 1.0); }\n  # endif\n#endif",
"localPosition.glsl":"#ifdef VV_CUSTOM_MODEL_MATRIX\nvec4 localPosition() { return vvTransformPosition(position, instanceFeatureAttribute); }\n#else\nvec4 localPosition() { return vec4(position, 1.0); }\n#endif","normalPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\n#include \x3cutil/fsPrecision.glsl\x3e\n#include \x3cutil/slice.glsl\x3e\n#if (NORMALS \x3d\x3d NORMALS_COMPRESSED) || (NORMALS \x3d\x3d NORMALS_DEFAULT)\n  varying vec3 vnormal;\n#endif\nvarying vec3 vpos;\nvarying vec3 vPositionView;\n#if defined(TEXTURING)\n  #include \x3cmaterials/defaultMaterial/texturingInputs.glsl\x3e\n  #include \x3cmaterials/defaultMaterial/texturing.glsl\x3e\n#endif\nvoid main() {\n  discardBySlice(vpos);\n  #if defined(TEXTURING)\n    vec4 texColor \x3d textureLookup(tex, vtc);\n    discardOrAdjustTextureAlpha(texColor);\n  #endif\n#if (NORMALS \x3d\x3d NORMALS_SCREEN_DERIVATIVE)\n  vec3 normal \x3d normalize(cross(dFdx(vPositionView),dFdy(vPositionView)));\n#else\n  vec3 normal \x3d normalize(vnormal);\n  if (gl_FrontFacing \x3d\x3d false) normal \x3d -normal;\n#endif\n  #ifndef ALPHA_ZERO\n    gl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 1.0);\n  #else\n    gl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 0.0);\n  #endif\n}",
"normalPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\n#include \x3cmaterials/defaultMaterial/commonInputs.glsl\x3e\nuniform mat4 viewNormal;\nattribute vec3 position;\n#if (NORMALS \x3d\x3d NORMALS_COMPRESSED)\n  attribute vec2 normalCompressed;\n  varying vec3 vnormal;\n#elif (NORMALS \x3d\x3d NORMALS_DEFAULT)\n  attribute vec3 normal;\n  varying vec3 vnormal;\n#endif\n#ifdef TEXTURING\nattribute vec2 uv0;\nvarying vec2 vtc;\n#ifdef TEXTURE_ATLAS\nattribute vec4 region;\nvarying vec4 regionV;\n#endif\n#endif\nvarying vec3 vpos;\nvarying vec3 vPositionView;\n#include \x3cutil/visualVariables.glsl\x3e\n#if defined(VV_CUSTOM_MODEL_MATRIX)\nattribute vec4 instanceFeatureAttribute;\n#endif\n#include \x3cmaterials/defaultMaterial/commonFunctions.glsl\x3e\n#include \x3cmaterials/defaultMaterial/localCenter.glsl\x3e\n#include \x3cmaterials/defaultMaterial/localNormal.glsl\x3e\nvoid main(void) {\n  vpos \x3d calculateVPos();\n#ifdef INSTANCED_DOUBLE_PRECISION\n  #if (NORMALS \x3d\x3d NORMALS_COMPRESSED) || (NORMALS \x3d\x3d NORMALS_DEFAULT)\n    vnormal \x3d normalize((viewNormal * vec4(modelNormal * localNormal().xyz, 1.0)).xyz);\n  #endif\n  vec3 originDelta \x3d dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n  #ifdef IOS_SAFARI_FIX\n    originDelta \x3d originDelta - fract(originDelta * 1000000.0) * (1.0 / 1000000.0);\n  #endif\n  vpos -\x3d originDelta;\n#else\n  #if (NORMALS \x3d\x3d NORMALS_COMPRESSED) || (NORMALS \x3d\x3d NORMALS_DEFAULT)\n    vnormal \x3d normalize((viewNormal * modelNormal * localNormal()).xyz);\n  #endif\n#endif\n  #ifdef VERTICAL_OFFSET\n    vpos +\x3d calculateVerticalOffset(vpos, localOrigin);\n  #endif\n  vPositionView \x3d (view * vec4(vpos, 1.0)).xyz;\n  gl_Position \x3d proj * vec4(vPositionView, 1.0);\n#ifdef TEXTURING\n#ifndef FLIPV\n  vtc \x3d uv0;\n#else\n  vtc \x3d vec2(uv0.x, 1.0-uv0.y);\n#endif\n#ifdef TEXTURE_ATLAS\n  regionV \x3d region;\n#endif\n#endif\n}",
"textureNormals.glsl":"#if defined(TEXTURE_NORMALS)\n  uniform sampler2D texNormal;\n  vec3 computeTextureNormal(mat3 tangentSpace) {\n    vec3 rawNormal \x3d texture2D(texNormal, vtc).rgb * 2.0 - 1.0;\n    return tangentSpace * rawNormal;\n  }\n#endif","texturing.glsl":"float calcMipMapLevel(const vec2 ddx, const vec2 ddy) {\n  float deltaMaxSqr \x3d max(dot(ddx, ddx), dot(ddy, ddy));\n  return max(0.0, 0.5 * log2(deltaMaxSqr));\n}\nvec4 textureAtlasLookup(sampler2D tex, vec2 uv, vec4 region, vec2 texSize) {\n  vec2 atlasScale \x3d region.zw - region.xy;\n  vec2 uvAtlas \x3d fract(uv) * atlasScale + region.xy;\n  vec4 texColor;\n  vec2 dUVdx \x3d dFdx(uv) * atlasScale;\n  vec2 dUVdy \x3d dFdy(uv) * atlasScale;\n#ifdef GL_EXT_shader_texture_lod\n  return texture2DGradEXT(tex, uvAtlas, dUVdx, dUVdy);\n#else\n  vec2 dUVdxAuto \x3d dFdx(uvAtlas);\n  vec2 dUVdyAuto \x3d dFdy(uvAtlas);\n  float mipMapLevel \x3d calcMipMapLevel(dUVdx * texSize, dUVdy * texSize);\n  float autoMipMapLevel \x3d calcMipMapLevel(dUVdxAuto * texSize, dUVdyAuto * texSize);\n  return texture2D(tex, uvAtlas, mipMapLevel - autoMipMapLevel);\n#endif\n}\nvec4 textureLookup(sampler2D tex, vec2 uv) {\n#ifdef TEXTURE_ATLAS\n  return textureAtlasLookup(tex, uv, regionV, texSize);\n#else\n  return texture2D(tex, uv);\n#endif\n}\nvoid discardOrAdjustTextureAlpha(inout vec4 texColor) {\n  #if defined(TEXTURE_ALPHA_MODE_MASK)\n    if (texColor.a \x3c textureAlphaCutoff) {\n      discard;\n    } else {\n      texColor.a \x3d 1.0;\n    }\n  #elif defined(TEXTURE_ALPHA_MODE_MASK_BLEND)\n    if (texColor.a \x3c textureAlphaCutoff) {\n      discard;\n    }\n  #elif defined(TEXTURE_ALPHA_MODE_OPAQUE)\n    texColor.a \x3d 1.0;\n  #else\n  #endif\n}",
"texturingInputs.glsl":"#ifdef TEXTURING\n  uniform sampler2D tex;\n  uniform vec2 texSize;\n  #if defined(TEXTURE_ALPHA_MODE_MASK) || defined(TEXTURE_ALPHA_MODE_MASK_BLEND)\n  uniform float textureAlphaCutoff;\n  #endif\n  #ifdef TEXTURE_ATLAS\n  varying vec4 regionV;\n  #endif\n#endif\n#if defined(TEXTURING) || defined(TEXTURE_COORDINATES)\nvarying vec2 vtc;\n#endif","vertexTangents.glsl":"#if defined(VERTEX_SHADER)\n  #if defined(VERTEX_TANGENTS)\n    attribute vec4 aTangent;\n    varying vec4 vTangent;\n    void transformVertexTangent(mat3 modelTransformForNormals) {\n      vTangent.xyz \x3d modelTransformForNormals * aTangent.xyz;\n      vTangent.w \x3d aTangent.w;\n    }\n  #endif\n#elif defined(FRAGMENT_SHADER)\n  #if defined(VERTEX_TANGENTS)\n    varying vec4 vTangent;\n    #if defined(WINDINGORDERDOUBLESIDED)\n      mat3 computeTangentSpace(vec3 normal) {\n        float tangentHeadedness \x3d gl_FrontFacing ? vTangent.w : -vTangent.w;\n        vec3 tangent \x3d normalize(gl_FrontFacing ? vTangent.xyz : -vTangent.xyz);\n        vec3 bitangent \x3d cross(normal, tangent) * tangentHeadedness;\n        return mat3(tangent, bitangent, normal);\n      }\n    #else\n      mat3 computeTangentSpace(vec3 normal) {\n        float tangentHeadedness \x3d vTangent.w;\n        vec3 tangent \x3d normalize(vTangent.xyz);\n        vec3 bitangent \x3d cross(normal, tangent) * tangentHeadedness;\n        return mat3(tangent, bitangent, normal);\n      }\n    #endif\n  #else\n    mat3 computeTangentSpace(vec3 normal, vec3 pos, vec2 st) {\n      vec3 Q1 \x3d dFdx(pos);\n      vec3 Q2 \x3d dFdy(pos);\n      vec2 stx \x3d dFdx(st);\n      vec2 sty \x3d dFdy(st);\n      vec3 T \x3d (sty.t * Q1 - stx.t * Q2) / (stx.s * sty.t - sty.s * stx.t);\n      T \x3d normalize(T - normal * dot(normal, T));\n      vec3 B \x3d normalize(cross(normal, T));\n      float det \x3d sty.t * stx.s - stx.t * sty.s;\n      if(det \x3e 0.0){\n        T *\x3d -1.0;\n      }\n      return mat3(T, B, normal);\n    }\n  #endif\n#endif"},
hud:{"colorPass.frag":"#include \x3cmaterials/hud/hudHeader.glsl\x3e\nvoid main() {\n#include \x3cmaterials/hud/hudMain.glsl\x3e\n}","highlightPass.frag":"#include \x3cmaterials/hud/hudHeader.glsl\x3e\n#include \x3cutil/highlight.glsl\x3e\nuniform sampler2D depthTex;\nuniform vec4 highlightViewportPixelSz;\nvoid main() {\n#include \x3cmaterials/hud/hudMain.glsl\x3e\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\n  if (voccluded \x3d\x3d 1.0) {\n    gl_FragColor \x3d vec4(1.0, 1.0, 0.0, 1.0);\n  } else {\n    gl_FragColor \x3d vec4(1.0, 0.0, 1.0, 1.0);\n  }\n#else\n  gl_FragColor \x3d highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n#endif\n}",
"hud.vert":"#include \x3cutil/vsPrecision.glsl\x3e\n#include \x3cutil/alignPixel.glsl\x3e\n#include \x3cutil/hud.glsl\x3e\n#include \x3cutil/visualVariables.glsl\x3e\n#include \x3cutil/slice.glsl\x3e\nuniform vec2 screenOffset;\nuniform vec2 anchorPos;\nuniform vec2 textureCoordinateScaleFactor;\n#ifdef SCREEN_SIZE_PERSPECTIVE\nuniform vec4 screenSizePerspective;\n#endif\n#ifdef DEBUG_DRAW_BORDER\nvarying vec4 debugBorderCoords;\n#endif\nattribute vec2 uv0;\nattribute vec4 color;\nattribute vec2 size;\nattribute vec4 auxpos2;\nvarying vec4 vcolor;\nvarying vec2 vtc;\nvarying vec2 vsize;\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\nvarying float voccluded;\n#endif\nvoid main(void) {\n  ProjectHUDAux projectAux;\n  vec4 posProj \x3d projectPositionHUD(projectAux);\n  if (rejectBySlice(projectAux.posModel)) {\n    gl_Position \x3d vec4(1e038, 1e038, 1e038, 1.0);\n    return;\n  }\n  vec2 inputSize;\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  inputSize \x3d screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);\n  vec2 screenOffsetScaled \x3d screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n#else\n  inputSize \x3d size;\n  vec2 screenOffsetScaled \x3d screenOffset;\n#endif\n#ifdef VV_SIZE\n  inputSize *\x3d vvGetScale(auxpos2).xx;\n#endif\n  vec2 combinedSize \x3d inputSize * pixelRatio;\n  vec4 quadOffset \x3d vec4(0.0);\n#if defined(OCCL_TEST) || defined(BINARY_HIGHLIGHT_OCCLUSION)\n  bool visible \x3d testVisibilityHUD(posProj);\n#endif\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\nvoccluded \x3d visible ? 0.0 : 1.0;\n#endif\n#ifdef OCCL_TEST\n  if (visible) {\n#endif\n    vec2 uv01 \x3d floor(uv0);\n    vec2 uv \x3d uv0 - uv01;\n    quadOffset.xy \x3d ((uv01 - anchorPos) * 2.0 * combinedSize + screenOffsetScaled) / viewport.zw * posProj.w;\n#ifdef SIGNED_DISTANCE_FIELD\n    posProj \x3d alignToPixelOrigin(posProj, viewport.zw) + quadOffset;\n#else\n    posProj +\x3d quadOffset;\n    if (inputSize.x \x3d\x3d size.x) {\n      posProj \x3d alignToPixelOrigin(posProj, viewport.zw);\n    }\n#endif\n    gl_Position \x3d posProj;\n    vtc \x3d uv * textureCoordinateScaleFactor;\n#ifdef DEBUG_DRAW_BORDER\n    debugBorderCoords \x3d vec4(uv01, 1.5 / combinedSize);\n#endif\n    vsize \x3d inputSize;\n#ifdef OCCL_TEST\n  } else {\n    vtc \x3d vec2(.0);\n#ifdef DEBUG_DRAW_BORDER\n    debugBorderCoords \x3d vec4(0.5, 0.5, 1.5 / combinedSize);\n#endif\n  }\n#endif\n  gl_Position \x3d posProj;\n#ifdef VV_COLOR\n  vcolor \x3d vvGetColor(auxpos2, vvColorValues, vvColorColors);\n#else\n  vcolor \x3d color / 255.0;\n#endif\n}",
"hudHeader.glsl":"#include \x3cutil/enableExtensions.glsl\x3e\n#include \x3cutil/fsPrecision.glsl\x3e\n#include \x3cutil/encoding.glsl\x3e\n#include \x3cutil/color.glsl\x3e\nuniform sampler2D tex;\nuniform vec4 overrideColor;\nuniform vec4 outlineColor;\nuniform float outlineSize;\nvarying vec4 vcolor;\nvarying vec2 vtc;\nvarying vec2 vsize;\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\nvarying float voccluded;\n#endif\n#ifdef DEBUG_DRAW_BORDER\nvarying vec4 debugBorderCoords;\n#endif","hudMain.glsl":"#ifdef SIGNED_DISTANCE_FIELD\n  vec4 color \x3d vec4(0.0, 0.0, 0.0, 0.0);\n  vec4 fillPixelColor \x3d overrideColor * vcolor;\n  const float txSize \x3d 128.0;\n  const float texelSize \x3d 1.0 / txSize;\n  vec2 scaleFactor \x3d (vsize - txSize) * texelSize;\n  vec2 samplePos \x3d vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;\n  float d \x3d rgba2float(texture2D(tex, samplePos)) - 0.5;\n  float dist \x3d d * vsize.x;\n  fillPixelColor.a *\x3d clamp(0.5 - dist, 0.0, 1.0);\n  if (outlineSize \x3e 0.25) {\n    vec4 outlinePixelColor \x3d outlineColor;\n    float clampedOutlineSize \x3d min(outlineSize, 0.5*vsize.x);\n    outlinePixelColor.a *\x3d clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);\n    float compositeAlpha \x3d outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);\n    vec3 compositeColor \x3d vec3(outlinePixelColor) * outlinePixelColor.a +\n      vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);\n    gl_FragColor \x3d vec4(compositeColor, compositeAlpha);\n  }\n  else {\n    gl_FragColor \x3d premultiplyAlpha(fillPixelColor);\n  }\n#else\n  gl_FragColor \x3d texture2D(tex, vtc, -0.5) * premultiplyAlpha(overrideColor * vcolor);\n#endif\n#ifdef DEBUG_DRAW_BORDER\n   float isBorder \x3d float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));\n   gl_FragColor \x3d mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder);\n#endif\n  if (gl_FragColor.a \x3c 0.1) {\n    discard;\n  }",
"occlusionTest.frag":"#include \x3cutil/fsPrecision.glsl\x3e\nuniform vec4 color;\nvoid main() {\n  gl_FragColor \x3d color;\n}","occlusionTest.vert":"#include \x3cutil/vsPrecision.glsl\x3e\n#include \x3cutil/alignPixel.glsl\x3e\n#include \x3cutil/hud.glsl\x3e\n#include \x3cutil/slice.glsl\x3e\nvoid main(void) {\n  vec4 posProjCenter;\n  if (dot(position, position) \x3e 0.0) {\n    ProjectHUDAux projectAux;\n    vec4 posProj \x3d projectPositionHUD(projectAux);\n    posProjCenter \x3d alignToPixelCenter(posProj, viewport.zw);\n    vec3 vpos \x3d projectAux.posModel;\n    if (rejectBySlice(vpos)) {\n      posProjCenter \x3d vec4(1e038, 1e038, 1e038, 1.0);\n    }\n  }\n  else {\n    posProjCenter \x3d vec4(1e038, 1e038, 1e038, 1.0);\n  }\n  gl_Position \x3d posProjCenter;\n  gl_PointSize \x3d 1.0;\n}"},
lineCallout:{"lineCallout.frag":"#include \x3cutil/fsPrecision.glsl\x3e\nuniform vec4 color;\nuniform vec4 borderColor;\nvarying vec4 coverageSampling;\nvarying vec2 lineSizes;\nvoid main() {\n  vec2 coverage \x3d min(1.0 - clamp(abs(coverageSampling.xy) - coverageSampling.zw, 0.0, 1.0), lineSizes);\n  float borderAlpha \x3d color.a * borderColor.a * coverage.y;\n  float colorAlpha \x3d color.a * coverage.x;\n  float finalAlpha \x3d mix(borderAlpha, 1.0, colorAlpha);\n#ifdef DEPTH_HUD\n  if (finalAlpha \x3c 0.01) {\n    discard;\n  }\n#else\n  vec3 finalRgb \x3d mix(borderColor.rgb * borderAlpha, color.rgb, colorAlpha);\n  gl_FragColor \x3d vec4(finalRgb, finalAlpha);\n#endif\n}",
"lineCallout.vert":"#include \x3cutil/vsPrecision.glsl\x3e\n#include \x3cutil/alignPixel.glsl\x3e\n#include \x3cutil/hud.glsl\x3e\n#include \x3cutil/slice.glsl\x3e\nattribute vec2 uv0;\nuniform float lineSize;\nuniform vec2 pixelToNDC;\nuniform float borderSize;\nuniform vec2 screenOffset;\nvarying vec4 coverageSampling;\nvarying vec2 lineSizes;\nvoid main(void) {\n  ProjectHUDAux projectAux;\n  vec4 endPoint \x3d projectPositionHUD(projectAux);\n  vec3 vpos \x3d projectAux.posModel;\n  if (rejectBySlice(vpos)) {\n    gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0);\n    return;\n  }\n#ifdef OCCL_TEST\n  if (!testVisibilityHUD(endPoint)) {\n    gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0);\n    return;\n  }\n#endif\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  vec4 perspectiveFactor \x3d screenSizePerspectiveScaleFactor(projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n  vec2 screenOffsetScaled \x3d applyScreenSizePerspectiveScaleFactorVec2(screenOffset, perspectiveFactor);\n#else\n  vec2 screenOffsetScaled \x3d screenOffset;\n#endif\n  vec3 posView \x3d (view * (model * vec4(position, 1.0))).xyz;\n  applyHUDViewDependentPolygonOffset(auxpos1.w, projectAux.absCosAngle, posView);\n  vec4 startPoint \x3d proj * vec4(posView, 1.0);\n  vec2 screenOffsetNorm \x3d screenOffsetScaled * 2.0 / viewport.zw;\n  startPoint.xy +\x3d screenOffsetNorm * startPoint.w;\n  endPoint.xy +\x3d screenOffsetNorm * endPoint.w;\n  vec4 startAligned \x3d alignToPixelOrigin(startPoint, viewport.zw);\n  vec4 endAligned \x3d alignToPixelOrigin(endPoint, viewport.zw);\n#ifdef DEPTH_HUD\n#ifdef DEPTH_HUD_ALIGN_START\n  endAligned \x3d vec4(endAligned.xy / endAligned.w * startAligned.w, startAligned.zw);\n#else\n  startAligned \x3d vec4(startAligned.xy / startAligned.w * endAligned.w, endAligned.zw);\n#endif\n#endif\n  vec4 projectedPosition \x3d mix(startAligned, endAligned, uv0.y);\n  vec2 screenSpaceDirection \x3d normalize(endAligned.xy / endAligned.w - startAligned.xy / startAligned.w);\n  vec2 perpendicularScreenSpaceDirection \x3d vec2(screenSpaceDirection.y, -screenSpaceDirection.x);\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  float lineSizeScaled \x3d applyScreenSizePerspectiveScaleFactorFloat(lineSize, perspectiveFactor);\n  float borderSizeScaled \x3d applyScreenSizePerspectiveScaleFactorFloat(borderSize, perspectiveFactor);\n#else\n  float lineSizeScaled \x3d lineSize;\n  float borderSizeScaled \x3d borderSize;\n#endif\n  float halfPixelSize \x3d lineSizeScaled * 0.5;\n  float halfWholePixelSize \x3d floor(lineSizeScaled) * 0.5;\n  float halfPixelSizeInt \x3d floor(halfWholePixelSize);\n  float subpixelOffset \x3d -fract(lineSizeScaled) * float(halfWholePixelSize \x3e 0.0);\n  float pixelOffset \x3d -halfPixelSizeInt + subpixelOffset;\n  float padding \x3d 1.0 + borderSizeScaled;\n  vec2 ndcOffset \x3d (pixelOffset - padding + uv0.x * (lineSizeScaled + padding + padding)) * pixelToNDC;\n  projectedPosition.xy +\x3d perpendicularScreenSpaceDirection * ndcOffset * projectedPosition.w;\n  float edgeDirection \x3d (uv0.x * 2.0 - 1.0);\n  float halfBorderSize \x3d 0.5 * borderSizeScaled;\n  float halfPixelSizeAndBorder \x3d halfPixelSize + halfBorderSize;\n  float outerEdgeCoverageSampler \x3d edgeDirection * (halfPixelSizeAndBorder + halfBorderSize + 1.0);\n  float isOneSided \x3d float(lineSizeScaled \x3c 2.0 \x26\x26 borderSize \x3c 2.0);\n  coverageSampling \x3d vec4(\n    outerEdgeCoverageSampler,\n    outerEdgeCoverageSampler - halfPixelSizeAndBorder * isOneSided,\n    halfPixelSize - 0.5,\n    halfBorderSize - 0.5 + halfPixelSizeAndBorder * (1.0 - isOneSided)\n  );\n  lineSizes \x3d vec2(lineSizeScaled, borderSizeScaled);\n  gl_Position \x3d projectedPosition;\n}"},
measurementArrow:{"measurementArrow.frag":"#include \x3cutil/fsPrecision.glsl\x3e\nuniform float outlineSize;\nuniform vec4 outlineColor;\nuniform float stripeLength;\nuniform vec4 stripeEvenColor;\nuniform vec4 stripeOddColor;\nvarying vec2 vtc;\nvarying float vlength;\nvarying float vradius;\n#define INV_SQRT2 (1.0 / sqrt(2.0))\nvec4 arrowColor(vec2 tc, float len) {\n  float d \x3d INV_SQRT2 * (tc.x - abs(tc.y));\n  d \x3d min(d, INV_SQRT2 * (len - tc.x - abs(tc.y)));\n  d \x3d min(d, 1.0 - abs(tc.y));\n  if (d \x3c 0.0) {\n    return vec4(0.0);\n  } else if (d \x3c outlineSize) {\n    return outlineColor;\n  } else {\n    return fract(0.5 / stripeLength * tc.x * vradius) \x3e\x3d 0.5 ? stripeOddColor : stripeEvenColor;\n  }\n}\nvoid main(void) {\n  vec2 ntc \x3d vec2(vtc.x / vradius, vtc.y);\n  vec4 color \x3d arrowColor(ntc, vlength / vradius);\n  if (color.a \x3d\x3d 0.0) {\n    discard;\n  }\n  gl_FragColor \x3d color;\n}",
"measurementArrow.vert":"#include \x3cutil/vsPrecision.glsl\x3e\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nuniform float width;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv0;\nattribute float auxpos1;\nvarying vec2 vtc;\nvarying float vlength;\nvarying float vradius;\nvoid main(void) {\n  vec3 bitangent \x3d normal;\n  vtc \x3d uv0;\n  vlength \x3d auxpos1;\n  vradius \x3d 0.5 * width;\n  vec4 pos \x3d view * vec4((model * vec4(position + vradius * bitangent * uv0.y, 1.0)).xyz, 1.0);\n  gl_Position \x3d proj * pos;\n}"},
nativeLine:{"colorPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\n#include \x3cutil/fsPrecision.glsl\x3e\n#include \x3cutil/slice.glsl\x3e\nuniform vec4 constantColor;\nvarying vec3 vpos;\n#ifdef VERTEXCOLORS\nvarying vec4 vcolor;\n#endif\nvoid main() {\n  discardBySlice(vpos);\n#ifdef VERTEXCOLORS\n  gl_FragColor \x3d highlightSlice(vcolor, vpos);\n#else\n  gl_FragColor \x3d highlightSlice(constantColor, vpos);\n#endif\n}","highlightPass.frag":"#include \x3cutil/fsPrecision.glsl\x3e\n#include \x3cutil/slice.glsl\x3e\n#include \x3cutil/highlight.glsl\x3e\nvarying vec3 vpos;\nuniform sampler2D depthTex;\nuniform vec4 highlightViewportPixelSz;\nvoid main() {\n  discardBySlice(vpos);\n  gl_FragColor \x3d highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n}",
"nativeLine.vert":"#include \x3cutil/vsPrecision.glsl\x3e\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nattribute vec3 position;\n#ifdef VERTEXCOLORS\nattribute vec4 color;\n#endif\nvarying vec3 vpos;\n#ifdef VERTEXCOLORS\nvarying vec4 vcolor;\n#endif\nvoid main(void) {\n  vpos \x3d (model * vec4(position, 1.0)).xyz;\n  #ifdef VERTEXCOLORS\n    vcolor \x3d color * 0.003921568627451;\n  #endif\n  gl_Position \x3d proj * view * vec4(vpos, 1.0);\n}"},pathMaterial:{"colorMixMode.glsl":"#include \x3cutil/color.glsl\x3e\nvec4 decodeSymbolColor(vec4 symbolColor, out int colorMixMode) {\n  float symbolAlpha \x3d 0.0;\n  const float maxTint \x3d 85.0;\n  const float maxReplace \x3d 170.0;\n  const float scaleAlpha \x3d 3.0;\n  if (symbolColor.a \x3d\x3d 0.0) {\n    colorMixMode \x3d 1;\n    symbolAlpha \x3d 0.0;\n  }\n  else if (symbolColor.a \x3c\x3d maxTint) {\n    colorMixMode \x3d 0;\n    symbolAlpha \x3d scaleAlpha * symbolColor.a;\n  }\n  else if (symbolColor.a \x3c\x3d maxReplace) {\n    colorMixMode \x3d 3;\n    symbolAlpha \x3d scaleAlpha * (symbolColor.a - maxTint);\n  }\n  else {\n    colorMixMode \x3d 1;\n    symbolAlpha \x3d scaleAlpha * (symbolColor.a - maxReplace);\n  }\n  return vec4(symbolColor.rgb, symbolAlpha);\n}\nvec3 mixExternalColor(vec3 internalColor, vec3 textureColor, vec3 externalColor, int mode) {\n  vec3 internalMixed \x3d internalColor * textureColor;\n  vec3 allMixed \x3d internalMixed * externalColor;\n  if (mode \x3d\x3d 1 ) {\n    return allMixed;\n  }\n  else if (mode \x3d\x3d 2  ) {\n    return internalMixed;\n  }\n  else if (mode \x3d\x3d 3  ) {\n    return externalColor;\n  }\n  else {\n    vec3 hsvIn \x3d rgb2hsv(internalMixed);\n    vec3 hsvTint \x3d rgb2hsv(externalColor);\n    vec3 hsvOut \x3d vec3(hsvTint.x, hsvTint.y, hsvIn.z * hsvTint.z);\n    return hsv2rgb(hsvOut);\n  }\n}\nfloat mixExternalOpacity(float internalOpacity, float textureOpacity, float externalOpacity, int mode) {\n  float internalMixed \x3d internalOpacity * textureOpacity;\n  float allMixed \x3d internalMixed * externalOpacity;\n  if (mode \x3d\x3d 2  ) {\n    return internalMixed;\n  }\n  else if (mode \x3d\x3d 3  ) {\n    return externalOpacity;\n  }\n  else {\n    return allMixed;\n  }\n}",
"colorPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\n#include \x3cutil/fsPrecision.glsl\x3e\n#include \x3cutil/slice.glsl\x3e\n#include \x3cutil/sceneLighting.glsl\x3e\nuniform vec3 camPos;\nuniform vec3 localOrigin;\nuniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 specular;\nuniform float opacity;\nuniform float layerOpacity;\n#if defined(SYMBOLVERTEXCOLORS) || defined(COMPONENTCOLORS)\nvarying mediump float colorMixMode;\n#else\nuniform int colorMixMode;\n#endif\n#ifdef RECEIVE_SHADOWS\nuniform sampler2D depthTex;\nuniform int shadowMapNum;\nuniform vec4 shadowMapDistance;\nuniform mat4 shadowMapMatrix[4];\nuniform float depthHalfPixelSz;\n#endif\n#ifdef RECEIVE_SSAO\nuniform sampler2D ssaoTex;\nuniform vec4 viewportPixelSz;\n#endif\nvarying vec3 vpos;\nvarying vec3 vnormal;\nvarying vec4 vcolor;\nvarying vec4 vcolorExt;\n#ifdef RECEIVE_SHADOWS\nvarying float linearDepth;\n#include \x3cutil/shadow.glsl\x3e\n#endif\n#include \x3cmaterials/pathMaterial/colorMixMode.glsl\x3e\nvoid main() {\n  discardBySlice(vpos);\n  vec4 texColor \x3d vec4(1.0);\n  vec3 viewDir \x3d vpos - camPos;\n#ifdef GROUND_NORMAL_SHADING\n#if VIEWING_MODE \x3d\x3d VIEWING_MODE_GLOBAL\n  vec3 normal \x3d normalize(vpos + localOrigin);\n#else\n  vec3 normal \x3d vec3(0.0, 0.0, 1.0);\n#endif\n#else\n#ifdef DOUBLESIDED\n  vec3 normal \x3d dot(vnormal, viewDir)\x3e0.0 ? -vnormal : vnormal;\n#elif defined(WINDINGORDERDOUBLESIDED)\n  vec3 normal \x3d gl_FrontFacing ? vnormal : -vnormal;\n#else\n  vec3 normal \x3d vnormal;\n#endif\n  normal \x3d normalize(normal);\n#endif\n#ifdef RECEIVE_SSAO\n  float ssao \x3d texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n  ssao \x3d viewportPixelSz.z \x3c 0.0 ? 1.0 : ssao;\n#else\n  float ssao \x3d 1.0;\n#endif\n  float additionalAmbientScale;\n  vec3 additionalLight \x3d sceneLightingAdditionalLightGlobal(vpos + localOrigin, ssao, additionalAmbientScale);\n  float shadow \x3d 0.0;\n#ifdef RECEIVE_SHADOWS\n  shadow \x3d evalShadow(vpos, linearDepth, depthTex, shadowMapNum, shadowMapDistance, shadowMapMatrix, depthHalfPixelSz);\n#elif VIEWING_MODE \x3d\x3d VIEWING_MODE_GLOBAL\n  shadow \x3d lightingGlobalFactor * (1.0 - additionalAmbientScale);\n#endif\n  vec3 matColor \x3d max(ambient, diffuse);\n  vec3 albedo_ \x3d mixExternalColor(vcolor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n  float opacity_ \x3d layerOpacity * mixExternalOpacity(vcolor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n  albedo_+\x3d 0.25 * specular;\n#ifdef TRANSPARENCY_DISCARD\n  if (opacity_ \x3c 0.001) {\n    discard;\n  }\n#endif\n  vec3 shadedColor \x3d evaluateSceneLighting(normal, albedo_, shadow, 1.0 - ssao, additionalLight);\n  gl_FragColor \x3d vec4(shadedColor, opacity_);\n  gl_FragColor \x3d highlightSlice(gl_FragColor, vpos);\n}",
"colorPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\n#include \x3cmaterials/pathMaterial/commonInputs.glsl\x3e\n#ifdef COMPRESSED_NORMALS\nattribute vec2 normalCompressed;\n#else\nattribute vec3 normal;\n#endif\nvarying vec3 vpos;\nvarying vec3 vnormal;\n#ifdef COMPONENTCOLORS\nuniform sampler2D uComponentColorTex;\nuniform vec2 uComponentColorTexInvDim;\nattribute float componentIndex;\nvec4 readComponentColor() {\n  float normalizedIndex \x3d (componentIndex + 0.5) * uComponentColorTexInvDim.x;\n  vec2 indexCoord \x3d vec2(\n    mod(normalizedIndex, 1.0),\n    (floor(normalizedIndex) + 0.5) * uComponentColorTexInvDim.y\n  );\n  return texture2D(uComponentColorTex, indexCoord);\n}\n#endif\n#ifdef RECEIVE_SHADOWS\nvarying float linearDepth;\n#endif\n#ifdef SYMBOLVERTEXCOLORS\nattribute vec4 symbolColor;\n#endif\nuniform vec4 externalColor;\nvarying vec4 vcolor;\nvarying vec4 vcolorExt;\n#if defined(SYMBOLVERTEXCOLORS) || defined(COMPONENTCOLORS)\nvarying mediump float colorMixMode;\n#endif\n#include \x3cmaterials/pathMaterial/commonFunctions.glsl\x3e\n#include \x3cmaterials/pathMaterial/localNormal.glsl\x3e\n#include \x3cmaterials/pathMaterial/colorMixMode.glsl\x3e\nvoid main() {\n  vpos \x3d calculateVPos();\n  vnormal \x3d normalize((modelNormal * localNormal()).xyz);\n  gl_Position \x3d proj * view * vec4(vpos, 1.0);\n#ifdef RECEIVE_SHADOWS\n  linearDepth \x3d gl_Position.w;\n#endif\n  vcolorExt \x3d externalColor;\n  vcolor \x3d getColor();\n#ifdef SYMBOLVERTEXCOLORS\n  int symbolColorMixMode;\n  vcolorExt *\x3d decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451;\n  colorMixMode \x3d float(symbolColorMixMode) + 0.5;\n#endif\n#ifdef COMPONENTCOLORS\n  int symbolColorMixMode;\n  vcolorExt *\x3d decodeSymbolColor(readComponentColor() * 255.0, symbolColorMixMode) * 0.003921568627451;\n  colorMixMode \x3d float(symbolColorMixMode) + 0.5;\n#endif\n}",
"commonFunctions.glsl":"#include \x3cutil/doublePrecision.glsl\x3e\nattribute vec4 featureValue;\nbool isCapVertex() {\n  return featureValue.w \x3d\x3d 1.0;\n}\nuniform vec3 size;\n#if defined(VV_SIZE)\n  uniform vec3 vvSizeMinSize;\n  uniform vec3 vvSizeMaxSize;\n  uniform vec3 vvSizeOffset;\n  uniform vec3 vvSizeFactor;\n  vec3 getSize() {\n    float value \x3d featureValue.x;\n    return size*clamp(vvSizeOffset + value * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).xzy;\n  }\n#else\n  vec3 getSize(){\n    return size;\n  }\n#endif\n#ifdef VV_OPACITY\n  #define VV_OPACITY_N 8\n  uniform float vvOpacityValues[VV_OPACITY_N];\n  uniform float vvOpacityOpacities[VV_OPACITY_N];\n  vec4 applyOpacity(vec4 color) {\n    float value \x3d featureValue.z;\n    if (value \x3c\x3d vvOpacityValues[0]) {\n      return vec4( color.xyz, vvOpacityOpacities[0]);\n    }\n    for (int i \x3d 1; i \x3c VV_OPACITY_N; ++i) {\n      if (vvOpacityValues[i] \x3e\x3d value) {\n        float f \x3d (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);\n        return vec4( color.xyz, mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f));\n      }\n    }\n    return vec4( color.xyz, vvOpacityOpacities[VV_OPACITY_N - 1]);\n  }\n#else\n  vec4 applyOpacity(vec4 color){\n    return color;\n  }\n#endif\n#ifdef VV_COLOR\n  #define VV_COLOR_N 8\n  uniform float vvColorValues[VV_COLOR_N];\n  uniform vec4 vvColorColors[VV_COLOR_N];\n  vec4 getColor() {\n    float value \x3d featureValue.y;\n    if (value \x3c\x3d vvColorValues[0]) {\n      return applyOpacity(vvColorColors[0]);\n    }\n    for (int i \x3d 1; i \x3c VV_COLOR_N; ++i) {\n      if (vvColorValues[i] \x3e\x3d value) {\n        float f \x3d (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);\n        return applyOpacity(mix(vvColorColors[i-1], vvColorColors[i], f));\n      }\n    }\n    return applyOpacity(vvColorColors[VV_COLOR_N - 1]);\n  }\n#else\n  vec4 getColor(){\n    return applyOpacity(vec4(1, 1, 1, 1));\n  }\n#endif\nvec3 calculateVPos() {\n  vec3 size \x3d getSize();\n  vec3 origin \x3d position;\n  vec3 profileRightAxis \x3d pathGeometryInfo[0].xyz;\n  vec3 profileUpAxis \x3d pathGeometryInfo[1].xyz;\n  vec3 offset \x3d profileRightAxis * size.x + profileUpAxis * size.y;\n  if(!isCapVertex()) {\n    vec3 rotationRightAxis \x3d pathGeometryInfo[2].xyz;\n    float maxDistance \x3d length(rotationRightAxis);\n    rotationRightAxis \x3d normalize(rotationRightAxis);\n    float rx \x3d dot(offset, rotationRightAxis);\n    if( abs(rx) \x3e maxDistance ) {\n      vec3 rotationUpAxis \x3d offset - rx*rotationRightAxis;\n      offset \x3d rotationRightAxis * maxDistance * sign(rx) + rotationUpAxis;\n    }\n  } else {\n    vec3 profilePlaneOffset \x3d pathGeometryInfo[2].xyz*size.x;\n    offset +\x3d profilePlaneOffset;\n  }\n  vec4 localPosition \x3d vec4(origin + offset, 1.0);\n  return (model * localPosition).xyz;\n}",
"commonInputs.glsl":"uniform mat4 proj;\nuniform mat4 view;\nuniform vec3 camPos;\nuniform vec3 localOrigin;\nuniform mat4 model;\nuniform mat4 modelNormal;\nattribute vec3 position;\nattribute mat3 pathGeometryInfo;","depthPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\n#include \x3cutil/fsPrecision.glsl\x3e\n#include \x3cutil/encoding.glsl\x3e\n#include \x3cutil/depth.glsl\x3e\n#include \x3cutil/slice.glsl\x3e\nvarying float depth;\nvarying vec3 vpos;\nvoid main() {\n  discardBySlice(vpos);\n#ifndef BIAS_SHADOWMAP\n  gl_FragColor \x3d float2rgba(depth);\n#else\n  gl_FragColor \x3d float2rgba(calcFragDepth(depth));\n#endif\n}",
"depthPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\n#include \x3cmaterials/pathMaterial/commonInputs.glsl\x3e\nuniform vec2 nearFar;\nvarying float depth;\nvarying vec3 vpos;\n#include \x3cmaterials/pathMaterial/commonFunctions.glsl\x3e\nvoid main(void) {\n  vpos \x3d calculateVPos();\n  vec4 eye \x3d view * vec4(vpos, 1.0);\n  gl_Position \x3d proj * eye;\n  depth \x3d (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;\n}","highlightPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\n#include \x3cutil/fsPrecision.glsl\x3e\n#include \x3cutil/slice.glsl\x3e\n#include \x3cutil/highlight.glsl\x3e\nvarying vec3 vpos;\nuniform sampler2D depthTex;\nuniform vec4 highlightViewportPixelSz;\nvoid main() {\n  discardBySlice(vpos);\n  gl_FragColor \x3d highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n}",
"highlightPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\n#include \x3cmaterials/pathMaterial/commonInputs.glsl\x3e\nvarying vec3 vpos;\n#include \x3cmaterials/pathMaterial/commonFunctions.glsl\x3e\nvoid main(void) {\n  vpos \x3d calculateVPos();\n  gl_Position \x3d proj * view * vec4(vpos, 1.0);\n}","localNormal.glsl":"#include \x3cutil/normalEncoding.glsl\x3e\n# ifdef COMPRESSED_NORMALS\nvec4 localNormal() { return vec4(decodeNormal(normalCompressed), 1.0); }\n# else\nvec4 localNormal() { return vec4(normal, 1.0); }\n# endif",
"normalPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\n#include \x3cutil/fsPrecision.glsl\x3e\n#include \x3cutil/slice.glsl\x3e\nvarying vec3 vnormal;\nvarying vec3 vpos;\nvoid main() {\n  discardBySlice(vpos);\n  vec3 normal \x3d normalize(vnormal);\n  if (gl_FrontFacing \x3d\x3d false) normal \x3d -normal;\n#ifndef ALPHA_ZERO\n  gl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 1.0);\n#else\n  gl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 0.0);\n#endif\n}","normalPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\n#include \x3cmaterials/pathMaterial/commonInputs.glsl\x3e\nuniform mat4 viewNormal;\n#ifdef COMPRESSED_NORMALS\nattribute vec2 normalCompressed;\n#else\nattribute vec3 normal;\n#endif\nvarying vec3 vnormal;\nvarying vec3 vpos;\n#include \x3cmaterials/pathMaterial/commonFunctions.glsl\x3e\n#include \x3cmaterials/pathMaterial/localNormal.glsl\x3e\nvoid main(void) {\n  vpos \x3d calculateVPos();\n  vnormal \x3d normalize((viewNormal * modelNormal * localNormal()).xyz);\n  gl_Position \x3d proj * view * vec4(vpos, 1.0);\n}",
"texturing.glsl":"float calcMipMapLevel(const vec2 ddx, const vec2 ddy) {\n  float deltaMaxSqr \x3d max(dot(ddx, ddx), dot(ddy, ddy));\n  return max(0.0, 0.5 * log2(deltaMaxSqr));\n}\nvec4 textureAtlasLookup(sampler2D tex, vec2 uv, vec4 region, vec2 texSize) {\n  vec2 atlasScale \x3d region.zw - region.xy;\n  vec2 uvAtlas \x3d fract(uv) * atlasScale + region.xy;\n  vec2 dUVdx \x3d dFdx(uv) * atlasScale;\n  vec2 dUVdy \x3d dFdy(uv) * atlasScale;\n#ifdef GL_EXT_shader_texture_lod\n  return texture2DGradEXT(tex, uvAtlas, dUVdx, dUVdy);\n#else\n  vec2 dUVdxAuto \x3d dFdx(uvAtlas);\n  vec2 dUVdyAuto \x3d dFdy(uvAtlas);\n  float mipMapLevel \x3d calcMipMapLevel(dUVdx * texSize, dUVdy * texSize);\n  float autoMipMapLevel \x3d calcMipMapLevel(dUVdxAuto * texSize, dUVdyAuto * texSize);\n  return texture2D(tex, uvAtlas, mipMapLevel - autoMipMapLevel);\n#endif\n}\nvec4 textureLookup(sampler2D tex, vec2 uv) {\n#ifdef TEXTURE_ATLAS\n  return textureAtlasLookup(tex, uv, regionV, texSize);\n#else\n  return texture2D(tex, uv);\n#endif\n}"},
ribbonLine:{"colorPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\n#include \x3cutil/fsPrecision.glsl\x3e\n#include \x3cutil/slice.glsl\x3e\nuniform vec4 symbolColor;\nvarying vec4 vColor;\nvarying vec2 vtc;\nvarying vec3 vpos;\n#ifdef STIPPLE\nuniform float stippleLengthDoubleInv;\n#endif\nvoid main() {\n  discardBySlice(vpos);\n#ifdef STIPPLE\n  if (fract(vtc.x * stippleLengthDoubleInv) \x3e 0.5) {\n    discard;\n  }\n#endif\n  gl_FragColor \x3d highlightSlice(symbolColor * vColor, vpos);\n}",
"highlightPass.frag":"#include \x3cutil/fsPrecision.glsl\x3e\n#include \x3cutil/slice.glsl\x3e\nvarying vec2 vtc;\nvarying vec3 vpos;\n#ifdef STIPPLE\nuniform float stippleLengthDoubleInv;\n#endif\nvoid main() {\n  discardBySlice(vpos);\n#ifdef STIPPLE\n  if (fract(vtc.x * stippleLengthDoubleInv) \x3e 0.5) {\n    discard;\n  }\n#endif\n  gl_FragColor \x3d vec4(1.0, 1.0, 1.0, 1.0);\n}","inputs.glsl":"uniform float symbolLineWidth;\n#ifdef VV_SIZE\n  attribute float sizeFeatureAttribute;\n  uniform vec3 vvSizeMinSize;\n  uniform vec3 vvSizeMaxSize;\n  uniform vec3 vvSizeOffset;\n  uniform vec3 vvSizeFactor;\n  float getSize() {\n    float value \x3d sizeFeatureAttribute;\n    return symbolLineWidth * clamp(vvSizeOffset + value * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).x;\n  }\n#else\n  attribute float size;\n  float getSize(){\n    return symbolLineWidth * size;\n  }\n#endif\n#ifdef VV_OPACITY\n  attribute float opacityFeatureAttribute;\n  #define VV_OPACITY_N 8\n  uniform float vvOpacityValues[VV_OPACITY_N];\n  uniform float vvOpacityOpacities[VV_OPACITY_N];\n  float interpolateOpacity( float value ){\n    if (value \x3c\x3d vvOpacityValues[0]) {\n      return vvOpacityOpacities[0];\n    }\n    for (int i \x3d 1; i \x3c VV_OPACITY_N; ++i) {\n      if (vvOpacityValues[i] \x3e\x3d value) {\n        float f \x3d (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);\n        return mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f);\n      }\n    }\n    return vvOpacityOpacities[VV_OPACITY_N - 1];\n  }\n  vec4 applyOpacity( vec4 color ){\n    return vec4(color.xyz, interpolateOpacity(opacityFeatureAttribute));\n  }\n#else\n  vec4 applyOpacity( vec4 color ){\n    return color;\n  }\n#endif\n#ifdef VV_COLOR\n  attribute float colorFeatureAttribute;\n  #define VV_COLOR_N 8\n  uniform float vvColorValues[VV_COLOR_N];\n  uniform vec4 vvColorColors[VV_COLOR_N];\n  vec4 interpolateColor( float value ) {\n    if (value \x3c\x3d vvColorValues[0]) {\n      return vvColorColors[0];\n    }\n    for (int i \x3d 1; i \x3c VV_COLOR_N; ++i) {\n      if (vvColorValues[i] \x3e\x3d value) {\n        float f \x3d (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);\n        return mix(vvColorColors[i-1], vvColorColors[i], f);\n      }\n    }\n    return vvColorColors[VV_COLOR_N - 1];\n  }\n  vec4 getColor(){\n    return applyOpacity(interpolateColor(colorFeatureAttribute));\n  }\n#else\n  attribute vec4 color;\n  vec4 getColor(){\n    return applyOpacity(color);\n  }\n#endif",
"ribbonLine.vert":"#include \x3cutil/vsPrecision.glsl\x3e\n#include \x3cmaterials/ribbonLine/inputs.glsl\x3e\nconst float PI \x3d 3.1415926535897932384626433832795;\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nuniform float nearPlane;\nuniform float pixelRatio;\nattribute vec3 position;\nattribute float subdivisionFactor;\nattribute vec2 uv0;\nvarying vec2 vtc;\nvarying vec4 vColor;\nvarying vec3 vpos;\nuniform float miterLimit;\nattribute vec3 auxpos1;\nattribute vec3 auxpos2;\nuniform vec2 screenSize;\nvec4 toScreenCoords(vec3 vertex) {\n  vec4 vClipSpace \x3d proj * view * vec4((model * vec4(vertex, 1.0)).xyz, 1.0);\n  vClipSpace.xy *\x3d screenSize;\n  return vClipSpace/abs(vClipSpace.w);\n}\n#define PERPENDICULAR(v) vec2(v.y, -v.x);\n#define ISOUTSIDE (left.x * right.y - left.y * right.x)*uv0.y \x3e 0.0\nfloat interp(float ncp, vec4 a, vec4 b) {\n  return (-ncp - a.z) / (b.z - a.z);\n}\nvec2 rotate(vec2 v, float a) {\n\tfloat s \x3d sin(a);\n\tfloat c \x3d cos(a);\n\tmat2 m \x3d mat2(c, -s, s, c);\n\treturn m * v;\n}\nvoid clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {\n  float vnp \x3d nearPlane*0.99;\n  if(pos.z \x3e -nearPlane) {\n    if (!isStartVertex) {\n      if(prev.z \x3c -nearPlane) {\n        pos \x3d mix(prev, pos, interp(vnp, prev, pos));\n        next \x3d pos;\n      } else {\n        pos \x3d vec4(0.0, 0.0, 0.0, 1.0);\n      }\n    }\n    if(isStartVertex) {\n      if(next.z \x3c -nearPlane) {\n        pos \x3d mix(pos, next, interp(vnp, pos, next));\n        prev \x3d pos;\n      } else {\n        pos \x3d vec4(0.0, 0.0, 0.0, 1.0);\n      }\n    }\n  } else {\n    if (prev.z \x3e -nearPlane) {\n      prev \x3d mix(pos, prev, interp(vnp, pos, prev));\n    }\n    if (next.z \x3e -nearPlane) {\n      next \x3d mix(next, pos, interp(vnp, next, pos));\n    }\n  }\n  pos\x3d proj * pos;\n  pos.xy *\x3d screenSize;\n  pos /\x3d pos.w;\n  next \x3d proj * next;\n  next.xy *\x3d screenSize;\n  next /\x3d next.w;\n  prev \x3d proj * prev;\n  prev.xy *\x3d screenSize;\n  prev /\x3d prev.w;\n}\nvoid main(void) {\n  vpos \x3d (model * vec4(position, 1.0)).xyz;\n  if (uv0.y \x3d\x3d 0.0) {\n    gl_Position \x3d vec4(1e038, 1e038, 1e038, 1.0);\n  }\n  else {\n    bool isStartVertex \x3d abs(abs(uv0.y)-3.0) \x3d\x3d 1.0;\n    bool isJoin \x3d abs(uv0.y)-3.0 \x3c 0.0;\n    float lineWidth \x3d getSize() * pixelRatio;\n    vec4 pos  \x3d view * vec4((model * vec4(position.xyz, 1.0)).xyz, 1.0);\n    vec4 prev \x3d view * vec4((model * vec4(auxpos1.xyz, 1.0)).xyz, 1.0);\n    vec4 next \x3d view * vec4((model * vec4(auxpos2.xyz, 1.0)).xyz, 1.0);\n    clipAndTransform(pos, prev, next, isStartVertex);\n    vec2 left \x3d (pos - prev).xy;\n    vec2 right \x3d (next - pos).xy;\n    float leftLen \x3d length(left);\n    left \x3d (leftLen \x3e 0.001) ? left/leftLen : vec2(0.0, 0.0);\n    float rightLen \x3d length(right);\n    right \x3d (rightLen \x3e 0.001) ? right/rightLen : vec2(0.0, 0.0);\n    vec2 capDisplacementDir \x3d vec2(0, 0);\n    vec2 joinDisplacementDir \x3d vec2(0, 0);\n    float displacementLen \x3d lineWidth;\n    if( isJoin ){\n      bool isOutside \x3d ISOUTSIDE;\n      joinDisplacementDir \x3d normalize(left + right);\n      joinDisplacementDir \x3d PERPENDICULAR(joinDisplacementDir);\n      if (leftLen \x3e 0.001 \x26\x26 rightLen \x3e 0.001) {\n        float nDotSeg \x3d dot(joinDisplacementDir, left);\n        displacementLen /\x3d length(nDotSeg*left - joinDisplacementDir);\n        if (!isOutside) {\n          displacementLen \x3d min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));\n        }\n      }\n      if (isOutside \x26\x26 (displacementLen \x3e miterLimit*lineWidth)) {\n#ifdef JOIN_ROUND\n        vec2 startDir;\n        vec2 endDir;\n        if (leftLen \x3c 0.001) {\n          startDir \x3d right;\n        }\n        else{\n          startDir \x3d left;\n        }\n        startDir \x3d normalize(startDir);\n        startDir \x3d PERPENDICULAR(startDir);\n        if (rightLen \x3c 0.001) {\n          endDir \x3d left;\n        }\n        else{\n          endDir \x3d right;\n        }\n        endDir \x3d normalize(endDir);\n        endDir \x3d PERPENDICULAR(endDir);\n        float rotationAngle \x3d acos(clamp(dot(startDir, endDir), -1.0, 1.0));\n        joinDisplacementDir \x3d rotate( startDir, -sign(uv0.y)*subdivisionFactor*rotationAngle );\n        displacementLen \x3d lineWidth;\n#else\n        if (leftLen \x3c 0.001) {\n          joinDisplacementDir \x3d right;\n        }\n        else if (rightLen \x3c 0.001) {\n          joinDisplacementDir \x3d left;\n        }\n        else {\n          joinDisplacementDir \x3d isStartVertex ? right : left;\n        }\n        joinDisplacementDir \x3d normalize(joinDisplacementDir);\n        joinDisplacementDir \x3d PERPENDICULAR(joinDisplacementDir);\n        displacementLen \x3d lineWidth;\n#endif\n      }\n    } else {\n      if (leftLen \x3c 0.001) {\n        joinDisplacementDir \x3d right;\n      }\n      else if (rightLen \x3c 0.001) {\n        joinDisplacementDir \x3d left;\n      }\n      else {\n        joinDisplacementDir \x3d isStartVertex ? right : left;\n      }\n      joinDisplacementDir \x3d normalize(joinDisplacementDir);\n      joinDisplacementDir \x3d PERPENDICULAR(joinDisplacementDir);\n      displacementLen \x3d lineWidth;\n      capDisplacementDir \x3d isStartVertex ? -right : left;\n  #ifdef CAP_ROUND\n      float angle \x3d subdivisionFactor*PI*0.5;\n      joinDisplacementDir *\x3d cos(angle);\n      capDisplacementDir *\x3d sin(angle);\n  #else\n      capDisplacementDir *\x3d subdivisionFactor;\n  #endif\n    }\n    pos.xy +\x3d joinDisplacementDir * sign(uv0.y) * displacementLen;\n    pos.xy +\x3d capDisplacementDir * displacementLen;\n    pos.xy /\x3d screenSize;\n    vtc \x3d uv0;\n    vColor \x3d getColor();\n    gl_Position \x3d pos;\n  }\n}"},
slicePlane:{"slicePlane.frag":"#include \x3cutil/enableExtensions.glsl\x3e\n#include \x3cutil/fsPrecision.glsl\x3e\nuniform vec4 backgroundColor;\nuniform vec4 gridColor;\nuniform float ratio;\nuniform float gridWidth;\nvarying vec2 vUV;\nvoid main() {\n  const float LINE_WIDTH \x3d 1.0;\n  vec2 uvScaled \x3d vUV * gridWidth;\n  vec2 gridUV \x3d (fract(uvScaled + 0.5) - 0.5) / (LINE_WIDTH * fwidth(uvScaled));\n  vec2 grid \x3d (1.0 - step(0.5, gridUV)) * step(-0.5, gridUV);\n  grid.x *\x3d step(0.5, uvScaled.x) * step(uvScaled.x, gridWidth - 0.5);\n  grid.y *\x3d step(0.5, uvScaled.y) * step(uvScaled.y, gridWidth - 0.5);\n  float gridFade \x3d max(grid.x, grid.y);\n  float gridAlpha \x3d gridColor.a * gridFade;\n  gl_FragColor \x3d\n    vec4(backgroundColor.rgb * backgroundColor.a, backgroundColor.a) * (1.0 - gridAlpha) +\n    vec4(gridColor.rgb, 1.0) * gridAlpha;\n}",
"slicePlane.vert":"#include \x3cutil/vsPrecision.glsl\x3e\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nattribute vec3 position;\nattribute vec2 uv0;\nvarying vec2 vUV;\nvoid main(void) {\n  vUV \x3d uv0;\n  gl_Position \x3d proj * view * vec4((model * vec4(position, 1.0)).xyz, 1.0);\n}"},water:{"colorPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\n#include \x3cutil/fsPrecision.glsl\x3e\nuniform sampler2D texWaveNormal;\nuniform sampler2D texWavePerturbation;\n#include \x3cmaterials/water/waterDistortion.glsl\x3e\n#include \x3cutil/slice.glsl\x3e\n#ifdef RECEIVE_SHADOWS\nuniform sampler2D depthTex;\nuniform int shadowMapNum;\nuniform vec4 shadowMapDistance;\nuniform mat4 shadowMapMatrix[4];\nuniform float depthHalfPixelSz;\nvarying float linearDepth;\n#include \x3cutil/shadow.glsl\x3e\n#endif\n#include \x3cmaterials/water/waterSurface.glsl\x3e\nuniform vec4 waterColor;\nuniform vec3 lightingMainDirection;\nuniform int shadowsEnabled;\nuniform vec3 camPos;\nuniform float timeElapsed;\nvarying vec2 uvOut;\nvarying vec3 posOut;\nvarying vec3 normalOut;\nvarying mat3 tbnMatrix;\nvoid main() {\n  discardBySlice(posOut);\n  vec3 localUp \x3d normalOut;\n  vec2 uv \x3d uvOut;\n  vec3 tangentNormal \x3d getSurfaceNormal(uv, timeElapsed);\n  vec3 n \x3d normalize(tbnMatrix * tangentNormal);\n  vec3 v \x3d -normalize(posOut - camPos);\n  vec3 l \x3d normalize(-lightingMainDirection);\n  float shadow \x3d 1.0;\n#ifdef RECEIVE_SHADOWS\n  if(shadowsEnabled \x3d\x3d 1) {\n    shadow \x3d 1.0 - evalShadow(posOut, linearDepth, depthTex, shadowMapNum, shadowMapDistance, shadowMapMatrix, depthHalfPixelSz);\n  }\n#endif\n  vec4 final \x3d vec4(getSeaColor(n, v, l, waterColor.rgb, localUp, shadow), waterColor.w);\n  gl_FragColor \x3d vec4(pow(final.rgb, vec3( 1.0 / 2.2)), final.w);\n  gl_FragColor \x3d highlightSlice(gl_FragColor, posOut);\n}",
"colorPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\n#include \x3cmaterials/water/normalsUtils.glsl\x3e\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nuniform vec3 localOrigin;\nattribute vec3 position;\nattribute vec2 uv0;\n#include \x3cmaterials/defaultMaterial/commonFunctions.glsl\x3e\nvarying vec2 uvOut;\nvarying vec3 posOut;\nvarying vec3 normalOut;\nvarying mat3 tbnMatrix;\n#ifdef RECEIVE_SHADOWS\nvarying float linearDepth;\n#endif\nvoid main(void) {\n  uvOut \x3d uv0;\n  posOut \x3d calculateVPos();\n  normalOut \x3d getLocalUp(posOut, localOrigin);\n  tbnMatrix \x3d getTBNMatrix(normalOut);\n  gl_Position \x3d proj * view * vec4(posOut.xyz, 1.0);\n  #ifdef RECEIVE_SHADOWS\n    linearDepth \x3d gl_Position.w;\n  #endif\n}",
"drapedColorPass.frag":"#include \x3cutil/fsPrecision.glsl\x3e\nuniform vec4 waterColor;\nvoid main() {\n  gl_FragColor \x3d waterColor;\n}","drapedColorPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\n#include \x3cmaterials/water/normalsUtils.glsl\x3e\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nuniform vec3 localOrigin;\nattribute vec3 position;\n#include \x3cmaterials/defaultMaterial/commonFunctions.glsl\x3e\nvarying vec3 posOut;\nvoid main(void) {\n  posOut \x3d calculateVPos();\n  gl_Position \x3d proj * view * vec4(posOut.xyz, 1.0);\n}",
"normalPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\n#include \x3cutil/fsPrecision.glsl\x3e\nuniform sampler2D texWaveNormal;\nuniform sampler2D texWavePerturbation;\n#include \x3cmaterials/water/waterDistortion.glsl\x3e\n#include \x3cutil/slice.glsl\x3e\nuniform float timeElapsed;\nvarying vec2 uvOut;\nvarying vec3 posOut;\nvoid main() {\n  discardBySlice(posOut);\n  vec2 uv \x3d uvOut;\n  vec3 tangentNormal \x3d getSurfaceNormal(uv, timeElapsed);\n  tangentNormal \x3d normalize(tangentNormal);\n  gl_FragColor \x3d vec4((tangentNormal + vec3(1.0)) * 0.5, 0.0);\n}",
"normalPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\n#include \x3cmaterials/water/normalsUtils.glsl\x3e\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nuniform vec3 localOrigin;\nattribute vec3 position;\nattribute vec2 uv0;\n#include \x3cmaterials/defaultMaterial/commonFunctions.glsl\x3e\nvarying vec3 posOut;\nvarying vec2 uvOut;\nvoid main(void) {\n  uvOut \x3d uv0;\n  posOut \x3d calculateVPos();\n  gl_Position \x3d proj * view * vec4(posOut.xyz, 1.0);\n}","normalsUtils.glsl":"vec3 getLocalUp(in vec3 pos, in vec3 origin) {\n  #if VIEWING_MODE \x3d\x3d VIEWING_MODE_GLOBAL\n    return normalize(pos + origin);\n  #else\n    return vec3(0.0, 0.0, 1.0);\n  #endif\n}\nmat3 getTBNMatrix(in vec3 n) {\n  #if VIEWING_MODE \x3d\x3d VIEWING_MODE_GLOBAL\n    vec3 t \x3d normalize(cross(vec3(0.0, 0.0, 1.0), n));\n    vec3 b \x3d normalize(cross(n, t));\n    return mat3(t, b, n);\n  #else\n    vec3 t \x3d vec3(1.0, 0.0, 0.0);\n    vec3 b \x3d normalize(cross(n, t));\n    return mat3(t, b, n);\n  #endif\n}",
"waterDistortion.glsl":"uniform vec3 octaveTextureRepeat;\nuniform vec4 waveParams;\nuniform vec2 waveDirection;\nconst vec2  FLOW_JUMP \x3d vec2(6.0/25.0, 5.0/24.0);\nvec2 textureDenormalized2D(sampler2D _tex, vec2 _uv) {\n  return 2.0 * texture2D(_tex, _uv).rg - 1.0;\n}\nfloat sampleNoiseTexture(vec2 _uv) {\n  return texture2D(texWavePerturbation, _uv).b;\n}\nvec3 textureDenormalized3D(sampler2D _tex, vec2 _uv) {\n  return 2.0 * texture2D(_tex, _uv).rgb - 1.0;\n}\nfloat computeProgress(vec2 uv, float time) {\n  return fract(time);\n}\nfloat computeWeight(vec2 uv, float time) {\n  float progress \x3d computeProgress(uv, time);\n  return 1.0 - abs(1.0 - 2.0 * progress);\n}\nvec3 computeUVPerturbedWeigth(sampler2D texFlow, vec2 uv, vec2 _waveDir, float time, float phaseOffset) {\n  float flowStrength \x3d waveParams[2];\n  float flowOffset \x3d waveParams[3];\n  vec2 flowVector \x3d textureDenormalized2D(texFlow, uv) * flowStrength;\n  float progress \x3d computeProgress(uv, time + phaseOffset);\n  float weight \x3d computeWeight(uv, time + phaseOffset);\n  vec2 result \x3d uv;\n  result -\x3d flowVector * (progress + flowOffset);\n  result +\x3d phaseOffset;\n  result +\x3d (time - progress) * FLOW_JUMP;\n  return vec3(result, weight);\n}\nconst float TIME_NOISE_TEXTURE_REPEAT \x3d 0.3737;\nconst float TIME_NOISE_STRENGTH \x3d 7.77;\nvec3 getWaveLayer(sampler2D _texNormal, sampler2D _dudv, vec2 _uv, vec2 _waveDir, float time) {\n  float waveStrength \x3d waveParams[0];\n  vec2 waveMovement \x3d time * waveDirection;\n  float timeNoise \x3d sampleNoiseTexture(_uv * TIME_NOISE_TEXTURE_REPEAT) * TIME_NOISE_STRENGTH;\n  vec3 uv_A \x3d computeUVPerturbedWeigth(_dudv, _uv + waveMovement, _waveDir, time + timeNoise, 0.0);\n  vec3 uv_B \x3d computeUVPerturbedWeigth(_dudv, _uv + waveMovement, _waveDir, time + timeNoise, 0.5);\n  vec3 normal_A \x3d textureDenormalized3D(_texNormal, uv_A.xy) * uv_A.z;\n  vec3 normal_B \x3d textureDenormalized3D(_texNormal, uv_B.xy) * uv_B.z;\n  vec3 mixNormal \x3d normalize(normal_A + normal_B);\n  mixNormal.xy *\x3d waveStrength;\n  mixNormal.z \x3d sqrt(1.0 - dot(mixNormal.xy, mixNormal.xy));\n  return mixNormal;\n}\nvec3 getSurfaceNormal(vec2 _uv, float _time) {\n  float waveTextureRepeat \x3d waveParams[1];\n  return getWaveLayer(texWaveNormal, texWavePerturbation, _uv * waveTextureRepeat, waveDirection, _time);\n}",
"waterSurface.glsl":"#ifdef OVERLAY\n  const vec3 skyZenitColor \x3d vec3(0, 0.6, 0.9);\n  const vec3 skyColor \x3d vec3(0.72, 0.92, 1.0);\n  float f0Sky \x3d 0.02;\n  float f0maxSky \x3d 1.0;\n  float expSky \x3d 5.0;\n  float roughness \x3d 0.06;\n  float f0maxSpec \x3d 0.1;\n#else\n  uniform vec3 skyColor;\n  uniform vec3 skyZenitColor;\n  uniform float f0Sky;\n  uniform float f0maxSky;\n  uniform float expSky;\n  uniform float roughness;\n  uniform float f0maxSpec;\n#endif\nuniform vec3 lightIntensity;\n#include \x3cutil/pbrUtils.glsl\x3e\nPBRShading shadingInfo;\nvec3 getSkyColor(in float cosTheta, in vec3 horizon, in vec3 zenit) {\n  float exponent \x3d pow((1.0 - cosTheta), expSky);\n  return horizon * exponent + zenit * (1.0 -  exponent);\n}\nvec3 getSeaColor(in vec3 n, in vec3 v, in vec3 l, vec3 color,  in vec3 localUp, in float shadow) {\n  vec3 seaWaterColor \x3d pow(color.rgb, vec3(2.2));\n  vec3 h \x3d normalize(l + v);\n  shadingInfo.NdotL \x3d clamp(dot(n, l), 0.0, 1.0);\n  shadingInfo.NdotV \x3d clamp(dot(n, v), 0.001, 1.0);\n  shadingInfo.VdotN \x3d clamp(dot(v, n), 0.001, 1.0);\n  shadingInfo.NdotH \x3d clamp(dot(n, h), 0.0, 1.0);\n  shadingInfo.VdotH \x3d clamp(dot(v, h), 0.0, 1.0);\n  shadingInfo.LdotH \x3d clamp(dot(l, h), 0.0, 1.0);\n  float upDotV \x3d max(dot(localUp,v), 0.0);\n  vec3 skyHorizon \x3d  pow(skyColor, vec3(2.2));\n  vec3 skyZenit \x3d  pow(skyZenitColor, vec3(2.2));\n  vec3 reflectedSkyColor \x3d getSkyColor(upDotV, skyHorizon, skyZenit );\n  float upDotL \x3d max(dot(localUp,l),0.0);\n  reflectedSkyColor *\x3d 0.1 + upDotL * 0.9;\n  float shadowModifier \x3d clamp(shadow, 0.8, 1.0);\n  vec3 reflSky \x3d fresnelReflection(shadingInfo.VdotN, vec3(f0Sky), f0maxSky) * reflectedSkyColor * shadowModifier;\n  vec3 reflSea \x3d seaWaterColor * mix(reflectedSkyColor, upDotL * lightIntensity, 2.0 / 3.0) * shadowModifier;\n  vec3 specular \x3d vec3(0.0);\n  if(upDotV \x3e 0.0 \x26\x26 upDotL \x3e 0.0) {\n    vec3 specularSun \x3d calculateSpecularReflectanceWater(shadingInfo, roughness, vec3(0.02), f0maxSpec);\n    vec3 incidentLight \x3d lightIntensity * shadow;\n    specular \x3d shadingInfo.NdotL * incidentLight * specularSun;\n  }\n  return tonemapACES(reflSky + reflSea + specular);\n}"}},
misc:{"blendLayers.frag":"#include \x3cutil/fsPrecision.glsl\x3e\nvarying vec2 uv;\nuniform sampler2D tex;\nuniform float opacity;\nvoid main() {\n  vec4 color \x3d texture2D(tex, uv);\n  gl_FragColor \x3d vec4(color.xyz, 1.0) * color.a * opacity;\n}","blendLayers.vert":"#include \x3cutil/vsPrecision.glsl\x3e\nattribute vec3 position;\nattribute vec2 uv0;\nuniform float scale;\nuniform vec2 offset;\nvarying vec2 uv;\nvoid main(void) {\n  gl_Position \x3d vec4(position, 1.0);\n  uv \x3d uv0 * scale + offset;;\n}",
"texOnly.frag":"#include \x3cutil/fsPrecision.glsl\x3e\nuniform sampler2D tex;\nuniform vec4 color;\nvarying vec2 vtc;\nvoid main() {\n  vec4 texColor \x3d texture2D(tex, vtc);\n  gl_FragColor \x3d texColor * color;\n}","texOnly.vert":"#include \x3cutil/vsPrecision.glsl\x3e\nattribute vec3 position;\nattribute vec2 uv0;\nvarying vec2 vtc;\nvoid main(void) {\n  gl_Position \x3d vec4(position, 1.0);\n  vtc \x3d uv0;\n}"},pointRenderer:{"pointRenderer.frag":"#include \x3cutil/fsPrecision.glsl\x3e\n#include \x3cutil/encoding.glsl\x3e\n#ifdef DEPTH_PASS\nvarying float depth;\n#else\nvarying vec3 vColor;\n#endif\nvoid main(void) {\n  vec2 vOffset \x3d gl_PointCoord - vec2(0.5, 0.5);\n  float r2 \x3d dot(vOffset, vOffset);\n  if (r2 \x3e 0.25) {\n    discard;\n  }\n#ifdef DEPTH_PASS\n  gl_FragColor \x3d float2rgba(depth);\n#else\n  gl_FragColor \x3d vec4(vColor, 1.0);\n#endif\n}",
"pointRenderer.vert":"#include \x3cutil/slice.glsl\x3e\n#include \x3cutil/vsPrecision.glsl\x3e\nattribute vec3 aPosition;\nattribute vec3 aColor;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform vec2 uScreenMinMaxSize;\nuniform vec2 uPointScale;\nuniform vec3 uClipMin;\nuniform vec3 uClipMax;\n#ifdef DEPTH_PASS\nuniform vec2 nearFar;\nvarying float depth;\n#else\nvarying vec3 vColor;\n#endif\nvoid main(void) {\n  if (aPosition.x \x3c uClipMin.x || aPosition.y \x3c uClipMin.y || aPosition.z \x3c uClipMin.z ||\n      aPosition.x \x3e uClipMax.x || aPosition.y \x3e uClipMax.y || aPosition.z \x3e uClipMax.z) {\n    gl_Position \x3d vec4(0.0,0.0,0.0,2.0);\n    gl_PointSize \x3d 0.0;\n    return;\n  }\n  if (rejectBySlice(aPosition)) {\n    gl_Position \x3d vec4(0.0,0.0,0.0,2.0);\n    gl_PointSize \x3d 0.0;\n    return;\n  }\n  vec4 camera \x3d uModelViewMatrix * vec4(aPosition, 1.0);\n  float pointSize \x3d uPointScale.x;\n  vec4 position \x3d uProjectionMatrix * camera;\n#ifdef DRAW_SCREEN_SIZE\n    float clampedScreenSize \x3d pointSize;\n#else\n    float pointRadius \x3d 0.5 * pointSize;\n    vec4 cameraOffset \x3d camera + vec4(0.0, pointRadius, 0.0, 0.0);\n    vec4 positionOffset \x3d uProjectionMatrix * cameraOffset;\n    float radius \x3d abs(positionOffset.y - position.y);\n    float viewHeight \x3d uPointScale.y;\n    float screenPointSize \x3d (radius / position.w) * viewHeight;\n    float clampedScreenSize \x3d clamp(screenPointSize, uScreenMinMaxSize.x, uScreenMinMaxSize.y);\n    camera.xyz -\x3d normalize(camera.xyz) * pointRadius * clampedScreenSize / screenPointSize;\n    position \x3d uProjectionMatrix * camera;\n#endif\n  gl_PointSize \x3d clampedScreenSize;\n  gl_Position \x3d position;\n#ifdef DEPTH_PASS\n  depth \x3d (-camera.z - nearFar[0]) / (nearFar[1] - nearFar[0]);\n#else\n  vColor \x3d aColor;\n#endif\n}"},
renderer:{highlight:{"apply.frag":"#include \x3cutil/fsPrecision.glsl\x3e\nuniform sampler2D tex;\nuniform sampler2D origin;\nuniform vec4 color;\nuniform float outlineSize;\nuniform float blurSize;\nuniform vec4 opacities;\nvarying vec2 uv;\nvoid main() {\n  #if defined(GRID_OPTIMIZATION) \x26\x26 defined(GRID_DEBUG)\n    gl_FragColor \x3d vec4(uv, 0.0, 1.0);\n  #else\n    vec4 blurredHighlightValue \x3d texture2D(tex, uv);\n    float highlightIntensity \x3d blurredHighlightValue.a;\n    if (highlightIntensity \x3d\x3d 0.0) {\n      discard;\n    }\n    vec4 origin_color \x3d texture2D(origin, uv);\n    float outlineIntensity;\n    float fillIntensity;\n    if (blurredHighlightValue.g \x3e blurredHighlightValue.b) {\n      outlineIntensity \x3d color.w * opacities[1];\n      fillIntensity \x3d color.w * opacities[3];\n    }\n    else {\n      outlineIntensity \x3d color.w * opacities[0];\n      fillIntensity \x3d color.w * opacities[2];\n    }\n    float inner \x3d 1.0 - outlineSize / 9.0;\n    float outer \x3d 1.0 - (outlineSize + blurSize) / 9.0;\n    float outlineFactor \x3d smoothstep(outer, inner, highlightIntensity);\n    float fillFactor \x3d any(notEqual(origin_color, vec4(0.0, 0.0, 0.0, 0.0))) ? 1.0 : 0.0;\n    float intensity \x3d outlineIntensity * outlineFactor * (1.0 - fillFactor) + fillIntensity * fillFactor;\n    gl_FragColor \x3d vec4(color.xyz, intensity);\n  #endif\n}",
"apply.vert":"#include \x3cutil/vsPrecision.glsl\x3e\nattribute vec2 position;\nvarying vec2 uv;\n#ifdef GRID_OPTIMIZATION\n  attribute vec2 uv0;\n  uniform sampler2D coverageTex;\n#endif\nvoid main() {\n  #ifdef GRID_OPTIMIZATION\n    #ifdef GRID_DEBUG\n      vec4 cov \x3d texture2D(coverageTex, uv0);\n      if (cov.r \x3d\x3d 0.0 || cov.g \x3d\x3d 1.0 || cov.b \x3d\x3d 1.0) {\n        gl_Position \x3d vec4(0.0);\n        return;\n      }\n      gl_Position \x3d vec4(position, .0, 1.0);\n      uv \x3d uv0;\n      return;\n    #else\n      vec4 cov \x3d texture2D(coverageTex, uv0);\n      if (cov.r \x3d\x3d 0.0) {\n        gl_Position \x3d vec4(0.0);\n        return;\n      }\n    #endif\n  #endif\n  gl_Position \x3d vec4(position, .0, 1.0);\n  uv \x3d position.xy * .5 + vec2(.5);\n}",
"blur.frag":"#include \x3cutil/fsPrecision.glsl\x3e\nuniform sampler2D tex;\n#ifdef GRID_OPTIMIZATION\n  uniform vec2 blurSize;\n  varying vec3 blurCoordinate;\n#else\n  varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n#endif\nvoid main() {\n  #ifdef GRID_OPTIMIZATION\n    vec2 uv \x3d blurCoordinate.xy;\n    vec4 center \x3d texture2D(tex, uv);\n    if (blurCoordinate.z \x3d\x3d 1.0) {\n      gl_FragColor \x3d center;\n    }\n    else {\n      vec4 sum \x3d vec4(0.0);\n      #if GAUSSIAN_SAMPLES \x3d\x3d 3\n        sum +\x3d center * 0.204164;\n        sum +\x3d texture2D(tex, uv + blurSize * 1.407333) * 0.304005;\n        sum +\x3d texture2D(tex, uv - blurSize * 1.407333) * 0.304005;\n      #elif GAUSSIAN_SAMPLES \x3d\x3d 5\n        sum +\x3d center * 0.204164;\n        sum +\x3d texture2D(tex, uv + blurSize * 1.407333) * 0.304005;\n        sum +\x3d texture2D(tex, uv - blurSize * 1.407333) * 0.304005;\n        sum +\x3d texture2D(tex, uv + blurSize * 3.294215) * 0.093913;\n        sum +\x3d texture2D(tex, uv - blurSize * 3.294215) * 0.093913;\n      #elif GAUSSIAN_SAMPLES \x3d\x3d 7\n        sum +\x3d center * 0.204164;\n        sum +\x3d texture2D(tex, uv + blurSize * 1.407333) * 0.304005;\n        sum +\x3d texture2D(tex, uv - blurSize * 1.407333) * 0.304005;\n        sum +\x3d texture2D(tex, uv + blurSize * 3.294215) * 0.093913;\n        sum +\x3d texture2D(tex, uv - blurSize * 3.294215) * 0.093913;\n        sum +\x3d texture2D(tex, uv + blurSize * 5.1) * 0.03;\n        sum +\x3d texture2D(tex, uv - blurSize * 5.1) * 0.03;\n      #elif GAUSSIAN_SAMPLES \x3d\x3d 9\n        sum +\x3d center * 0.154164;\n        sum +\x3d texture2D(tex, uv + blurSize * 1.5) * 0.204005;\n        sum +\x3d texture2D(tex, uv - blurSize * 1.5) * 0.204005;\n        sum +\x3d texture2D(tex, uv + blurSize * 3.5) * 0.123913;\n        sum +\x3d texture2D(tex, uv - blurSize * 3.5) * 0.123913;\n        sum +\x3d texture2D(tex, uv + blurSize * 5.5) * 0.123913;\n        sum +\x3d texture2D(tex, uv - blurSize * 5.5) * 0.123913;\n        sum +\x3d texture2D(tex, uv + blurSize * 7.5) * 0.05;\n        sum +\x3d texture2D(tex, uv - blurSize * 7.5) * 0.05;\n      #endif\n      gl_FragColor \x3d sum;\n    }\n  #else\n    vec4 sum \x3d vec4(0.0);\n    #if GAUSSIAN_SAMPLES \x3d\x3d 3\n      sum +\x3d texture2D(tex, blurCoordinates[0]) * 0.204164;\n      sum +\x3d texture2D(tex, blurCoordinates[1]) * 0.304005;\n      sum +\x3d texture2D(tex, blurCoordinates[2]) * 0.304005;\n    #elif GAUSSIAN_SAMPLES \x3d\x3d 5\n      sum +\x3d texture2D(tex, blurCoordinates[0]) * 0.204164;\n      sum +\x3d texture2D(tex, blurCoordinates[1]) * 0.304005;\n      sum +\x3d texture2D(tex, blurCoordinates[2]) * 0.304005;\n      sum +\x3d texture2D(tex, blurCoordinates[3]) * 0.093913;\n      sum +\x3d texture2D(tex, blurCoordinates[4]) * 0.093913;\n    #elif GAUSSIAN_SAMPLES \x3d\x3d 7\n      sum +\x3d texture2D(tex, blurCoordinates[0]) * 0.204164;\n      sum +\x3d texture2D(tex, blurCoordinates[1]) * 0.304005;\n      sum +\x3d texture2D(tex, blurCoordinates[2]) * 0.304005;\n      sum +\x3d texture2D(tex, blurCoordinates[3]) * 0.093913;\n      sum +\x3d texture2D(tex, blurCoordinates[4]) * 0.093913;\n      sum +\x3d texture2D(tex, blurCoordinates[5]) * 0.03;\n      sum +\x3d texture2D(tex, blurCoordinates[6]) * 0.03;\n    #elif GAUSSIAN_SAMPLES \x3d\x3d 9\n      sum +\x3d texture2D(tex, blurCoordinates[0]) * 0.154164;\n      sum +\x3d texture2D(tex, blurCoordinates[1]) * 0.204005;\n      sum +\x3d texture2D(tex, blurCoordinates[2]) * 0.204005;\n      sum +\x3d texture2D(tex, blurCoordinates[3]) * 0.123913;\n      sum +\x3d texture2D(tex, blurCoordinates[4]) * 0.123913;\n      sum +\x3d texture2D(tex, blurCoordinates[5]) * 0.09;\n      sum +\x3d texture2D(tex, blurCoordinates[6]) * 0.09;\n      sum +\x3d texture2D(tex, blurCoordinates[7]) * 0.05;\n      sum +\x3d texture2D(tex, blurCoordinates[8]) * 0.05;\n    #endif\n    gl_FragColor \x3d sum;\n  #endif\n}",
"blur.vert":"#include \x3cutil/vsPrecision.glsl\x3e\nattribute vec2 position;\nattribute vec2 uv0;\n#ifdef GRID_OPTIMIZATION\n  uniform sampler2D coverageTex;\n  varying vec3 blurCoordinate;\n#else\n  uniform vec2 blurSize;\n  varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n#endif\nvoid main() {\n  gl_Position \x3d vec4(position, 0.0, 1.0);\n  #ifdef GRID_OPTIMIZATION\n    vec4 cov \x3d texture2D(coverageTex, uv0);\n    if (cov.r \x3d\x3d 0.0) {\n      gl_Position \x3d vec4(0.0);\n    }\n    blurCoordinate \x3d vec3(gl_Position.xy * .5 + vec2(.5), max(cov.g, cov.b));\n  #else\n    vec2 uv \x3d position.xy * .5 + vec2(.5);\n    #if GAUSSIAN_SAMPLES \x3d\x3d 3\n      blurCoordinates[0] \x3d uv;\n      blurCoordinates[1] \x3d uv + blurSize * 1.407333;\n      blurCoordinates[2] \x3d uv - blurSize * 1.407333;\n    #elif GAUSSIAN_SAMPLES \x3d\x3d 5\n      blurCoordinates[0] \x3d uv;\n      blurCoordinates[1] \x3d uv + blurSize * 1.407333;\n      blurCoordinates[2] \x3d uv - blurSize * 1.407333;\n      blurCoordinates[3] \x3d uv + blurSize * 3.294215;\n      blurCoordinates[4] \x3d uv - blurSize * 3.294215;\n    #elif GAUSSIAN_SAMPLES \x3d\x3d 7\n      blurCoordinates[0] \x3d uv;\n      blurCoordinates[1] \x3d uv + blurSize * 1.407333;\n      blurCoordinates[2] \x3d uv - blurSize * 1.407333;\n      blurCoordinates[3] \x3d uv + blurSize * 3.294215;\n      blurCoordinates[4] \x3d uv - blurSize * 3.294215;\n      blurCoordinates[5] \x3d uv + blurSize * 5.1;\n      blurCoordinates[6] \x3d uv - blurSize * 5.1;\n    #elif GAUSSIAN_SAMPLES \x3d\x3d 9\n      blurCoordinates[0] \x3d uv;\n      blurCoordinates[1] \x3d uv + blurSize * 1.407333;\n      blurCoordinates[2] \x3d uv - blurSize * 1.407333;\n      blurCoordinates[3] \x3d uv + blurSize * 3.294215;\n      blurCoordinates[4] \x3d uv - blurSize * 3.294215;\n      blurCoordinates[5] \x3d uv + blurSize * 5.1;\n      blurCoordinates[6] \x3d uv - blurSize * 5.1;\n      blurCoordinates[7] \x3d uv + blurSize * 7.1;\n      blurCoordinates[8] \x3d uv - blurSize * 7.1;\n    #endif\n  #endif\n}",
"downsample.frag":"#include \x3cutil/fsPrecision.glsl\x3e\nuniform sampler2D tex;\nuniform vec2 invFramebufferDim;\nvoid main() {\n  vec2 coord \x3d gl_FragCoord.xy * invFramebufferDim;\n  vec4 value \x3d texture2D(tex, coord);\n  float mx \x3d floor(max(value.g, value.b));\n  gl_FragColor \x3d vec4(ceil(value.r), mx, mx, 1.0);\n}","downsample.vert":"#include \x3cutil/vsPrecision.glsl\x3e\nattribute vec2 position;\nvoid main() {\n  gl_Position \x3d vec4(vec2(1.0) - position * 2.0, .0, 1.0);\n}"},
laserLine:{"laserLine.frag":"#include \x3cutil/enableExtensions.glsl\x3e\n#include \x3cutil/fsPrecision.glsl\x3e\n#include \x3cutil/depth.glsl\x3e\nuniform sampler2D depthMap;\nuniform vec2 nearFar;\nuniform vec4 projInfo;\nuniform vec2 zScale;\nuniform float maxPixelDistance;\nuniform vec4 focusPlane;\nuniform vec4 focusSphere;\nuniform vec4 segmentPlane;\nuniform vec3 segmentStart;\nuniform vec3 segmentEnd;\nuniform vec3 glowColor;\nuniform float glowWidth;\nuniform vec3 innerColor;\nuniform float innerWidth;\nuniform float globalAlpha;\nvarying vec2 uv;\n#define INFINITY 100000.0\nvec3 reconstructPosition(vec2 fragCoord, float depth) {\n  return vec3((fragCoord * projInfo.xy + projInfo.zw) * (zScale.x * depth + zScale.y), depth);\n}\nfloat planeDistancePixels(vec4 plane, vec3 pos) {\n  float dist \x3d dot(plane.xyz, pos) + plane.w;\n  float width \x3d fwidth(dist);\n  dist /\x3d min(width, maxPixelDistance);\n  return abs(dist);\n}\nfloat sphereDistancePixels(vec4 sphere, vec3 pos) {\n  float dist \x3d distance(sphere.xyz, pos) - sphere.w;\n  float width \x3d fwidth(dist);\n  dist /\x3d min(width, maxPixelDistance);\n  return abs(dist);\n}\nvec4 blendPremultiplied(vec4 source, vec4 dest) {\n  float oneMinusSourceAlpha \x3d 1.0 - source.a;\n  return vec4(\n    source.rgb + dest.rgb * oneMinusSourceAlpha,\n    source.a + dest.a * oneMinusSourceAlpha\n  );\n}\nvec4 premultipliedColor(vec3 rgb, float alpha) {\n  return vec4(rgb * alpha, alpha);\n}\nvec4 laserLineProfile(float dist) {\n  if (dist \x3e glowWidth) {\n    return vec4(0.0);\n  }\n  float innerAlpha \x3d (1.0 - smoothstep(0.0, innerWidth, dist));\n  float glowAlpha \x3d pow(max(0.0, 1.0 - dist / glowWidth), 8.0);\n  return blendPremultiplied(\n    premultipliedColor(innerColor, innerAlpha),\n    premultipliedColor(glowColor, glowAlpha)\n  );\n}\nvoid main() {\n  float depth \x3d linearDepth(depthMap, uv, nearFar);\n  if (-depth \x3d\x3d nearFar[0]) {\n    discard;\n  }\n  vec3 pos \x3d reconstructPosition(gl_FragCoord.xy, depth);\n  float ddepth \x3d fwidth(depth);\n  float depthDiscontinuityAlpha \x3d 1.0 - smoothstep(0.0, 0.01, -ddepth / depth);\n  vec3 normal \x3d normalize(cross(dFdx(pos), dFdy(pos)));\n  float focusPlaneDistance \x3d planeDistancePixels(focusPlane, pos);\n  float focusSphereDistance \x3d sphereDistancePixels(focusSphere, pos);\n  float segmentDistance \x3d INFINITY;\n  float segmentLength \x3d length(segmentEnd - segmentStart);\n  vec3 segmentDir \x3d (segmentEnd - segmentStart) / segmentLength;\n  float t \x3d dot(segmentDir, pos - segmentStart);\n  if (segmentLength \x3e 0.0 \x26\x26 t \x3e\x3d 0.0 \x26\x26 t \x3c\x3d segmentLength) {\n    segmentDistance \x3d planeDistancePixels(segmentPlane, pos);\n  }\n  vec4 focusPlaneColor \x3d laserLineProfile(focusPlaneDistance);\n  vec4 focusSphereColor \x3d laserLineProfile(focusSphereDistance);\n  vec4 segmentColor \x3d laserLineProfile(segmentDistance);\n  float focusPlaneAlpha \x3d 1.0 - smoothstep(0.995, 0.999, abs(dot(normal, focusPlane.xyz)));\n  float focusSphereAlpha \x3d 1.0 - smoothstep(0.995, 0.999, abs(dot(normal, normalize(pos - focusSphere.xyz))));\n  float segmentAlpha \x3d 1.0 - smoothstep(0.995, 0.999, abs(dot(normal, segmentPlane.xyz)));\n  vec4 color \x3d max(\n    focusPlaneColor * focusPlaneAlpha,\n    max(\n      focusSphereColor * focusSphereAlpha,\n      segmentColor * segmentAlpha\n    )\n  );\n  gl_FragColor \x3d color * globalAlpha * depthDiscontinuityAlpha;\n}"},
offscreen:{"composite.frag":"#include \x3cutil/fsPrecision.glsl\x3e\nuniform sampler2D tex;\nvarying vec2 vtc;\nvoid main() {\n  gl_FragColor \x3d texture2D(tex, vtc);\n}","compositeOccluded.frag":"#include \x3cutil/fsPrecision.glsl\x3e\nuniform sampler2D occludedColorMap;\nuniform float opacity;\nvarying vec2 vtc;\nvoid main() {\n  vec4 occludedColor \x3d texture2D(occludedColorMap, vtc);\n  gl_FragColor \x3d occludedColor * opacity;\n}","compositeTransparentToHUDVisibility.frag":"#include \x3cutil/fsPrecision.glsl\x3e\nuniform sampler2D tex;\nvarying vec2 vtc;\nvoid main() {\n  gl_FragColor \x3d vec4(1.0 - texture2D(tex, vtc).a);\n}",
"offscreen.vert":"#include \x3cutil/vsPrecision.glsl\x3e\nattribute vec2 position;\nvarying vec2 vtc;\nvoid main(void) {\n  gl_Position \x3d vec4(position.xy, 0.0, 1.0);\n  vtc \x3d position.xy * 0.5 + 0.5;\n}"},ssao:{"blur.frag":"#include \x3cutil/enableExtensions.glsl\x3e\n#include \x3cutil/fsPrecision.glsl\x3e\n#include \x3cutil/depth.glsl\x3e\n#ifndef RADIUS\n#define RADIUS 4\n#endif\nuniform sampler2D normalMap;\nuniform sampler2D depthMap;\nuniform sampler2D tex;\nuniform vec2 blurSize;\nuniform float g_BlurFalloff;\nuniform float projScale;\nuniform vec2 nearFar;\nuniform vec2 zScale;\nvarying vec2 uv;\nfloat BlurFunction(vec2 uv, float r, float center_d, inout float w_total, float sharpness) {\n  float c \x3d texture2D(tex, uv).r;\n  float d \x3d linearDepth(depthMap, uv, nearFar);\n  float ddiff \x3d d - center_d;\n  float w \x3d exp(-r*r*g_BlurFalloff - ddiff*ddiff*sharpness);\n  w_total +\x3d w;\n  return w*c;\n}\nvoid main(void) {\n  float b \x3d 0.0;\n  float w_total \x3d 0.0;\n  float center_d \x3d linearDepth(depthMap, uv, nearFar);\n  float sharpness \x3d -0.05 * projScale/(center_d*zScale.x+zScale.y);\n  for (int r \x3d -RADIUS; r \x3c\x3d RADIUS; ++r) {\n    float rf \x3d float(r);\n    vec2 uvOffset \x3d uv + rf*blurSize;\n    b +\x3d BlurFunction(uvOffset, rf, center_d, w_total, sharpness);\n  }\n  gl_FragColor \x3d vec4(b/w_total);\n}",
"ssao.frag":"#include \x3cutil/enableExtensions.glsl\x3e\n#include \x3cutil/fsPrecision.glsl\x3e\n#include \x3cutil/depth.glsl\x3e\n#ifndef SAMPLES\n#define SAMPLES 4\n#endif\nuniform mat4 projMatrixInv;\nuniform sampler2D normalMap;\nuniform sampler2D depthMap;\nuniform float intensity;\nuniform float projScale;\nuniform float radius;\nuniform vec2 nearFar;\nuniform vec4 projInfo;\nuniform vec2 screenDimensions;\nuniform vec3 pSphere[SAMPLES];\nuniform vec2 rnmScale;\nuniform sampler2D rnm;\nuniform vec2 zScale;\nvarying vec2  uv;\nvarying vec4  camPos;\nfloat fallOffFunction(float vv, float vn, float bias) {\n  float radius2 \x3d radius * radius;\n  float f \x3d max(radius2 - vv, 0.0); return f * f * f * max(vn-bias, 0.0);\n}\nfloat aoValueFromPositionsAndNormal(vec3 C, vec3 n_C, vec3 Q) {\n  vec3 v \x3d Q - C;\n  float vv \x3d dot(v, v);\n  float vn \x3d dot(normalize(v), n_C);\n  return fallOffFunction(vv, vn, 0.1);\n}\nvec3 reconstructCSPosition(vec2 S, float z) {\n  return vec3(( (S.xy) * projInfo.xy + projInfo.zw)*(z*zScale.x+zScale.y), z);\n}\nvoid main(void) {\n  vec3 fres \x3d normalize((texture2D(rnm, uv * rnmScale).xyz * 2.0) - vec3(1.0));\n  float currentPixelDepth \x3d linearDepth(depthMap, uv, nearFar);\n  if (-currentPixelDepth\x3enearFar.y || -currentPixelDepth\x3cnearFar.x) {\n    gl_FragColor \x3d vec4(0.0);\n    return;\n  }\n  vec3 currentPixelPos \x3d reconstructCSPosition(gl_FragCoord.xy,currentPixelDepth);\n  vec4 norm4 \x3d texture2D(normalMap, uv);\n  vec3 norm \x3d vec3(-1.0) + 2.0 * norm4.xyz;\n  bool isTerrain \x3d norm4.w\x3c0.5;\n  float sum \x3d .0;\n  vec4 occluderFragment;\n  vec3 ray;\n  vec3 tapPixelPos;\n  float ps \x3d projScale/(2.0*currentPixelPos.z*zScale.x+zScale.y);\n  for(int i \x3d 0; i \x3c SAMPLES; ++i) {\n    vec2 unitOffset \x3d reflect(pSphere[i], fres).xy;\n    vec2 offset \x3d vec2(-unitOffset*radius*ps);\n    if ( abs(offset.x)\x3c2.0 || abs(offset.y)\x3c2.0) continue;\n    vec2 tc \x3d vec2(gl_FragCoord.xy + offset);\n    if (tc.x \x3c 0.0 || tc.y \x3c 0.0 || tc.x \x3e screenDimensions.x || tc.y \x3e screenDimensions.y) continue;\n    vec2 tcTap \x3d tc/screenDimensions;\n    float occluderFragmentDepth \x3d linearDepth(depthMap, tcTap, nearFar);\n    if (isTerrain) {\n      bool isTerrainTap \x3d texture2D(normalMap, tcTap).w\x3c0.5;\n      if (isTerrainTap) {\n        continue;\n      }\n    }\n    tapPixelPos \x3d reconstructCSPosition(tc, occluderFragmentDepth);\n    sum+\x3d aoValueFromPositionsAndNormal(currentPixelPos, norm, tapPixelPos);\n  }\n  float A \x3d max(1.0-sum*intensity/float(SAMPLES),0.0);\n  A \x3d (pow(A, 0.2) + 1.2 * A*A*A*A) / 2.2;\n  gl_FragColor \x3d vec4(A);\n}"}},
terrainRenderer:{"colorPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\n#include \x3cutil/fsPrecision.glsl\x3e\n#include \x3cutil/sceneLighting.glsl\x3e\n#include \x3cutil/screenSizePerspective.glsl\x3e\n#include \x3cutil/shadow.glsl\x3e\n#include \x3cutil/slice.glsl\x3e\n#include \x3cterrainRenderer/overlay.glsl\x3e\nuniform vec3 camPos;\nuniform vec3 lightDirection;\nuniform vec3 viewDirection;\nuniform sampler2D depthTex;\nuniform int shadowMapNum;\nuniform vec4 shadowMapDistance;\nuniform mat4 shadowMapMatrix[4];\nuniform float depthHalfPixelSz;\nuniform sampler2D ssaoTex;\nuniform vec4 viewportPixelSz;\nuniform sampler2D tex;\nuniform float opacity;\n#if defined(WIREFRAME_TEXTURE) || defined(TILE_BORDERS)\nstruct WireframeSettings {\n  float width;\n  float falloff;\n  float subdivision;\n  vec4 color;\n  float wireOpacity;\n  float surfaceOpacity;\n};\nuniform WireframeSettings wireframe;\n#endif\nvarying vec3 vnormal;\nvarying vec3 vpos;\nvarying vec2 vtc;\n#if defined(WIREFRAME_TEXTURE) || defined(TILE_BORDERS)\nvarying vec2 vuv;\n#endif\n#ifdef ATMOSPHERE\nvarying vec3 wnormal;\nvarying vec3 wlight;\n#endif\n#ifdef SCREEN_SIZE_PERSPECTIVE\nuniform vec4 screenSizePerspective;\nvarying float screenSizeDistanceToCamera;\nvarying float screenSizeCosAngle;\n#endif\nconst vec3 ambient \x3d vec3(0.2,0.2,0.2);\nconst vec3 diffuse \x3d vec3(0.8,0.8,0.8);\nconst float diffuseHardness \x3d 2.5;\nconst float sliceOpacity \x3d 0.2;\n#ifdef OVERLAY\nuniform sampler2D ovInnerColorTex;\nuniform sampler2D ovOuterColorTex;\nuniform sampler2D ovInnerWaterTex;\nuniform sampler2D ovOuterWaterTex;\nuniform float overlayOpacity;\nvarying vec4 vtcOverlay;\nvarying vec3 tbnTangent;\nvarying vec3 tbnBiTangent;\n#endif\n#ifdef RECEIVE_SHADOWS\nvarying float linearDepth;\n#endif\nfloat lum(vec3 c) {\n  float max \x3d max(max(c.r, c.g), c.b);\n  float min \x3d min(min(c.r, c.g), c.b);\n  return (min + max) * 0.5;\n}\n#ifdef ATMOSPHERE\nvec3 atmosphere(vec3 lightPos, vec3 normal, vec3 view) {\n  vec3 surfaceColor   \x3d vec3(0.0);\n  vec3 fuzzySpecColor \x3d vec3(1.0);\n  vec3 subColor       \x3d vec3(0.0);\n  float rollOff       \x3d 1.0;\n  vec3 Ln \x3d normalize(lightPos);\n  vec3 Nn \x3d normalize(normal);\n  vec3 Hn \x3d normalize(view + Ln);\n  float ldn \x3d dot(Ln, Nn);\n  float diffComp \x3d max(0.0, ldn);\n  float vdn \x3d clamp(1.0 - dot(view, Nn), 0.0, 1.0);\n  float ndv \x3d dot(view, Ln);\n  vec3 diffContrib \x3d surfaceColor * diffComp;\n  float subLamb \x3d max(0.0, smoothstep(-rollOff, 1.0, ldn) - smoothstep(0.0, 1.0, ldn));\n  vec3 subContrib \x3d subLamb * subColor;\n  vec3 vecColor \x3d vec3(vdn);\n  vec3 diffuseContrib \x3d (subContrib + diffContrib);\n  vec3 specularContrib \x3d (vecColor * fuzzySpecColor);\n  return (diffContrib + specularContrib) * rollOff;\n}\n#endif\nconst float GAMMA_EXP \x3d 0.4545454545;\nvoid main() {\n  vec3 a \x3d ambient;\n  float shadow \x3d 0.0;\n#ifdef RECEIVE_SHADOWS\n  shadow \x3d evalShadow(vpos, linearDepth, depthTex, shadowMapNum, shadowMapDistance, shadowMapMatrix, depthHalfPixelSz);\n#endif\n  float vndl \x3d dot(normalize(vnormal), lightDirection);\n  float k \x3d smoothstep(0.0, 1.0, clamp(vndl*diffuseHardness, 0.0, 1.0));\n  vec3 d \x3d (1.0 - shadow/1.8) * diffuse * k;\n  float ssao \x3d viewportPixelSz.w \x3c .0 ? 1.0 : texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n  vec4 tileColor \x3d texture2D(tex, vtc) * opacity;\n#ifdef OVERLAY\n  vec4 overlayColor  \x3d overlayOpacity * getOverlayColor(ovInnerColorTex, ovOuterColorTex, vtcOverlay);\n  tileColor \x3d tileColor * (1.0 - overlayColor.a) + overlayColor;\n#endif\n  if (rejectBySlice(vpos)) {\n    tileColor *\x3d sliceOpacity;\n  }\n  vec3 atm \x3d vec3(0.0);\n#ifdef ATMOSPHERE\n  float ndotl \x3d max(0.0, min(1.0, vndl));\n  atm \x3d atmosphere(wlight, wnormal, -viewDirection);\n  atm *\x3d max(0.0, min(1.0, (1.0-lum(tileColor.rgb)*1.5)));\n  atm *\x3d max(0.0, min(1.0, ndotl*2.0));\n  atm *\x3d tileColor.a;\n#endif\n  vec3 albedo \x3d atm + tileColor.rgb;\n  vec3 normal \x3d normalize(vnormal);\n  float additionalAmbientScale \x3d smoothstep(0.0, 1.0, clamp(vndl*2.5, 0.0, 1.0));\n  vec3 additionalLight \x3d ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n  gl_FragColor \x3d vec4(evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight), tileColor.a);\n#ifdef OVERLAY\n  vec4 overlayWaterMask \x3d getOverlayColor(ovInnerWaterTex, ovOuterWaterTex, vtcOverlay);\n  float waterNormalLength \x3d length(overlayWaterMask);\n  if (waterNormalLength \x3e 0.95) {\n    mat3 tbnMatrix \x3d mat3(tbnTangent, tbnBiTangent, vnormal);\n    vec4 waterColor \x3d overlayOpacity * getOverlayWaterColor(tileColor, overlayWaterMask, overlayColor, vpos, shadow, vnormal, camPos, tbnMatrix);\n    vec4 groundColor \x3d vec4(pow(gl_FragColor.rgb, vec3(2.2)), gl_FragColor.w);\n    waterColor \x3d mix(groundColor, waterColor, waterColor.a);\n    gl_FragColor \x3d vec4(pow(waterColor.rgb, vec3( GAMMA_EXP )), waterColor.a);\n  }\n#endif\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  float perspectiveScale \x3d screenSizePerspectiveScaleFloat(1.0, screenSizeCosAngle, screenSizeDistanceToCamera, screenSizePerspective);\n  if (perspectiveScale \x3c\x3d 0.25) {\n    gl_FragColor \x3d mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), perspectiveScale * 4.0);\n  }\n  else if (perspectiveScale \x3c\x3d 0.5) {\n    gl_FragColor \x3d mix(gl_FragColor, vec4(0.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.25) * 4.0);\n  }\n  else if (perspectiveScale \x3e\x3d 0.99) {\n    gl_FragColor \x3d mix(gl_FragColor, vec4(0.0, 1.0, 0.0, 1.0), 0.2);\n  }\n  else {\n    gl_FragColor \x3d mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.5) * 2.0);\n  }\n#endif\n#if defined(WIREFRAME_TEXTURE) || defined(TILE_BORDERS)\n  vec2 vuvScaled \x3d vuv * wireframe.subdivision;\n  vec2 vuvMod \x3d fract(vuvScaled);\n  vec2 dVuv \x3d fwidth(vuvScaled);\n  dVuv \x3d max(vec2(0.00001), dVuv);\n  vec2 edgeFactors \x3d smoothstep((wireframe.width - wireframe.falloff) * dVuv,\n                                wireframe.width * dVuv, min(vuvMod, 1.0 - vuvMod));\n  float edgeFactor \x3d 1.0 - min(edgeFactors.x, edgeFactors.y);\n#ifdef WIREFRAME_TEXTURE\n  vec3 wireframeColor \x3d mix(gl_FragColor.rgb, wireframe.color.rgb, edgeFactor * wireframe.color.a);\n  float wireframeAlpha \x3d mix(wireframe.surfaceOpacity, wireframe.wireOpacity, edgeFactor);\n  gl_FragColor \x3d vec4(wireframeColor * wireframeAlpha, wireframeAlpha * gl_FragColor.a);\n#endif\n#ifdef TILE_BORDERS\n  dVuv \x3d fwidth(vuv);\n  edgeFactors \x3d smoothstep((wireframe.width - wireframe.falloff) * dVuv,\n                            wireframe.width * dVuv, min(vuv, 1.0 - vuv));\n  edgeFactor \x3d 1.0 - min(edgeFactors.x, edgeFactors.y);\n  gl_FragColor \x3d mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), edgeFactor);\n#endif\n#endif\n  gl_FragColor \x3d highlightSlice(gl_FragColor, vpos);\n}",
"colorPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\n#include \x3cterrainRenderer/skirts.glsl\x3e\n#include \x3cmaterials/water/normalsUtils.glsl\x3e\nuniform mat4 proj;\nuniform mat4 view;\nuniform vec3 origin;\nuniform vec4 texOffsetAndScale;\nuniform mat4 viewNormal;\nuniform float skirtScale;\nattribute vec3 position;\nattribute vec2 uv0;\nvarying vec3 vnormal;\nvarying vec3 vpos;\nvarying vec2 vtc;\n#ifdef RECEIVE_SHADOWS\nvarying float linearDepth;\n#endif\n#if defined(WIREFRAME_TEXTURE) || defined(TILE_BORDERS)\nvarying vec2 vuv;\n#endif\n#ifdef ATMOSPHERE\nuniform vec3 lightDirection;\nvarying vec3 wnormal;\nvarying vec3 wlight;\n#endif\n#ifdef OVERLAY\nuniform vec4 overlayTexOffset;\nuniform vec4 overlayTexScale;\nvarying vec4 vtcOverlay;\nvarying vec3 tbnTangent;\nvarying vec3 tbnBiTangent;\n#endif\n#ifdef SCREEN_SIZE_PERSPECTIVE\nuniform vec4 screenSizePerspective;\nvarying float screenSizeDistanceToCamera;\nvarying float screenSizeCosAngle;\n#endif\nvoid main(void) {\n  vpos \x3d position;\n  vnormal \x3d getLocalUp(vpos, origin);\n  vec2 uv \x3d uv0;\n  vpos \x3d applySkirts(uv, vpos, vnormal, skirtScale);\n#ifdef ATMOSPHERE\n  wnormal \x3d (viewNormal * vec4(normalize(vpos+origin), 1.0)).xyz;\n  wlight \x3d (view  * vec4(lightDirection, 1.0)).xyz;\n#endif\n#if defined(WIREFRAME_TEXTURE) || defined(TILE_BORDERS)\n  vuv \x3d uv;\n#endif\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  vec3 viewPos \x3d (view * vec4(vpos, 1.0)).xyz;\n  screenSizeDistanceToCamera \x3d length(viewPos);\n  vec3 viewSpaceNormal \x3d (viewNormal * vec4(normalize(vpos + origin), 1.0)).xyz;\n  screenSizeCosAngle \x3d abs(viewSpaceNormal.z);\n#endif\n  gl_Position \x3d proj * view * vec4(vpos, 1.0);\n#ifdef RECEIVE_SHADOWS\n  linearDepth \x3d gl_Position.w;\n#endif\n  vtc \x3d uv * texOffsetAndScale.zw + texOffsetAndScale.xy;\n#ifdef OVERLAY\n  vtcOverlay \x3d vec4(uv, uv) * overlayTexScale + overlayTexOffset;\n  #if VIEWING_MODE \x3d\x3d VIEWING_MODE_GLOBAL\n    tbnTangent \x3d normalize(cross(vec3(0.0, 0.0, 1.0), vnormal));\n    tbnBiTangent \x3d normalize(cross(vnormal, tbnTangent));\n  #else\n    tbnTangent \x3d vec3(1.0, 0.0, 0.0);\n    tbnBiTangent \x3d normalize(cross(vnormal, tbnTangent));\n  #endif\n#endif\n}",
"depthPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\n#include \x3cutil/fsPrecision.glsl\x3e\n#include \x3cutil/encoding.glsl\x3e\n#include \x3cutil/depth.glsl\x3e\nvarying float depth;\nvarying vec3 vpos;\nvoid main() {\n#ifndef BIAS_SHADOWMAP\n  gl_FragColor \x3d float2rgba(depth);\n#else\n  gl_FragColor \x3d float2rgba(calcFragDepth(depth));\n#endif\n}","depthPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\n#include \x3cterrainRenderer/skirts.glsl\x3e\nuniform vec3 origin;\nuniform mat4 proj;\nuniform mat4 view;\nuniform vec2 nearFar;\nuniform float skirtScale;\nattribute vec3 position;\nattribute vec2 uv0;\nvarying float depth;\nvarying vec3 vpos;\nvoid main(void) {\n#if VIEWING_MODE \x3d\x3d VIEWING_MODE_GLOBAL\n  vec3 normal \x3d normalize(position + origin);\n#else\n  vec3 normal \x3d vec3(0.0, 0.0, 1.0);\n#endif\n  vec2 uv \x3d uv0;\n  vpos \x3d applySkirts(uv, position, normal.xyz, skirtScale);\n  vec4 eye \x3d view * vec4(vpos, 1.0);\n  gl_Position \x3d proj * eye;\n  depth \x3d (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;\n}",
"highlightPass.frag":"#include \x3cutil/fsPrecision.glsl\x3e\n#include \x3cutil/highlight.glsl\x3e\n#include \x3cterrainRenderer/overlay.glsl\x3e\nuniform sampler2D ovInnerColorTex;\nuniform sampler2D ovOuterColorTex;\nuniform float overlayOpacity;\nuniform sampler2D depthTex;\nuniform vec4 highlightViewportPixelSz;\nvarying vec4 vtcOverlay;\nvoid main() {\n  vec4 overlayColor \x3d getOverlayColor(ovInnerColorTex, ovOuterColorTex, vtcOverlay) * overlayOpacity;\n  if (overlayColor.a \x3d\x3d 0.0) {\n    gl_FragColor \x3d vec4(0.0);\n    return;\n  }\n  gl_FragColor \x3d highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n}",
"highlightPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\n#include \x3cterrainRenderer/skirts.glsl\x3e\nuniform vec3 origin;\nuniform mat4 proj;\nuniform mat4 view;\nuniform vec4 overlayTexScale;\nuniform vec4 overlayTexOffset;\nuniform float skirtScale;\nattribute vec3 position;\nattribute vec2 uv0;\nvarying vec3 vpos;\nvarying vec4 vtcOverlay;\nvoid main() {\n  #if VIEWING_MODE \x3d\x3d VIEWING_MODE_GLOBAL\n    vec3 vnormal \x3d normalize(position + origin);\n  #else\n    vec3 vnormal \x3d vec3(0.0, 0.0, 1.0);\n  #endif\n  vec2 uv \x3d uv0;\n  vpos \x3d applySkirts(uv, position, vnormal, skirtScale);\n  vtcOverlay \x3d vec4(uv, uv) * overlayTexScale + overlayTexOffset;\n  gl_Position \x3d proj * view * vec4(vpos, 1.0);\n}",
"normalPass.frag":"#include \x3cutil/fsPrecision.glsl\x3e\nvarying vec3 vnormal;\nvarying vec3 vpos;\nvoid main() {\n  vec3 normal \x3d normalize(vnormal);\n  if (gl_FrontFacing \x3d\x3d false) normal \x3d -normal;\n#ifndef ALPHA_ZERO\n  gl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 1.0);\n#else\n  gl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 0.0);\n#endif\n}","normalPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\n#include \x3cterrainRenderer/skirts.glsl\x3e\nuniform vec3 origin;\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 viewNormal;\nuniform float skirtScale;\nattribute vec3 position;\nattribute vec2 uv0;\nvarying vec3 vnormal;\nvarying vec3 vpos;\nvoid main(void) {\n#if VIEWING_MODE \x3d\x3d VIEWING_MODE_GLOBAL\n  vec4 normal \x3d vec4(normalize(position + origin), 1.0);\n#else\n  vec4 normal \x3d vec4(0.0, 0.0, 1.0, 1.0);\n#endif\n  vec2 uv \x3d uv0;\n  vpos \x3d applySkirts(uv, position, normal.xyz, skirtScale);\n  gl_Position \x3d proj * view * vec4(vpos, 1.0);\n  vnormal \x3d normalize((viewNormal * normal).xyz);\n}",
"overlay.glsl":"#include \x3cmaterials/water/waterSurface.glsl\x3e\n#include \x3cutil/color.glsl\x3e\nvec4 getOverlayColor(sampler2D ov0Tex, sampler2D ov1Tex, vec4 texCoords) {\n  vec4 color \x3d vec4(0.0);\n  vec4 color0 \x3d texture2D(ov0Tex, texCoords.xy);\n  vec4 color1 \x3d texture2D(ov1Tex, texCoords.zw);\n  if ((texCoords.x \x3e 0.0) \x26\x26 (texCoords.x \x3c 1.0) \x26\x26 (texCoords.y \x3e 0.0) \x26\x26 (texCoords.y \x3c 1.0)) {\n    color \x3d color0;\n  } else if ((texCoords.z \x3e 0.0) \x26\x26 (texCoords.z \x3c 1.0) \x26\x26 (texCoords.w \x3e 0.0) \x26\x26 (texCoords.w \x3c 1.0)) {\n    color \x3d color1;\n  }\n  return color;\n}\n#ifdef OVERLAY\nvec4 getOverlayWaterColor( in vec4 tileColor, vec4 maskInput, vec4 colorInput,\n                     vec3 vpos, float shadow, vec3 localUp, vec3 eye, mat3 tbn) {\n  vec3 n \x3d normalize(tbn *  (2.0 * maskInput.rgb - vec3(1.0)));\n  vec3 v \x3d -normalize(vpos - eye);\n  vec3 l \x3d normalize(-lightingMainDirection);\n  vec3 final \x3d getSeaColor(n, v, l, colorInput.rgb, localUp, 1.0 - shadow);\n  return premultiplyAlpha(vec4(final, colorInput.w));\n}\n#endif",
"skirts.glsl":"vec3 applySkirts(inout vec2 uv, vec3 vpos, vec3 vnormal, float skirtScale) {\n  float skirtLength \x3d 0.0;\n  if (uv.x \x3e\x3d 2.0) {\n    skirtLength \x3d uv.y * skirtScale;\n    vec2 x \x3d vec2(uv.x) - vec2(3.5, 4.5);\n    uv \x3d clamp(vec2(1.5) - abs(x), vec2(0.0), vec2(1.0));\n  }\n  return vpos - vnormal * skirtLength;\n}"},util:{"alignPixel.glsl":"vec4 alignToPixelCenter(vec4 clipCoord, vec2 widthHeight) {\n  vec2 xy \x3d vec2(.500123) + .5 * clipCoord.xy / clipCoord.w;\n  vec2 pixelSz \x3d vec2(1.0) / widthHeight;\n  vec2 ij \x3d (floor(xy * widthHeight) + vec2(0.5)) * pixelSz;\n  vec2 result \x3d (ij * 2.0 - vec2(1.0)) * clipCoord.w;\n  return vec4(result, clipCoord.zw);\n}\nvec4 alignToPixelOrigin(vec4 clipCoord, vec2 widthHeight) {\n  vec2 xy \x3d vec2(.5) + .5 * clipCoord.xy / clipCoord.w;\n  vec2 pixelSz \x3d vec2(1.0) / widthHeight;\n  vec2 ij \x3d floor((xy + .5 * pixelSz) * widthHeight) * pixelSz;\n  vec2 result \x3d (ij * 2.0 - vec2(1.0)) * clipCoord.w;\n  return vec4(result, clipCoord.zw);\n}",
"color.glsl":"vec4 premultiplyAlpha(vec4 v) {\n  return vec4(v.rgb * v.a, v.a);\n}\nvec3 rgb2hsv(vec3 c) {\n  vec4 K \x3d vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p \x3d mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n  vec4 q \x3d mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n  float d \x3d q.x - min(q.w, q.y);\n  float e \x3d 1.0e-10;\n  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c) {\n  vec4 K \x3d vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p \x3d abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}",
"depth.glsl":"#include \x3cutil/encoding.glsl\x3e\nfloat linearDepth(sampler2D depthTex, vec2 uv, vec2 nearFar) {\n  return -(rgba2float(texture2D(depthTex, uv)) * (nearFar[1] - nearFar[0]) + nearFar[0]);\n}\nfloat calcFragDepth(const in float depth) {\n  const float SLOPE_SCALE \x3d 2.0;\n  const float BIAS \x3d 2.0 * .000015259;\n  float m \x3d max(abs(dFdx(depth)), abs(dFdy(depth)));\n  float result \x3d depth + SLOPE_SCALE * m + BIAS;\n  return clamp(result, .0, .999999);\n}","doublePrecision.glsl":"vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n  vec3 t1 \x3d hiA + hiB;\n  vec3 e \x3d t1 - hiA;\n  vec3 t2 \x3d ((hiB - e) + (hiA - (t1 - e))) + loA + loB;\n  return t1 + t2;\n}",
"enableExtensions.glsl":"#define EXTENSIONS_ENABLED\n#extension GL_OES_standard_derivatives : enable\n#extension GL_EXT_shader_texture_lod : enable","encoding.glsl":"const float MAX_RGBA_FLOAT \x3d\n  255.0 / 256.0 +\n  255.0 / 256.0 / 256.0 +\n  255.0 / 256.0 / 256.0 / 256.0 +\n  255.0 / 256.0 / 256.0 / 256.0 / 256.0;\nconst vec4 fixedPointFactors \x3d vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\nvec4 float2rgba(const float value) {\n  float valueInValidDomain \x3d clamp(value, 0.0, MAX_RGBA_FLOAT);\n  vec4 fixedPointU8 \x3d floor(fract(valueInValidDomain * fixedPointFactors) * 256.0);\n  const float toU8AsFloat \x3d 1.0 / 255.0;\n  return fixedPointU8 * toU8AsFloat;\n}\nconst vec4 rgba2float_factors \x3d vec4(\n  255.0 / (256.0),\n  255.0 / (256.0 * 256.0),\n  255.0 / (256.0 * 256.0 * 256.0),\n  255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\n  return dot(rgba, rgba2float_factors);\n}",
"fsPrecision.glsl":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\nprecision highp sampler2D;\n#else\nprecision mediump float;\nprecision mediump sampler2D;\n#endif","highlight.glsl":"vec4 highlightData(vec4 fragCoord, sampler2D depthTex, vec4 viewportPixelSize) {\n  float sceneDepth \x3d texture2D(depthTex, (fragCoord.xy - viewportPixelSize.xy) * viewportPixelSize.zw).r;\n  if (fragCoord.z \x3e sceneDepth + 5e-7) {\n    return vec4(1.0, 1.0, 0.0, 1.0);\n  }\n  else {\n    return vec4(1.0, 0.0, 1.0, 1.0);\n  }\n}",
"hud.glsl":"#include \x3cutil/screenSizePerspective.glsl\x3e\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec4 auxpos1;\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 viewNormal;\nuniform mat4 model;\nuniform mat4 modelNormal;\nuniform vec4 viewport;\nuniform vec3 camPos;\nuniform float polygonOffset;\nuniform float cameraGroundRelative;\nuniform float pixelRatio;\nuniform float perDistancePixelRatio;\n#ifdef VERTICAL_OFFSET\nuniform vec4 verticalOffset;\n#endif\n#ifdef SCREEN_SIZE_PERSPECTIVE\nuniform vec4 screenSizePerspectiveAlignment;\n#endif\nuniform sampler2D hudVisibilityTexture;\nconst float SMALL_OFFSET_ANGLE \x3d 0.984807753012208;\nstruct ProjectHUDAux {\n  vec3 posModel;\n  vec3 posView;\n  vec3 vnormal;\n  float distanceToCamera;\n  float absCosAngle;\n};\nfloat applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {\n  float pointGroundSign \x3d sign(pointGroundDistance);\n  if (pointGroundSign \x3d\x3d 0.0) {\n    pointGroundSign \x3d cameraGroundRelative;\n  }\n  float groundRelative \x3d cameraGroundRelative * pointGroundSign;\n  if (polygonOffset \x3e .0) {\n    float cosAlpha \x3d clamp(absCosAngle, 0.01, 1.0);\n    float tanAlpha \x3d sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;\n    float factor \x3d (1.0 - tanAlpha / viewport[2]);\n    if (groundRelative \x3e 0.0) {\n      posView *\x3d factor;\n    }\n    else {\n      posView /\x3d factor;\n    }\n  }\n  return groundRelative;\n}\nvoid applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {\n  float distanceToCamera \x3d length(posView);\n  float pixelOffset \x3d distanceToCamera * perDistancePixelRatio * 0.5;\n  vec3 modelOffset \x3d normalModel * cameraGroundRelative * pixelOffset;\n  vec3 viewOffset \x3d (viewNormal * vec4(modelOffset, 1.0)).xyz;\n  posModel +\x3d modelOffset;\n  posView +\x3d viewOffset;\n}\nvec4 projectPositionHUD(out ProjectHUDAux aux) {\n  vec3 centerOffset \x3d auxpos1.xyz;\n  float pointGroundDistance \x3d auxpos1.w;\n  aux.posModel \x3d (model * vec4(position, 1.0)).xyz;\n  aux.posView \x3d (view * vec4(aux.posModel, 1.0)).xyz;\n  aux.vnormal \x3d (modelNormal * vec4(normal, 1.0)).xyz;\n  applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);\n  aux.distanceToCamera \x3d length(aux.posView);\n  vec3 viewDirObjSpace \x3d normalize(camPos - aux.posModel);\n  float cosAngle \x3d dot(aux.vnormal, viewDirObjSpace);\n  aux.absCosAngle \x3d abs(cosAngle);\n#ifdef SCREEN_SIZE_PERSPECTIVE\n#if defined(VERTICAL_OFFSET) || defined(CENTER_OFFSET_UNITS_SCREEN)\n  vec4 perspectiveFactor \x3d screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);\n#endif\n#endif\n#ifdef VERTICAL_OFFSET\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  float verticalOffsetScreenHeight \x3d applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);\n#else\n  float verticalOffsetScreenHeight \x3d verticalOffset.x;\n#endif\n  float worldOffset \x3d clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);\n  vec3 modelOffset \x3d aux.vnormal * worldOffset;\n  aux.posModel +\x3d modelOffset;\n  vec3 viewOffset \x3d (viewNormal * vec4(modelOffset, 1.0)).xyz;\n  aux.posView +\x3d viewOffset;\n  pointGroundDistance +\x3d worldOffset;\n#endif\n  float groundRelative \x3d applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);\n#ifndef CENTER_OFFSET_UNITS_SCREEN\n  aux.posView +\x3d vec3(centerOffset.x, centerOffset.y, 0.0);\n  if (centerOffset.z !\x3d 0.0) {\n    aux.posView -\x3d normalize(aux.posView) * centerOffset.z;\n  }\n#endif\n  vec4 posProj \x3d proj * vec4(aux.posView, 1.0);\n#ifdef CENTER_OFFSET_UNITS_SCREEN\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  float centerOffsetY \x3d applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);\n#else\n  float centerOffsetY \x3d centerOffset.y;\n#endif\n  posProj.xy +\x3d vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;\n#endif\n  posProj.z -\x3d groundRelative * polygonOffset * posProj.w;\n  return posProj;\n}\nuniform float uRenderTransparentlyOccludedHUD;\nbool testVisibilityHUD(vec4 posProj) {\n  vec4 posProjCenter \x3d alignToPixelCenter(posProj, viewport.zw);\n  vec4 occlusionPixel \x3d texture2D(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);\n  if (uRenderTransparentlyOccludedHUD \x3e 0.5) {\n    return occlusionPixel.r * occlusionPixel.g \x3e 0.0 \x26\x26 occlusionPixel.g * uRenderTransparentlyOccludedHUD \x3c 1.0;\n  }\n  else {\n    return occlusionPixel.r * occlusionPixel.g \x3e 0.0 \x26\x26 occlusionPixel.g \x3d\x3d 1.0;\n  }\n}",
"normalEncoding.glsl":"vec3 decodeNormal(vec2 f) {\n    float z \x3d 1.0 - abs(f.x) - abs(f.y);\n    return vec3(f + sign(f) * min(z, 0.0), z);\n}","pbrUtils.glsl":"struct PBRShading\n{\n    float NdotL;\n    float NdotV;\n    float NdotH;\n    float VdotH;\n    float LdotH;\n    float VdotN;\n};\nconst float PI_W \x3d 3.14159265;\n#ifdef OVERLAY\n  float dtrExponent \x3d 2.0;\n#else\n  uniform float dtrExponent;\n#endif\nvec3 fresnelReflection(float VdotH, vec3 f0, float f0Max) {\n    return f0 + (f0Max - f0) * pow(1.0 - VdotH, 5.0);\n}\nfloat normalDistributionWater(float NdotH, float roughness)\n{\n  float r2 \x3d roughness * roughness;\n  float NdotH2 \x3d NdotH * NdotH;\n  float denom \x3d pow((NdotH2 * (r2 - 1.0) + 1.0), dtrExponent) * PI_W;\n  return r2 / denom;\n}\nfloat geometricOcclusionKelemen(float LoH)\n{\n    return 0.25 / (LoH * LoH);\n}\nvec3 calculateSpecularReflectanceWater(in PBRShading props, float roughness, vec3 F0, float F0Max)\n{\n  vec3  F \x3d fresnelReflection(props.VdotH, F0, F0Max);\n  float D \x3d normalDistributionWater(props.NdotH, roughness);\n  float V \x3d geometricOcclusionKelemen(props.LdotH);\n  return (D * V) * F;\n}\nvec3 tonemapACES(const vec3 x) {\n  return (x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14);\n}",
"quad.vert":"#include \x3cutil/vsPrecision.glsl\x3e\nattribute vec2 position;\nvarying vec2 uv;\nvoid main(void) {\n  gl_Position \x3d vec4(position.x, position.y, .0, 1.0);\n  uv \x3d position * .5 + vec2(.5);\n}","sceneLighting.glsl":"uniform vec3 lightingMainDirection;\nuniform vec3 lightingMainIntensity;\n#ifndef SH_ORDER\n  #ifdef USE_PBR\n    #define SH_ORDER 0\n  #else\n    #define SH_ORDER 2\n  #endif\n#endif\n#if SH_ORDER \x3d\x3d 0\n  uniform vec3 lightingAmbientSH0;\n#elif SH_ORDER \x3d\x3d 1\n  uniform vec4 lightingAmbientSH_R;\n  uniform vec4 lightingAmbientSH_G;\n  uniform vec4 lightingAmbientSH_B;\n#elif SH_ORDER \x3d\x3d 2\n  uniform vec3 lightingAmbientSH0;\n  uniform vec4 lightingAmbientSH_R1;\n  uniform vec4 lightingAmbientSH_G1;\n  uniform vec4 lightingAmbientSH_B1;\n  uniform vec4 lightingAmbientSH_R2;\n  uniform vec4 lightingAmbientSH_G2;\n  uniform vec4 lightingAmbientSH_B2;\n#endif\nuniform float lightingFixedFactor;\nuniform float lightingGlobalFactor;\nuniform float ambientBoostFactor;\nuniform vec3 groundColor;\nconst float GAMMA \x3d 2.1;\nconst float PI \x3d 3.14159;\nconst float halfPI \x3d 1.57079;\nconst float invPI \x3d 0.318309;\nconst float skyIlluminationAngle \x3d 1.57079;\n#ifdef USE_PBR\n  #ifdef USE_PBR_CLEAR_COATING\n    uniform float clearCoating;\n    uniform float clearCoatRoughness;\n  #endif\n#endif\nconst vec3 clearCoatingFresnel \x3d vec3(0.04);\nstruct PBRShadingInfo\n{\n    float NdotL;\n    float NdotV;\n    float NdotH;\n    float VdotH;\n    float LdotH;\n    float NdotNG;\n    float RdotNG;\n    vec3 diffuseColor;\n    vec3 ambientSky;\n    vec3 ambientGround;\n    float ssao;\n    vec3 groundColor;\n    vec3 albedoLinear;\n    vec3 f0;\n    vec3 f90;\n    vec3 f0_ClearCoating;\n    vec3 f90_ClearCoating;\n    float roughnessClearCoating;\n    float coating;\n    float metalness;\n    float roughness;\n    float refraction;\n};\nvec3 calculateAmbientComponent(vec3 normal, float ssao)\n{\n  #if SH_ORDER \x3d\x3d 0\n    vec3 ambientLight \x3d 0.282095 * lightingAmbientSH0;\n  #elif SH_ORDER \x3d\x3d 1\n    vec4 sh0 \x3d vec4(\n      0.282095,\n      0.488603 * normal.x,\n      0.488603 * normal.z,\n      0.488603 * normal.y\n    );\n    vec3 ambientLight \x3d vec3(\n      dot(lightingAmbientSH_R, sh0),\n      dot(lightingAmbientSH_G, sh0),\n      dot(lightingAmbientSH_B, sh0)\n    );\n  #elif SH_ORDER \x3d\x3d 2\n    vec3 ambientLight \x3d 0.282095 * lightingAmbientSH0;\n    vec4 sh1 \x3d vec4(\n      0.488603 * normal.x,\n      0.488603 * normal.z,\n      0.488603 * normal.y,\n      1.092548 * normal.x * normal.y\n    );\n    vec4 sh2 \x3d vec4(\n      1.092548 * normal.y * normal.z,\n      0.315392 * (3.0 * normal.z * normal.z - 1.0),\n      1.092548 * normal.x * normal.z,\n      0.546274 * (normal.x * normal.x - normal.y * normal.y)\n    );\n    ambientLight +\x3d vec3(\n      dot(lightingAmbientSH_R1, sh1),\n      dot(lightingAmbientSH_G1, sh1),\n      dot(lightingAmbientSH_B1, sh1)\n    );\n    ambientLight +\x3d vec3(\n      dot(lightingAmbientSH_R2, sh2),\n      dot(lightingAmbientSH_G2, sh2),\n      dot(lightingAmbientSH_B2, sh2)\n    );\n  #endif\n  ambientLight *\x3d (1.0 - ssao);\n  return ambientLight;\n}\nvec3 evaluateSceneLighting(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight) {\n  #if defined(TREE_RENDERING)\n    float minDot \x3d -0.5;\n    float dotRange \x3d 1.0 - minDot;\n    float dotNormalization \x3d 0.66;\n    float dotVal \x3d dotNormalization * (clamp(-dot(normal, lightingMainDirection), 1.0 - dotRange, 1.0) - minDot) * (1.0 / dotRange);\n  #else\n    float dotVal \x3d clamp(-dot(normal, lightingMainDirection), 0.0, 1.0);\n  #endif\n  dotVal \x3d mix(dotVal, 1.0, lightingFixedFactor);\n  vec3 mainLight \x3d (1.0 - shadow) * lightingMainIntensity * dotVal;\n  vec3 ambientLight \x3d calculateAmbientComponent(normal, ssao);\n  vec3 albedoGammaC \x3d pow(albedo, vec3(GAMMA));\n  vec3 totalLight \x3d mainLight + ambientLight + additionalLight;\n  totalLight \x3d min(totalLight, vec3(PI, PI, PI));\n  vec3 outColor \x3d vec3((albedoGammaC / PI) * (totalLight));\n  outColor \x3d pow(outColor, vec3(1.0/GAMMA));\n  return outColor;\n}\nvec3 sceneLightingAdditionalLightGlobal(vec3 worldPos, float ssao, out float additionalAmbientScale) {\n#if VIEWING_MODE \x3d\x3d VIEWING_MODE_GLOBAL\n    float vndl \x3d -dot(normalize(worldPos), lightingMainDirection);\n#else\n    float vndl \x3d -dot(vec3(0.0, 0.0, 1.0), lightingMainDirection);\n#endif\n  additionalAmbientScale \x3d smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n  return ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n}\n#ifdef USE_PBR\n  vec3 fresnelReflection(float angle, vec3 f0, vec3 f90) {\n      return f0 + (f90 - f0) * pow(1.0 - angle, 5.0);\n  }\n  vec3 calculateDiffuseReflectanceFactor(PBRShadingInfo inputs)\n  {\n    return (1.0 - inputs.metalness) * inputs.albedoLinear * invPI;\n  }\n  float normalDistribution(float NdotH, float roughness)\n  {\n    float r2 \x3d roughness * roughness;\n    float NdotH2 \x3d NdotH * NdotH;\n    float denom \x3d (NdotH2 * (r2 - 1.0) + 1.0) * (NdotH2 * (r2 - 1.0) + 1.0) * PI;\n    return r2 / denom;\n  }\n  float geometricOcclusion(float NdotV, float NdotL, float roughness)\n  {\n      float a2 \x3d roughness * roughness;\n      float GGXL \x3d NdotV * sqrt((-NdotL * a2 + NdotL) * NdotL + a2);\n      float GGXV \x3d NdotL * sqrt((-NdotV * a2 + NdotV) * NdotV + a2);\n      return 0.5 / (GGXV + GGXL);\n  }\n  float geometricOcclusionKelemen(float LoH)\n  {\n      return 0.25 / (LoH * LoH);\n  }\n  vec3 calculateSpecularReflectanceFactor(PBRShadingInfo inputs, float roughness, vec3 f0, vec3 f90)\n  {\n    vec3  F \x3d fresnelReflection(inputs.VdotH, f0, f90);\n    float D \x3d normalDistribution(inputs.NdotH, roughness);\n    float V \x3d geometricOcclusion(inputs.NdotV, inputs.NdotL, roughness);\n    return (D * V) * F;\n  }\n  vec3 brdfPBR(PBRShadingInfo inputs)\n  {\n    vec3 diffuseComponent  \x3d calculateDiffuseReflectanceFactor(inputs);\n    vec3 specularComponent   \x3d calculateSpecularReflectanceFactor(inputs, inputs.roughness, inputs.f0, inputs.f90);\n    #ifdef USE_PBR_CLEAR_COATING\n      vec3  Fc \x3d fresnelReflection(inputs.LdotH, inputs.f0_ClearCoating, , inputs.f90_ClearCoating) * inputs.coating;\n      float Dc \x3d normalDistribution(inputs.NdotH, inputs.roughnessClearCoating);\n      float Vc \x3d geometricOcclusionKelemen(inputs.LdotH);\n      vec3 specularComponentCoating \x3d  (Dc * Vc) * Fc;\n      return (1.0 - inputs.ssao) * (diffuseComponent * (1.0-Fc) + specularComponent * (1.0-Fc) * (1.0-Fc) + specularComponentCoating);\n    #else\n      return (1.0 - inputs.ssao) * (diffuseComponent + specularComponent);\n    #endif\n  }\n  vec3 calculateGroundComponent(PBRShadingInfo inputs)\n  {\n    return inputs.groundColor * inputs.ambientSky;\n  }\n  vec2 prefilteredDFG_Analytical(PBRShadingInfo inputs) {\n      const vec4 c0 \x3d vec4(-1.0, -0.0275, -0.572,  0.022);\n      const vec4 c1 \x3d vec4( 1.0,  0.0425,  1.040, -0.040);\n      vec4 r \x3d inputs.roughness * c0 + c1;\n      float a004 \x3d min(r.x * r.x, exp2(-9.28 * inputs.NdotV)) * r.x + r.y;\n      return vec2(-1.04, 1.04) * a004 + r.zw;\n  }\n      vec3 evaluateIrradianceIntegral(float firstAngle, float secondAngle, PBRShadingInfo inputs)\n      {\n        float firstAngleClamped \x3d clamp(firstAngle, 0.0, halfPI);\n        float secondAngleClamped \x3d clamp(secondAngle, 0.0, halfPI);\n        float ground \x3d sin(firstAngleClamped) - sin(0.0) + sin(halfPI) - sin(secondAngleClamped);\n        float sky \x3d sin(secondAngleClamped) - sin(firstAngleClamped);\n        return ground * inputs.ambientGround + sky * inputs.ambientSky;\n      }\n      vec3 evaluateDiffuseIllumination_Analytical(PBRShadingInfo inputs)\n      {\n        float theta \x3d acos(max(min(inputs.NdotNG, 1.0), -1.0));\n        float firstAngle \x3d halfPI + theta - skyIlluminationAngle;\n        float secondAngle \x3d halfPI + theta + skyIlluminationAngle;\n        vec3 LeftIntegral \x3d evaluateIrradianceIntegral(halfPI - secondAngle, halfPI - firstAngle, inputs);\n        vec3 RightIntegral \x3d evaluateIrradianceIntegral(firstAngle - halfPI, secondAngle - halfPI, inputs);\n        vec3 ambientDiffuseLight \x3d (1.0 - inputs.ssao) * (LeftIntegral + RightIntegral) / 2.0;\n        return ambientDiffuseLight;\n      }\n      float integratedRadiance(float theta, float roughness)\n      {\n        float r4 \x3d pow(roughness, 4.0);\n        float r2 \x3d pow(roughness, 2.0);\n        float cosT2 \x3d cos(theta) * cos(theta);\n        float denom_1 \x3d (cosT2 * (2.0 * r4 - 4.0 * r2 + 2.0) + 2.0 * r2 - 2.0);\n        float denom_2 \x3d (2.0 * r4 - 2.0 * r2);\n        float integral \x3d 2.0 * r2 * (1.0 / denom_1 - 1.0 / denom_2);\n        return integral;\n      }\n      vec3 evaluateRadianceIntegral(float firstAngle, float secondAngle, PBRShadingInfo inputs, float roughness)\n      {\n        float firstAngleClamped \x3d clamp(firstAngle, 0.0, halfPI);\n        float secondAngleClamped \x3d clamp(secondAngle, 0.0, halfPI);\n        float ro \x3d roughness;\n        float ground \x3d integratedRadiance(firstAngleClamped, ro) - integratedRadiance(0.0, ro) + integratedRadiance(halfPI, ro) - integratedRadiance(secondAngleClamped, ro);\n        float sky \x3d integratedRadiance(secondAngleClamped, ro) - integratedRadiance(firstAngleClamped, ro);\n        return ground * inputs.ambientGround + sky * inputs.ambientSky;\n      }\n      vec3 evaluateSpecularIllumination_Analytical(PBRShadingInfo inputs, float RdotNG, float roughness)\n      {\n        float theta \x3d acos(max(min(RdotNG, 1.0), -1.0));\n        float firstPoint \x3d - halfPI + theta + skyIlluminationAngle;\n        float secondPoint \x3d - halfPI + theta - skyIlluminationAngle;\n        vec3 LeftIntegral \x3d evaluateRadianceIntegral(halfPI - firstPoint, halfPI - secondPoint, inputs, roughness);\n        vec3 RightIntegral \x3d evaluateRadianceIntegral(secondPoint - halfPI, firstPoint - halfPI, inputs, roughness);\n        vec3 enviromentSpecularLight \x3d (1.0 - inputs.ssao) * (LeftIntegral + RightIntegral) / 2.0;\n        return enviromentSpecularLight;\n      }\n  vec3 evaluateEnviromentIllumination(PBRShadingInfo inputs) {\n      vec3 indirectDiffuse \x3d evaluateDiffuseIllumination_Analytical(inputs);\n      vec3 indirectSpecular \x3d evaluateSpecularIllumination_Analytical(inputs, inputs.RdotNG, inputs.roughness);\n      vec3 diffuseComponent \x3d inputs.diffuseColor * indirectDiffuse * invPI;\n      vec2 dfg \x3d prefilteredDFG_Analytical(inputs);\n      vec3 specularColor \x3d inputs.f0 * dfg.x + 1.0 * dfg.y;\n      vec3 specularComponent \x3d specularColor * indirectSpecular;\n      #ifdef USE_PBR_CLEAR_COATING\n        vec3 Fc \x3d fresnelReflection(inputs.NdotV, inputs.f0_ClearCoating) * inputs.coating;\n        diffuseComponent  *\x3d 1.0 - Fc;\n        specularComponent *\x3d (1.0 - Fc) * (1.0 - Fc);\n        specularComponent +\x3d evaluateSpecularIllumination_Analytical(inputs, inputs.RdotNG, inputs.roughnessClearCoating) * Fc;\n      #endif\n      return (diffuseComponent + specularComponent);\n  }\n  vec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, float _roughness, float _metalness, vec3 _emission)\n  {\n    vec3 viewDirection \x3d - normalize(viewDir);\n    vec3 mainLightDirection \x3d -lightingMainDirection;\n    vec3 h \x3d normalize(viewDirection + mainLightDirection);\n    PBRShadingInfo inputs;\n    inputs.NdotL \x3d clamp(dot(normal, mainLightDirection), 0.001, 1.0);\n    inputs.NdotV \x3d clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);\n    inputs.NdotH \x3d clamp(dot(normal, h), 0.0, 1.0);\n    inputs.VdotH \x3d clamp(dot(viewDirection, h), 0.0, 1.0);\n    inputs.LdotH \x3d clamp(dot(mainLightDirection, h), 0.0, 1.0);\n    inputs.NdotNG \x3d clamp(dot(normal, normalize(normalGround)), -1.0, 1.0);\n    vec3 reflectedView \x3d normalize(reflect(viewDirection, normal));\n    inputs.refraction \x3d dot(viewDirection, normal);\n    inputs.RdotNG \x3d clamp(dot(reflectedView, normalize(normalGround)), -1.0, 1.0);\n    inputs.albedoLinear \x3d pow(albedo, vec3(GAMMA));\n    inputs.groundColor \x3d pow(vec3(0.5, 0.5, 0.5), vec3(GAMMA));\n    inputs.ssao \x3d ssao;\n    inputs.roughness \x3d clamp(_roughness * _roughness, 0.001, 0.99);\n    inputs.metalness \x3d _metalness;\n    inputs.f0 \x3d vec3(0.04) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;\n    inputs.f90 \x3d vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0));\n    inputs.diffuseColor \x3d inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);\n    #ifdef USE_PBR_CLEAR_COATING\n      inputs.f0_ClearCoating \x3d clearCoatingFresnel;\n      inputs.f90_ClearCoating \x3d vec3(clamp(dot(inputs.f0_ClearCoating, vec3(50.0 * 0.33)), 0.0, 1.0));\n      float clearCoatRoughnessLinear \x3d mix(0.089, 0.6, clearCoatRoughness);\n      inputs.roughnessClearCoating \x3d clearCoatRoughnessLinear * clearCoatRoughnessLinear;\n      inputs.coating \x3d clearCoating;\n    #endif\n    inputs.ambientSky    \x3d calculateAmbientComponent(normal, ssao) * 1.2 - 0.2;\n    inputs.ambientGround \x3d calculateGroundComponent(inputs);\n    inputs.NdotL \x3d mix(inputs.NdotL, 1.0, lightingFixedFactor);\n    vec3 enviromentComponent \x3d evaluateEnviromentIllumination(inputs);\n    vec3 additionalLightComponents \x3d inputs.albedoLinear * (additionalLight) * invPI;\n    vec3 reflectanceFactor \x3d brdfPBR(inputs);\n    vec3 incidentLight  \x3d  inputs.NdotL * (1.0 - shadow) * lightingMainIntensity;\n    vec3 outColorLinear \x3d  incidentLight * reflectanceFactor + enviromentComponent + additionalLightComponents + pow(_emission, vec3(GAMMA));\n    vec3 outColor \x3d pow(outColorLinear, vec3(1.0/GAMMA));\n    return outColor;\n  }\n#endif",
"screenSizePerspective.glsl":"float screenSizePerspectiveMinSize(float size, vec4 factor) {\n  float nonZeroSize \x3d 1.0 - step(size, 0.0);\n  return (\n    factor.z * (\n      1.0 +\n      nonZeroSize *\n      2.0 * factor.w / (\n        size + (1.0 - nonZeroSize)\n      )\n    )\n  );\n}\nfloat screenSizePerspectiveViewAngleDependentFactor(float absCosAngle) {\n  return absCosAngle * absCosAngle * absCosAngle;\n}\nvec4 screenSizePerspectiveScaleFactor(float absCosAngle, float distanceToCamera, vec4 params) {\n  return vec4(min(params.x / (distanceToCamera - params.y), 1.0), screenSizePerspectiveViewAngleDependentFactor(absCosAngle), params.z, params.w);\n}\nfloat applyScreenSizePerspectiveScaleFactorFloat(float size, vec4 factor) {\n  return max(mix(size * factor.x, size, factor.y), screenSizePerspectiveMinSize(size, factor));\n}\nfloat screenSizePerspectiveScaleFloat(float size, float absCosAngle, float distanceToCamera, vec4 params) {\n  return applyScreenSizePerspectiveScaleFactorFloat(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));\n}\nvec2 applyScreenSizePerspectiveScaleFactorVec2(vec2 size, vec4 factor) {\n  return mix(size * clamp(factor.x, screenSizePerspectiveMinSize(size.y, factor) / size.y, 1.0), size, factor.y);\n}\nvec2 screenSizePerspectiveScaleVec2(vec2 size, float absCosAngle, float distanceToCamera, vec4 params) {\n  return applyScreenSizePerspectiveScaleFactorVec2(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));\n}",
"shadow.glsl":"#include \x3cutil/encoding.glsl\x3e\nfloat evalShadow(const in vec3 vpos, const in float depth, const in sampler2D depthTex, const int num, const in vec4 distance, in mat4 matrix[4], const in float halfPxSz) {\n  int i \x3d depth \x3c distance[1] ? 0 : depth \x3c distance[2] ? 1 : depth \x3c distance[3] ? 2 : 3;\n  if (i \x3e\x3d num) { return .0; }\n  mat4 mat \x3d i \x3d\x3d 0 ? matrix[0] : i \x3d\x3d 1 ? matrix[1] : i \x3d\x3d 2 ? matrix[2] : matrix[3];\n  vec4 lv \x3d mat * vec4(vpos, 1.0);\n  lv.xy /\x3d lv.w;\n  vec3 lvpos \x3d .5 * lv.xyz + vec3(.5);\n  if (lvpos.z \x3e\x3d 1.0) { return .0; }\n  if (lvpos.x \x3c .0 || lvpos.x \x3e 1.0 || lvpos.y \x3c .0 || lvpos.y \x3e 1.0) { return .0; }\n  vec2 uv \x3d vec2(float(i - 2 * (i / 2)) *.5, float(i / 2) * .5) + .5 * lvpos.xy;\n  float texSize \x3d .5 / halfPxSz;\n  vec2 st \x3d fract((vec2(halfPxSz) + uv) * texSize);\n  float s00 \x3d rgba2float(texture2D(depthTex, uv + vec2(-halfPxSz, -halfPxSz))) \x3c lvpos.z ? 1.0 : .0;\n  float s10 \x3d rgba2float(texture2D(depthTex, uv + vec2(halfPxSz, -halfPxSz))) \x3c lvpos.z ? 1.0 : .0;\n  float s11 \x3d rgba2float(texture2D(depthTex, uv + vec2(halfPxSz, halfPxSz))) \x3c lvpos.z ? 1.0 : .0;\n  float s01 \x3d rgba2float(texture2D(depthTex, uv + vec2(-halfPxSz, halfPxSz))) \x3c lvpos.z ? 1.0 : .0;\n  return mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);\n}",
"slice.glsl":"#ifdef SLICE\nuniform vec3 slicePlaneOrigin;\nuniform vec3 slicePlaneBasis1;\nuniform vec3 slicePlaneBasis2;\nstruct SliceFactors {\n  float front;\n  float side0;\n  float side1;\n  float side2;\n  float side3;\n};\nSliceFactors calculateSliceFactors(vec3 pos) {\n  vec3 rel \x3d pos - slicePlaneOrigin;\n  vec3 slicePlaneNormal \x3d -cross(slicePlaneBasis1, slicePlaneBasis2);\n  float slicePlaneW \x3d -dot(slicePlaneNormal, slicePlaneOrigin);\n  float basis1Len2 \x3d dot(slicePlaneBasis1, slicePlaneBasis1);\n  float basis2Len2 \x3d dot(slicePlaneBasis2, slicePlaneBasis2);\n  float basis1Dot \x3d dot(slicePlaneBasis1, rel);\n  float basis2Dot \x3d dot(slicePlaneBasis2, rel);\n  return SliceFactors(\n    dot(slicePlaneNormal, pos) + slicePlaneW,\n    -basis1Dot - basis1Len2,\n    basis1Dot - basis1Len2,\n    -basis2Dot - basis2Len2,\n    basis2Dot - basis2Len2\n  );\n}\nbool sliceByFactors(SliceFactors factors) {\n  return factors.front \x3c 0.0\n    \x26\x26 factors.side0 \x3c 0.0\n    \x26\x26 factors.side1 \x3c 0.0\n    \x26\x26 factors.side2 \x3c 0.0\n    \x26\x26 factors.side3 \x3c 0.0;\n}\nbool sliceByPlane(vec3 pos) {\n  return sliceByFactors(calculateSliceFactors(pos));\n}\n#ifdef EXTENSIONS_ENABLED\nvec4 applySliceHighlight(vec4 color, vec3 pos) {\n  SliceFactors factors \x3d calculateSliceFactors(pos);\n  if (sliceByFactors(factors)) {\n    return color;\n  }\n  const float HIGHLIGHT_WIDTH \x3d 1.0;\n  const vec4 HIGHLIGHT_COLOR \x3d vec4(0.0, 0.0, 0.0, 0.3);\n  factors.front /\x3d (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.front);\n  factors.side0 /\x3d (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side0);\n  factors.side1 /\x3d (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side1);\n  factors.side2 /\x3d (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side2);\n  factors.side3 /\x3d (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side3);\n  float highlightFactor \x3d (1.0 - step(0.5, factors.front))\n    * (1.0 - step(0.5, factors.side0))\n    * (1.0 - step(0.5, factors.side1))\n    * (1.0 - step(0.5, factors.side2))\n    * (1.0 - step(0.5, factors.side3));\n  return mix(color, vec4(HIGHLIGHT_COLOR.rgb, color.a), highlightFactor * HIGHLIGHT_COLOR.a);\n}\n#else\n#endif\n#define rejectBySlice(_pos_) sliceByPlane(_pos_)\n#define discardBySlice(_pos_) { if (sliceByPlane(_pos_)) discard; }\n#ifdef SLICE_HIGHLIGHT_DISABLED\n#define highlightSlice(_color_, _pos_) (_color_)\n#else\n#define highlightSlice(_color_, _pos_) applySliceHighlight(_color_, _pos_)\n#endif\n#else\n#define rejectBySlice(_pos_) false\n#define discardBySlice(_pos_) {}\n#define highlightSlice(_color_, _pos_) (_color_)\n#endif",
"visualVariables.glsl":"#if defined(VV_SIZE)\n  #define VV_CUSTOM_MODEL_MATRIX\n#endif\n#if defined(VV_SIZE)\n  uniform vec3 vvSizeMinSize;\n  uniform vec3 vvSizeMaxSize;\n  uniform vec3 vvSizeOffset;\n  uniform vec3 vvSizeFactor;\n#elif defined(VV_CUSTOM_MODEL_MATRIX)\n  uniform vec3 vvSizeValue;\n#endif\n#ifdef VV_CUSTOM_MODEL_MATRIX\n  uniform mat3 vvSymbolRotationMatrix;\n#endif\n#ifdef VV_CUSTOM_MODEL_MATRIX\n  uniform vec3 vvSymbolAnchor;\n#endif\n#ifdef VV_COLOR\n  #define VV_COLOR_N 8\n  uniform float vvColorValues[VV_COLOR_N];\n  uniform vec4 vvColorColors[VV_COLOR_N];\n#endif\n#if defined(VV_SIZE)\n  vec3 vvGetScale(vec4 featureAttribute) {\n    return clamp(vvSizeOffset + featureAttribute.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize);\n  }\n#elif defined(VV_CUSTOM_MODEL_MATRIX)\n  vec3 vvGetScale(vec4 featureAttribute) {\n    return vvSizeValue;\n  }\n#endif\n#ifdef VV_CUSTOM_MODEL_MATRIX\n  vec4 vvTransformPosition(vec3 position, vec4 featureAttribute) {\n    return vec4(vvSymbolRotationMatrix * (vvGetScale(featureAttribute) * (position + vvSymbolAnchor)), 1.0);\n  }\n  vec4 vvTransformNormal(vec3 normal, vec4 featureAttribute) {\n    return vec4(vvSymbolRotationMatrix * normal / vvGetScale(featureAttribute), 1.0);\n  }\n#endif\n#ifdef VV_COLOR\n  vec4 vvGetColor(vec4 featureAttribute, float values[VV_COLOR_N], vec4 colors[VV_COLOR_N]) {\n    float value \x3d featureAttribute.y;\n    if (value \x3c\x3d values[0]) {\n      return colors[0];\n    }\n    for (int i \x3d 1; i \x3c VV_COLOR_N; ++i) {\n      if (values[i] \x3e\x3d value) {\n        float f \x3d (value - values[i-1]) / (values[i] - values[i-1]);\n        return mix(colors[i-1], colors[i], f);\n      }\n    }\n    return colors[VV_COLOR_N - 1];\n  }\n#endif",
"vsPrecision.glsl":"precision highp float;\nprecision highp sampler2D;"}}});